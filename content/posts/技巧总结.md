---
title: 技巧总结
subtitle:
date: 2024-07-26T10:21:56+08:00
draft: false
author:
  name: 瞻鹤
  link:
  email: he-zhan@outlook.com
  avatar: /images/avatar.jpg
description:
keywords: 
license:
comment: false
weight: 0
tags:
  - 算法
categories:
  - 算法和数据结构
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRss: false
hiddenFromRelated: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
password:
message:
repost:
  enable: true
  url:

# See details front matter: https://fixit.lruihao.cn/documentation/content-management/introduction/#front-matter
---

<!--more-->	

#### 随机哈希值

使用random_device和mt19937生成随机哈希值，用法如下：

```c++
random_device rd;
mt19937 mt(rd());
ull myhash = mt();
```

#### 阶乘and阶乘逆元

线性递推求阶乘逆元：

~~~c++
ll fact[N], inv[N];
inv[n] = ksm(fact[n], mod - 2, mod);//先求最后一项的逆元
for(int i = n - 1; i >= 0; i--)
    inv[i] = inv[i + 1] * (i + 1) % mod; //递推求逆元
~~~

#### 存2到m因子

~~~ c++
    std::vector<std::vector<int>> d(m + 1);
    for (int i = 1; i <= m; i++) {
        for (int j = 2 * i; j <= m; j += i) {
            d[j].push_back(i);
        }
    }
~~~

#### 区间 约束下求某点贡献最大值

现在小w正在玩一款经典游戏——大鱼吃小鱼。     游戏规则如下：玩家操控一条初始重量为 $\mathrm{x}$ 的鱼，它的目标是吃掉所有**不超过**自身当前重量的鱼。每当吃掉一条重量为 $\mathrm{y}$ 的鱼，那么自身重量也会立即增长 $\mathrm{y}$。     在游戏过程中，共会陆续出现 $\mathrm{n}$ 条鱼。其中第 $\mathrm{i}$ 条鱼重 $\mathrm{y_i}$，其出现时间段为 $\mathrm{\left[l_i,r_i\right)}$，即这条鱼会在时刻 $\mathrm{l_i}$ 出现，并在时刻 $\mathrm{r_i}$ 前消失（**包含** $\mathrm{l_i}$ **但不包含** $\mathrm{r_i}$）。只有当前时刻位于 $\mathrm{\left[l_i,r_i\right)}$​ 时，小w才能操作自己的鱼去吃掉它。     鉴于小w的手速非凡，吃鱼的耗时可以忽略不计。不过最近他懒癌犯了，因此他打算只选择某一时刻进行捕食，并最大化他的鱼的重量。请计算他的鱼可能达到的最大重量。

数据范围：

$\mathrm{n,x}(\mathrm{1 \le n \le 10^5},\mathrm{\sum n \le 10^5},\mathrm{1 \le x \le 10^9})$​

$\mathrm{l_i,r_i,y_i}(\mathrm{1 \le l_i < r_i \le 10^9},\mathrm{1 \le y_i \le 10^9})$ 

解法：离散化+树状数组+暴力枚举

从小到大枚举区间可行的右边界，优先队列处理存在交集的区间，树状数组维护枚举点可以获得的贡献。

初始是x值，贪心处理每次吃完≤x的所有值，替换x，直到x不再变化。

~~~ c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
struct Fenwick{
    int n;
    vector<ll> tr;
    void resize(ll m){
        n = m;
        tr.resize(n + 1);
        for(int i = 0; i <= m; i++)    tr[i] = 0;
    }
    void update(ll u, ll x){
        for(int i = u; i <= n; i += i & -i)
            tr[i] += x;
    }
    ll query(ll x){
        ll sum = 0;
        for(int i = x; i >= 1; i -= i & -i)    sum += tr[i];
        return sum;
    }
    ll query(ll l, ll r){
        return query(r) - query(l - 1);
    }
}tr;
void solve(){
    ll n, x;
    cin >> n >> x;
    vector<ll> l(n + 1), r(n + 1), y(n + 1,0);
    set<ll>  it;
    vector<pair<ll,ll>> f;
    for(ll i = 1; i <= n; i++){
        cin >> l[i] >> r[i] >> y[i];
        it.insert(r[i] - 1);
        f.push_back({l[i], i});
    }
    sort(f.begin(), f.end(), [&](pair<ll,ll> a, pair<ll,ll> b){
        return a.first < b.first;
    });
    //双指针枚举，一个枚举选择的计算点（右边界从小到大排序），一个枚举区间计算有交集的区域（左边界从小到大排序）
    //保证每个区间只枚举到一次
    vector<ll> tmp = y;
    map<ll,ll> mp;
    ll cnt = 0;
    sort(tmp.begin(), tmp.end());
    tmp.erase(unique(tmp.begin(),tmp.end()), tmp.end());
    priority_queue<pair<ll,ll>,vector<pair<ll,ll>>, greater<>> que;
    for(auto i : tmp) mp[i] = cnt++;
    tr.resize(cnt + 5);
    ll ans = x;
    ll pos = 0;
    for(auto i : it){
        while(pos < n && f[pos].first <= i){
            que.push({r[f[pos].second], f[pos].second});
            tr.update(mp[y[f[pos].second]], y[f[pos].second]);
            pos++;
        }
        while(!que.empty() && que.top().first <= i){
            auto [dr, id] = que.top();
            que.pop();
            tr.update(mp[y[id]], -y[id]);
        }
        //que中存和当前枚举点有交集的区间
        //数状数组存离散后的贡献
        ll num = 0, last = x;
        while(num != last){
            num = last;
            ll pos = lower_bound(tmp.begin(), tmp.end(), last) - tmp.begin();
            if(tmp[pos] > last)
                last = x + tr.query(pos - 1);
            else
                last = x + tr.query(pos);
        }
        //计算可以获得的最大贡献
        ans = max(ans, last);
    }
    cout << ans << '\n';
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
~~~

#### map到vector

~~~ c++
map<int,int> mp;
//or unordered_map
vector<pair<int,int>> v(mp.begin(), vp.end());
~~~

