---
title: 第十二周预习报告
subtitle:
date: 2024-12-01T12:11:56+08:00
draft: false
author:
  name: 瞻鹤
  link:
  email: he-zhan@outlook.com
  avatar: /images/avatar.jpg
description:
keywords:
license:
comment: false
weight: 0
tags:
  - 
categories:
  - homework
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRss: false
hiddenFromRelated: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
password:
message:
repost:
  enable: true
  url:

# See details front matter: https://fixit.lruihao.cn/documentation/content-management/introduction/#front-matter
---

<!--more-->	

[toc]

# 第十二周预习报告

## 学习内容 

- 学习内容

- Head First C 嗨翻 C 语⾔ 第12章

- 课程 mindmap

- 报告内容参考第⼀周


### AI对学习内容的总结

#### 要求

- 让AI（kimi，元宝等）阅读学习内容并进⾏总结，教材内容可以使⽤微信读书或者云班课电⼦教材

#### 总结

##### 《Head First C 嗨翻 C 语⾔ 》第12章

PDF文件《Head.First.C.12.pdf》的内容是关于C语言中多线程编程的一章。以下是该章节的学习内容总结：

### 第12章：多线程编程

 1. 多线程的引入
- **并行世界**：程序经常需要同时执行多个任务，POSIX线程（pthread）可以帮助代码并行运行，提高响应性。
- **线程与进程**：相比于进程，线程创建更快，能够共享数据，并且代码更简洁。

 2. 并行工作
- **任务的并行性**：例如，在编写游戏时，需要同时更新屏幕图形、计算游戏中移动物体的位置、读取控制器或键盘的控制信息等。
- **进程的局限性**：进程创建耗时，数据共享困难，且代码复杂。

 3. 单线程执行
- **简单进程**：简单进程一次只能做一件事，类似于单人经营的商店，无法同时处理多项任务。

 4. 使用线程
- **多线程程序**：类似于多人工作的商店，可以同时进行多项任务，每个线程可以分配不同的任务并同时执行。

 5. 创建线程
- **pthread库**：使用POSIX线程库（pthread）来创建和管理线程。
- **线程函数**：线程函数需要有`void*`返回类型，即使没有实际的返回值，也需要返回`NULL`。

 6. 线程的同步
- **线程安全**：多个线程访问同一数据时可能会出现竞态条件，需要使用互斥锁（mutex）来保护共享数据。
- **互斥锁（Mutex）**：互斥锁是一种简单的线程同步机制，确保任一时刻只有一个线程可以访问共享资源。

 7. 传递长整型值给线程函数
- **void指针参数**：线程函数接受一个`void*`参数，可以通过长整型值（long）来传递和返回整数值。

 8. 锁定策略
- **啤酒磁铁示例**：通过一个例子说明了不同的锁定策略如何影响多线程程序的输出结果。

 9. 线程与性能
- **线程与速度**：线程可以帮助更充分利用处理器和核心，但如果线程频繁锁定，代码可能不会比单线程代码快。
- **死锁**：当两个线程互相等待对方持有的互斥锁时，会发生死锁，导致程序停滞。

 10. C语言工具箱
- **线程和进程**：介绍了线程是轻量级进程，以及如何使用`pthread_create()`和`pthread_join()`来创建和管理线程。

 11. 实验：Blasteroids游戏
- **游戏开发**：使用Allegro游戏开发库来创建一个名为Blasteroids的街机游戏，涉及到键盘控制、图形绘制、事件处理和游戏逻辑。

这个章节为读者提供了关于如何在C语言中使用多线程的基础知识，包括线程的创建、同步以及如何避免常见的多线程问题。通过实际的游戏开发项目，读者可以将这些概念应用于实践中。

### 对AI总结的反思

#### 要求

- AI总结的问题

#### 反思

- AI总结比较精简，适合作为提纲、导图等方式指导学习，更有助于分配自己的学习时间和精力

### 学习思维导图

#### 要求

- Mermaid 代码与截图(参考Mermaid MindMap语法)或者提交思维导图链接（如果使用线上编辑器，推荐processon,xmind,...）

#### 思维导图

代码:

~~~ markdown
mindmap
    root(C语言多线程编程)
        sub章1(多线程基础)
            sub节1_1(并行世界)
                详细1_1_1(程序需要同时执行多个任务)
                详细1_1_2(POSIX线程提高代码响应性)
            sub节1_2(线程与进程比较)
                详细1_2_1(进程创建耗时)
                详细1_2_2(进程间数据共享困难)
                详细1_2_3(线程创建快速且易于共享数据)
        sub章2(并行工作)
            sub节2_1(任务的并行性)
                详细2_1_1(游戏编程中的多任务需求)
            sub节2_2(进程局限性)
                详细2_2_1(进程创建效率低)
                详细2_2_2(进程数据共享不便)
        sub章3(单线程与多线程)
            sub节3_1(单线程执行)
                详细3_1_1(简单进程一次只能做一件事)
            sub节3_2(多线程程序)
                详细3_2_1(多个线程同时进行多项任务)
        sub章4(创建线程)
            sub节4_1(使用pthread库)
                详细4_1_1(创建和管理线程)
            sub节4_2(线程函数要求)
                详细4_2_1(线程函数需要void*返回类型)
        sub章5(线程同步)
            sub节5_1(线程安全问题)
                详细5_1_1(多线程访问同一数据的竞态条件)
            sub节5_2(互斥锁Mutex)
                详细5_2_1(保护共享数据的线程同步机制)
        sub章6(线程函数参数传递)
            sub节6_1(传递长整型值)
                详细6_1_1(使用void指针传递整数值)
        sub章7(锁定策略)
            sub节7_1(啤酒磁铁示例)
                详细7_1_1(不同锁定策略影响输出结果)
        sub章8(线程与性能)
            sub节8_1(线程与速度)
                详细8_1_1(线程利用多核处理器)
                详细8_1_2(线程频繁锁定导致效率低下)
            sub节8_2(死锁)
                详细8_2_1(线程等待对方持有的互斥锁)
        sub章9(C语言工具箱)
            sub节9_1(线程和进程)
                详细9_1_1(线程是轻量级进程)
                详细9_1_2(使用pthread_create和pthread_join管理线程)
        sub章10(实验：Blasteroids游戏)
            sub节10_1(游戏开发)
                详细10_1_1(使用Allegro库创建街机游戏)
                详细10_1_2(涉及键盘控制、图形绘制、事件处理)
~~~



~~~ mermaid
mindmap
    root(C语言多线程编程)
        sub章1(多线程基础)
            sub节1_1(并行世界)
                详细1_1_1(程序需要同时执行多个任务)
                详细1_1_2(POSIX线程提高代码响应性)
            sub节1_2(线程与进程比较)
                详细1_2_1(进程创建耗时)
                详细1_2_2(进程间数据共享困难)
                详细1_2_3(线程创建快速且易于共享数据)
        sub章2(并行工作)
            sub节2_1(任务的并行性)
                详细2_1_1(游戏编程中的多任务需求)
            sub节2_2(进程局限性)
                详细2_2_1(进程创建效率低)
                详细2_2_2(进程数据共享不便)
        sub章3(单线程与多线程)
            sub节3_1(单线程执行)
                详细3_1_1(简单进程一次只能做一件事)
            sub节3_2(多线程程序)
                详细3_2_1(多个线程同时进行多项任务)
        sub章4(创建线程)
            sub节4_1(使用pthread库)
                详细4_1_1(创建和管理线程)
            sub节4_2(线程函数要求)
                详细4_2_1(线程函数需要void*返回类型)
        sub章5(线程同步)
            sub节5_1(线程安全问题)
                详细5_1_1(多线程访问同一数据的竞态条件)
            sub节5_2(互斥锁Mutex)
                详细5_2_1(保护共享数据的线程同步机制)
        sub章6(线程函数参数传递)
            sub节6_1(传递长整型值)
                详细6_1_1(使用void指针传递整数值)
        sub章7(锁定策略)
            sub节7_1(啤酒磁铁示例)
                详细7_1_1(不同锁定策略影响输出结果)
        sub章8(线程与性能)
            sub节8_1(线程与速度)
                详细8_1_1(线程利用多核处理器)
                详细8_1_2(线程频繁锁定导致效率低下)
            sub节8_2(死锁)
                详细8_2_1(线程等待对方持有的互斥锁)
        sub章9(C语言工具箱)
            sub节9_1(线程和进程)
                详细9_1_1(线程是轻量级进程)
                详细9_1_2(使用pthread_create和pthread_join管理线程)
        sub章10(实验：Blasteroids游戏)
            sub节10_1(游戏开发)
                详细10_1_1(使用Allegro库创建街机游戏)
                详细10_1_2(涉及键盘控制、图形绘制、事件处理)
~~~

### 基于AI的学习

#### 要求

- 至少找到自己理解不是太好2个概念，让AI对自己进行苏格拉底提问
- 参考下面提示词或者使用AI Agent

~~~ mark
提示词：“我在学习XXX知识点，请你以苏格拉底的方式对我进行提问，一次一个问题”
1. 核心是要求AI工具：“请你以苏格拉底的方式对我进行提问”
2. 然后AI工具就会给你提问，如果不知道问题的答案，可以反问AI：“你的理解（回答）是什么？”
3. 如果你觉得差不多了，可以先问问AI工具：“针对我XXX知识点，我理解了吗？”
4. AI工具会给出它的判断，如果你也觉得自己想清楚了，可以最后问AI工具：“我的回答结束了，请对我的回答进行评价总结”，让它帮你总结一下。
~~~

#### 学习内容

Human:

~~~
我在学习并发编程知识点，请你以苏格拉底的方式对我进行提问，一次一个问题
~~~

AI:

~~~
当然可以，让我们开始吧。
问题1：当我们谈论并发编程时，我们指的是什么？你能给我一个并发编程的简单定义吗？
~~~

Human:

~~~
类似于多人工作的商店，可以同时进行多项任务，每个线程可以分配不同的任务并同时执行。
~~~

AI:

~~~
问题2：那么，如果并发编程允许我们同时执行多个任务，这与串行编程相比有什么优势呢？你能描述一下并发编程在性能上可能带来的提升吗？
~~~

Human:

~~~
简单进程一次只能做一件事，类似于单人经营的商店，无法同时处理多项任务。
~~~

AI:

~~~
问题3：既然并发编程可以提高效率，那么它是否总是比串行编程更好呢？有没有什么情况下，我们可能不会选择使用并发编程？
~~~

Human:

~~~
你的回答是
~~~

AI:

~~~markdown
并发编程并不总是比串行编程更好，尽管它能提高效率，但也引入了复杂性。以下是一些我们可能不会选择使用并发编程的情况：
1. 简单性：如果程序很简单，或者任务的性质不适合并行处理，引入并发可能会使程序变得更加复杂，而没有带来相应的性能提升。
2. 资源限制：在资源受限的环境中，如内存或处理器能力有限的嵌入式系统，创建和管理多个线程可能会消耗过多资源，反而降低效率。
3. 安全性：并发编程需要处理数据共享和同步问题，这可能导致死锁、竞态条件等同步错误，这些问题可能很难检测和调试。
4. 开销：创建和销毁线程、以及线程间的同步和通信都会带来额外的开销，对于非常短的任务，这些开销可能会抵消并发带来的性能提升。
5. 可扩展性：并非所有的程序都能很好地扩展到多线程。有些程序可能在单线程中运行得更快，因为它们不需要处理并发执行带来的额外逻辑。
6. 维护性：并发代码通常更难理解和维护，这可能会增加长期维护的成本。
所以，是否使用并发编程需要根据具体的应用场景和需求来决定。在某些情况下，串行编程可能更加合适。
~~~

### 学习实践过程遇到的问题与解决方式（AI 驱动，优先使用AI工具解决问题）

Q:并发编程的重要性？

A:

并发编程是指在计算机程序中同时执行多个任务的能力。它的重要性体现在多个方面：

1. **提高性能**：并发编程可以提高程序的性能，尤其是在多核处理器上。通过并行处理，可以同时执行多个任务，减少总体的执行时间。

2. **资源利用率**：并发可以更有效地利用系统资源，如CPU和内存。在没有并发的情况下，一个核心可能在等待I/O操作时闲置，而并发编程可以让其他任务在等待时使用这个核心。

3. **响应性**：在用户界面(UI)编程中，如果一个操作需要很长时间，可能会导致界面冻结。并发编程可以将长时间运行的任务放在后台线程中执行，从而保持UI的响应性。

4. **可扩展性**：并发程序可以更容易地扩展以处理更多的负载。例如，在Web服务器中，可以为每个请求创建一个新线程或协程，从而允许服务器同时处理多个请求。

5. **更好的用户体验**：通过并发执行后台任务，可以避免阻塞用户操作，提供更流畅的用户体验。

6. **实时处理**：对于需要实时响应的系统，如在线交易系统或实时监控系统，并发编程是必不可少的，因为它允许系统同时处理多个事件。

7. **简化编程模型**：并发编程框架和库（如Java的并发API、Python的asyncio）提供了简化的编程模型，使得编写并发代码变得更加容易。

8. **容错性**：在分布式系统中，通过并发处理可以在一个节点失败时，将任务转移到其他节点，提高系统的容错性。

9. **异步I/O操作**：并发编程允许程序在等待I/O操作（如文件读写、网络通信）完成时继续执行其他任务，这样可以避免浪费宝贵的CPU时间。

10. **多任务处理**：在现代操作系统中，用户和应用程序常常需要同时处理多个任务，而并发编程提供了实现这一点的技术手段。

尽管并发编程带来了许多好处，但它也引入了复杂性，如死锁、竞态条件和资源争用等问题。因此，正确地设计和实现并发程序是非常重要的。

### 作业提交要求

-  提交Markdown文件,文档命名“学号姓名《密码系统设计》.md” . 
- 提交Markdown文件转为 PDF,文档命名“学号姓名《密码系统设计》第 X 周.pdf” 
-  提交代码托管链接（可选）：学号姓名 gitee(github) 链接
- 内容质量高有加分

参考链接：

- AI工具

  - [ChatGPT](https://chatgpt.com/)
  - [Kimi.ai - 帮你看更大的世界 (moonshot.cn)](https://kimi.moonshot.cn/)
  - [Microsoft Copilot: 你的 AI 助手](https://copilot.microsoft.com/)
- 图书
  - 《Window C/C++加密解密实战》
