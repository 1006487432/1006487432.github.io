---
title: 实验2-2
subtitle:
date: 2024-10-27T17:11:56+08:00
draft: false
author:
  name: 瞻鹤
  link:
  email: he-zhan@outlook.com
  avatar: /images/avatar.jpg
description:
keywords:
license:
comment: false
weight: 0
tags:
  - 
categories:
  - homework
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRss: false
hiddenFromRelated: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
password:
message:
repost:
  enable: true
  url:

# See details front matter: https://fixit.lruihao.cn/documentation/content-management/introduction/#front-matter
---

<!--more-->	

# 《密码系统设计》实验

## 实验项目
| 实验序号 | 实验名称     | 实验学时数 | 实验目的                          | 实验内容 | 实验类型 | 学生学习预期成果                                             |
| -------- | ------------ | ---------- | --------------------------------- | :------- | -------- | ------------------------------------------------------------ |
| 实验二   | 密码算法实现 | 6          | 基于国产化平台使⽤C语⾔编程实现SM2、SM3、SM4等算法； |          | 验证性   | 1.基于Arm等平台和国产化操作系统使⽤C语⾔编程实现SM2、SM3、SM4算法；2.对⽐分析算法实现的正确性和效率|

### 在 Ubuntu或openEuler中（推荐 openEuler）中调试运⾏教材提供的源代码，⾄少运⾏SM2，SM3，SM4代码，使⽤GmSSL命令验证你代码的正确性，使⽤Markdown记录详细记录实践过程，每完成⼀项功能或者⼀个函数git commit ⼀次。（15分）

#### SM2

云班课下载的代码在虚拟机上无法编译成功，经过比对发现该代码与上一次实验2-1的代码基本一致，只有函数名不同。所以直接采用上一次代码进行测试。课本上的代码涉及加密解密、签名验签的自测，结果如下：

~~~ shell
$ ./sm2_test
Messagse:656e6372797074696f6e207374616e64617264
Cipher:04ebfc718e8d1798620432268e77feb6415e2e
M:656e6372797074696f6e207374616e64617264
SM2_enc_selftest pass
SM2_enc_selftest:0
message:6d65737361676520646967657374
Signature:f5a03b0648d2c4630eeac513e1bb81a15944da3827d5b74143ac7eaceee720b3b1b6aa29df212fd8763182bc0d421ca1bb9038fd1f7f42d4840b69c485bbc1aa
SM2_sign_selftest pass
SM2_sign_selftest:0
~~~

##### 验证

~~~ shell
$ gmssl sm2encrypt -help
usage: gmssl sm2encrypt (-pubkey pem | -cert pem) [-in file] [-out file]

Options

    -pubkey pem         Recepient's public key file in PEM format
    -cert pem           Recipient's certificate in PEM format
    -in file | stdin    To be encrypted data, at most 255 bytes
    -out file | stdout  Output ciphertext in binary DER-encoding

Examples

    $ gmssl sm2keygen -pass P@ssw0rd -out sm2.pem -pubout sm2pub.pem
    $ echo 'Secret message' | gmssl sm2encrypt -pubkey sm2pub.pem -out sm2.der
    $ gmssl sm2decrypt -key sm2.pem -pass P@ssw0rd -in sm2.der
$ gmssl sm2verify -help
usage: gmssl sm2verify (-pubkey pem | -cert pem) [-id str] [-in file] -sig file

Options

    -pubkey pem         Signer's public key file in PEM format
    -cert pem           Signer's certificate in PEM format
    -id str             Signer's identity string, '1234567812345678' by default
    -in file | stdin    Signed file or data
    -sig file           Signature in binary DER encoding

Examples

    $ gmssl sm2keygen -pass P@ssw0rd -out sm2.pem -pubout sm2pub.pem
    $ echo -n 'message to be signed' | gmssl sm2sign -key sm2.pem -pass P@ssw0rd -out sm2.sig
    $ echo -n 'message to be signed' | gmssl sm2verify -pubkey sm2pub.pem -sig sm2.sig
~~~

~~~ shell
$ echo -ne "\x39\x45\x20\x8F\x7B\x21\x44\xB1\x3F\x36\xE3\x8A\xC6\xD3\x9F\x95\x88\x93\x93\x69\x28\x60\xB5\x1A\x42\xFB\x81\xEF\x4D\xF7\xC5\xB8" > pri.hex
~~~



#### SM3

一段式和三段式实现SM3

~~~ shell
$ pwd
/home/zhanhe/rodec/bestidiocs2024/ch03/sm3
$ gcc -o sm31 sm31.c
$ gcc -o sm33 sm33.c
$ ./sm31
消息：abc
Hash结果：
len=32
66 c7 f0 f4 62 ee ed d9 d1 f2 d4 6b dc 10 e4 e2
41 67 c4 87 5c f2 f7 a2 29 7d a0 2b 8f 4b a8 e0
$ ./sm33
消息：abcd
Hash结果：
82ec580fe6d36ae4f81cae3c73f4a5b3b5a09c943172dc9053c69fd8e18dca1e
~~~
Openssl实现SM3
~~~ shell
$ pwd
/home/zhanhe/rodec/bestidiocs2024/ch03/sm3/sm3openssl
$ ./test
Raw data (sample1): abc
Hash length: 32 bytes.
Hash value:
66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0

Raw data (sample2):
0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64  0x61  0x62  0x63  0x64
Hash length: 32 bytes.
Hash value:
debe9ff92275b8a138604889c18e5a4d6fdb70e5387e5765293dcba39c0c5732
~~~

HMAC-SM3

~~~ shell
$ pwd
/home/zhanhe/rodec/bestidiocs2024/ch03/sm3/hmac-sm3
$ ls
Makefile  sm3.c  sm3.h  test.c
$ make
gcc   -Wall -O2   -o test   test.c sm3.c
$ ./test
Message: abc
HMAC:   ec76c401 b2ddceb3 916bdffa 0469b85f 90536ffc f4ecac77 539f3d8b 8bbe046c
~~~



##### 验证

~~~ shell
$ echo -n "abcd" | gmssl sm3
82ec580fe6d36ae4f81cae3c73f4a5b3b5a09c943172dc9053c69fd8e18dca1e
$ echo -n "abc" | gmssl sm3
66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0
$ echo -ne "\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64\x61\x62\x63\x64" | gmssl sm3
debe9ff92275b8a138604889c18e5a4d6fdb70e5387e5765293dcba39c0c5732
~~~

与代码结果一致

~~~ shell
key为"123456"
hex为313233343536
hmac需要对密钥进行预处理，得到16字节的密钥，即长度为32的hex字符串
填充得到31323334353600000000000000000000
$ echo -n "abc" | gmssl sm3hmac -key 31323334353600000000000000000000
ec76c401b2ddceb3916bdffa0469b85f90536ffcf4ecac77539f3d8b8bbe046c
~~~

hmac计算结果一致

#### SM4

16字节的SM4

~~~ shell
$ pwd
/home/zhanhe/rodec/bestidiocs2024/ch03/sm4/sm416
$ ./testsm416
明文 (十六进制): 01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10
密文 (十六进制): 68 1E DF 34 D2 06 96 5E 86 B3 E9 4F 53 6E 42 46
解密后的明文 (十六进制): 01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10
sm4(16 Bytes ok!)

~~~

4个模式的SM4

~~~ shell
$ pwd
/home/zhanhe/rodec/bestidiocs2024/ch03/sm4/sm4mode
$ ./test
ecb enc(len=16) memcmp ok
ecb dec(len=16) memcmp ok
ecb enc/dec(len=32) memcmp ok
ecb enc/dec(len=64) memcmp ok
ecb enc/dec(len=128) memcmp ok
ecb enc/dec(len=256) memcmp ok
ecb enc/dec(len=512) memcmp ok
ecb enc/dec(len=1024) memcmp ok
ecb enc/dec(len=2048) memcmp ok
ecb enc/dec(len=4096) memcmp ok
cbc enc(len=32) memcmp ok
cbc dec(len=32) memcmp ok
cbc enc/dec(len=32) memcmp ok
cbc enc/dec(len=64) memcmp ok
cbc enc/dec(len=128) memcmp ok
cbc enc/dec(len=256) memcmp ok
cbc enc/dec(len=512) memcmp ok
cbc enc/dec(len=1024) memcmp ok
cbc enc/dec(len=2048) memcmp ok
cbc enc/dec(len=4096) memcmp ok
cfb enc/dec(len=16) memcmp ok
cfb enc/dec(len=32) memcmp ok
cfb enc/dec(len=64) memcmp ok
cfb enc/dec(len=128) memcmp ok
cfb enc/dec(len=256) memcmp ok
cfb enc/dec(len=512) memcmp ok
cfb enc/dec(len=1024) memcmp ok
cfb enc/dec(len=2048) memcmp ok
cfb enc/dec(len=4096) memcmp ok
ofb enc/dec(len=16) memcmp ok
ofb enc/dec(len=32) memcmp ok
ofb enc/dec(len=64) memcmp ok
ofb enc/dec(len=128) memcmp ok
ofb enc/dec(len=256) memcmp ok
ofb enc/dec(len=512) memcmp ok
ofb enc/dec(len=1024) memcmp ok
ofb enc/dec(len=2048) memcmp ok
ofb enc/dec(len=4096) memcmp ok
~~~

##### 验证

16字节的SM4

~~~ c
//查看代码得到密钥和明文
unsigned char key[16] = { 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10 };
unsigned char plain[16] = { 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10 };
 unsigned char iv[16] = {
        0xeb, 0xee, 0xc5, 0x68,
        0x58, 0xe6, 0x04, 0xd8,
        0x32, 0x7b, 0x9b, 0x3c,
        0x10, 0xc9, 0x0c, 0xa7
    }; 
~~~

~~~ shell
$ echo -ne "\x01\x23\x45\x67\x89\xab\xcd\xef\xfe\xdc\xba\x98\x76\x54\x32\x10" > key.bin
$ echo -ne "\x01\x23\x45\x67\x89\xab\xcd\xef\xfe\xdc\xba\x98\x76\x54\x32\x10" > plain.txt
$ echo -ne "\xeb\xee\xc5\x68\x58\xe6\x04\xd8\x32\x7b\x9b\x3c\x10\xc9\x0c\xa
7" > iv.bin
$ gmssl sm4_ecb -encrypt -key $(xxd -p -c 32 key.bin) -in plain.txt -out enc.bin

$ od -tc -tx1 enc.bin
0000000   h 036 337   4 322 006 226   ^ 206 263 351   O   S   n   B   F
         68  1e  df  34  d2  06  96  5e  86  b3  e9  4f  53  6e  42  46
0000020
$ gmssl sm4_cbc -encrypt -key $(xxd -p -c 32 key.bin) -iv $(xxd -p -c 32 iv.bin) -in plain.txt -out cbc.bin
$ od -tx1 cbc.bin
0000000 3f 1e 73 c3 df d5 a1 32 88 2f e6 9d 99 6c de 93
0000020 82 3f 40 e0 01 d1 54 84 c1 32 ec 05 53 b4 e5 95
0000040

~~~

ecb(16字节）、cbc模式结果一致

cfb、ofb代码中并没有给出密文结果

### 在密标委⽹站http://www.gmbz.org.cn/main/bzlb.html查找SM2，SM3，SM4相关标准，分析代码实现与标准的对应关系。（10分）



### 使⽤GmSSL,UKey 交叉验证实现的正确性（5 分）



### 提交要求：

- 提交实践过程Markdown和转化的PDF文件
- 代码，文档托管到gitee或github等，推荐 gitclone 
- 记录实验过程中遇到的问题，解决过程，反思等内容，完成实验报告相关内容

### 参考链接

[个人仓库]([1006487432.github.io/content/src at master · 1006487432/1006487432.github.io](https://github.com/1006487432/1006487432.github.io/tree/master/content/src));

[lookingforfyf/SMX_Test: 基于MIRACL（C语言密码库）的国密SM2签名验签以及加解密、SM3的加解密、SM4的加解密算法](https://github.com/lookingforfyf/SMX_Test/tree/master)
