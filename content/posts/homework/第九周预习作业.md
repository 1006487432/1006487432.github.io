---
title: 第九周预习报告
subtitle:
date: 2024-11-9T12:11:56+08:00
draft: false
author:
  name: 瞻鹤
  link:
  email: he-zhan@outlook.com
  avatar: /images/avatar.jpg
description:
keywords:
license:
comment: false
weight: 0
tags:
  - 
categories:
  - homework
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRss: false
hiddenFromRelated: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
password:
message:
repost:
  enable: true
  url:

# See details front matter: https://fixit.lruihao.cn/documentation/content-management/introduction/#front-matter
---

<!--more-->	

[toc]

# 第九周预习报告

## 学习内容 

- 学习内容

- Head First C 嗨翻 C 语⾔ 第9章

- 课程 mindmap

- 报告内容参考第⼀周


### AI对学习内容的总结

#### 要求

- 让AI（kimi，元宝等）阅读学习内容并进⾏总结，教材内容可以使⽤微信读书或者云班课电⼦教材

#### 总结

##### Head First C 嗨翻 C 语⾔ 第9章

这份PDF文件是关于C语言中进程和系统调用的章节，涵盖了如何使用系统服务来创建和控制进程，以及如何通过系统调用来执行外部程序。以下是该章节的主要内容总结：

1. **系统调用（System Calls）**：
   - C程序依赖操作系统来执行几乎所有事情，系统调用是C标准库中大多数函数的基础。
   - 系统调用是存在于操作系统内核中的函数，例如`printf()`函数最终会通过系统调用来发送文本到屏幕。

2. **system()函数**：
   - `system()`函数接受一个字符串参数，并将其作为命令行指令执行。
   - 它允许从C代码中运行其他程序，特别适合快速原型开发或调用外部程序而不是编写大量C代码。

3. **进程和系统调用**：
   - 介绍了如何使用`system()`函数来创建一个程序，该程序将带时间戳的文本追加到日志文件末尾。
   - 讨论了`system()`函数的安全隐患，如注入命令行代码可能导致程序执行任意代码。

4. **exec()函数**：
   - `exec()`函数提供了比`system()`更多的控制，它们替换当前进程来运行另一个程序。
   - `exec()`函数族包括`execl()`、`execlp()`、`execle()`、`execv()`、`execvp()`和`execve()`，它们在参数传递和环境变量设置上有所不同。

5. **环境变量**：
   - 讨论了如何使用`getenv()`函数读取环境变量，以及如何通过`execle()`函数传递环境变量。

6. **错误处理**：
   - 介绍了`errno`全局变量和`strerror()`函数，用于处理和输出系统调用失败的错误信息。

7. **网络配置**：
   - 展示了如何在不同操作系统上运行不同的网络配置命令，例如Linux和Mac上的`/sbin/ifconfig`和Windows上的`ipconfig`。

8. **并发执行**：
   - 讨论了如何使用`fork()`系统调用来创建进程副本，并结合`exec()`在每个副本中执行不同的程序。

9. **RSS Gossip和Newshound**：
   - 介绍了如何使用外部Python脚本`rssgossip.py`来搜索RSS源，并创建了一个名为`newshound`的程序，该程序可以并发地搜索多个RSS源。

10. **fork()和exec()的结合使用**：
    - 通过`fork()`创建子进程，并在子进程中使用`exec()`执行外部程序，而父进程继续执行。

这份PDF文件提供了关于如何在C语言程序中使用系统调用来创建和管理进程的深入指导，包括如何执行外部程序、传递参数和环境变量，以及如何处理潜在的错误。

### 对AI总结的反思

#### 要求

- AI总结的问题

#### 反思

- AI总结比较精简，适合作为提纲、导图等方式指导学习，更有助于分配自己的学习时间和精力

### 学习思维导图

#### 要求

- Mermaid 代码与截图(参考Mermaid MindMap语法)或者提交思维导图链接（如果使用线上编辑器，推荐processon,xmind,...）

#### 思维导图

代码:

~~~ markdown
mindmap
    root(C语言进程和系统调用)
        sub章1(系统调用基础)
            sub节1_1(系统调用定义)
                详细1_1_1(系统调用与操作系统内核的关系)
                详细1_1_2(C标准库与系统调用的依赖)
            sub节1_2(system函数)
                详细1_2_1(system函数的用途)
                详细1_2_2(system函数的执行示例)
        sub章2(进程控制)
            sub节2_1(进程与程序)
                详细2_1_1(进程定义)
                详细2_1_2(程序与进程的区别)
            sub节2_2(创建进程)
                详细2_2_1(fork函数的使用)
                详细2_2_2(fork函数的返回值)
        sub章3(exec函数族)
            sub节3_1(exec函数概述)
                详细3_1_1(exec函数的作用)
                详细3_1_2(exec函数族的成员)
            sub节3_2(exec函数的使用)
                详细3_2_1(execl与execlp)
                详细3_2_2(execv与execvp)
        sub章4(环境变量)
            sub节4_1(getenv函数)
                详细4_1_1(getenv函数的用途)
                详细4_1_2(getenv函数的使用示例)
            sub节4_2(设置环境变量)
                详细4_2_1(execle函数的使用)
                详细4_2_2(环境变量数组的定义)
        sub章5(错误处理)
            sub节5_1(errno变量)
                详细5_1_1(errno变量的定义)
                详细5_1_2(errno变量的使用)
            sub节5_2(strerror函数)
                详细5_2_1(strerror函数的用途)
                详细5_2_2(strerror函数的使用示例)
        sub章6(网络配置命令)
            sub节6_1(不同系统的命令)
                详细6_1_1(Linux/Mac的ifconfig)
                详细6_1_2(Windows的ipconfig)
            sub节6_2(跨平台执行网络命令)
                详细6_2_1(exec函数在不同系统的应用)
                详细6_2_2(错误处理与跨平台兼容性)
        sub章7(并发执行与性能)
            sub节7_1(并发执行的概念)
                详细7_1_1(并发与并行的区别)
                详细7_1_2(并发执行的优势)
            sub节7_2(实现并发执行)
                详细7_2_1(fork与exec的结合)
                详细7_2_2(并发执行的代码示例)
~~~



~~~ mermaid
mindmap
    root(C语言进程和系统调用)
        sub章1(系统调用基础)
            sub节1_1(系统调用定义)
                详细1_1_1(系统调用与操作系统内核的关系)
                详细1_1_2(C标准库与系统调用的依赖)
            sub节1_2(system函数)
                详细1_2_1(system函数的用途)
                详细1_2_2(system函数的执行示例)
        sub章2(进程控制)
            sub节2_1(进程与程序)
                详细2_1_1(进程定义)
                详细2_1_2(程序与进程的区别)
            sub节2_2(创建进程)
                详细2_2_1(fork函数的使用)
                详细2_2_2(fork函数的返回值)
        sub章3(exec函数族)
            sub节3_1(exec函数概述)
                详细3_1_1(exec函数的作用)
                详细3_1_2(exec函数族的成员)
            sub节3_2(exec函数的使用)
                详细3_2_1(execl与execlp)
                详细3_2_2(execv与execvp)
        sub章4(环境变量)
            sub节4_1(getenv函数)
                详细4_1_1(getenv函数的用途)
                详细4_1_2(getenv函数的使用示例)
            sub节4_2(设置环境变量)
                详细4_2_1(execle函数的使用)
                详细4_2_2(环境变量数组的定义)
        sub章5(错误处理)
            sub节5_1(errno变量)
                详细5_1_1(errno变量的定义)
                详细5_1_2(errno变量的使用)
            sub节5_2(strerror函数)
                详细5_2_1(strerror函数的用途)
                详细5_2_2(strerror函数的使用示例)
        sub章6(网络配置命令)
            sub节6_1(不同系统的命令)
                详细6_1_1(Linux/Mac的ifconfig)
                详细6_1_2(Windows的ipconfig)
            sub节6_2(跨平台执行网络命令)
                详细6_2_1(exec函数在不同系统的应用)
                详细6_2_2(错误处理与跨平台兼容性)
        sub章7(并发执行与性能)
            sub节7_1(并发执行的概念)
                详细7_1_1(并发与并行的区别)
                详细7_1_2(并发执行的优势)
            sub节7_2(实现并发执行)
                详细7_2_1(fork与exec的结合)
                详细7_2_2(并发执行的代码示例)
~~~



### 基于AI的学习	

#### 要求

- 至少找到自己理解不是太好2个概念，让AI对自己进行苏格拉底提问
- 参考下面提示词或者使用AI Agent

~~~ mark
提示词：“我在学习XXX知识点，请你以苏格拉底的方式对我进行提问，一次一个问题”
1. 核心是要求AI工具：“请你以苏格拉底的方式对我进行提问”
2. 然后AI工具就会给你提问，如果不知道问题的答案，可以反问AI：“你的理解（回答）是什么？”
3. 如果你觉得差不多了，可以先问问AI工具：“针对我XXX知识点，我理解了吗？”
4. AI工具会给出它的判断，如果你也觉得自己想清楚了，可以最后问AI工具：“我的回答结束了，请对我的回答进行评价总结”，让它帮你总结一下。
~~~

#### 学习内容

Human:

~~~
我在学习系统调用知识点，请你以苏格拉底的方式对我进行提问，一次一个问题
~~~

AI:

~~~
当然可以，让我们开始吧。告诉我，你对系统调用的理解是什么？
~~~

Human:

~~~
系统调用是存在于操作系统内核中的函数，例如`printf()`函数最终会通过系统调用来发送文本到屏幕。
~~~

AI:

~~~
非常好，你已经理解了系统调用的基本定义。那么，你能进一步解释为什么程序需要通过系统调用来与硬件通信吗？
~~~

Human:

~~~
因为封装起来了
~~~

AI:

~~~
没错，封装是一个关键概念。那么，你能详细说明一下这种封装是如何保护程序和操作系统的吗？
~~~

Human:

~~~
没错，封装是一个关键概念。那么，你能详细说明一下这种封装是如何保护程序和操作系统的吗？
~~~

AI:

~~~markdown
是的，你说得对。系统调用通过提供一组有限且受控的接口来保护硬件和操作系统。这些接口确保程序不能随意访问或修改硬件，从而防止潜在的损害。接下来，你能描述一下系统调用和库函数之间有什么区别吗？
~~~

Human:

~~~
通过库函数实现系统调用
~~~

AI:

~~~
接近了，但可以更具体一些。库函数通常是用户空间中的代码，它们提供了一个更高级、更易于使用的接口给程序员。而系统调用是库函数背后实际与操作系统内核交互的机制。库函数，比如C标准库中的printf()，会使用系统调用来执行实际的硬件操作，比如将数据输出到屏幕。那么，你能想到为什么系统调用对于操作系统的安全性至关重要吗？
~~~

Human:

~~~
系统调用如何保证系统安全？
~~~

AI：

~~~markdown
很好，我们正在深入这个话题。系统调用保证系统安全的方式主要体现在以下几个方面：
1. 权限控制：系统调用提供了一种机制，使得用户空间的程序必须通过内核的检查才能执行特定的操作，比如文件访问或内存管理。内核会检查程序的权限，确保它们不能执行超出权限的操作。
2. 隔离：系统调用确保用户空间的程序不能直接访问内核空间的资源，这种隔离是防止恶意软件和其他安全威胁的关键。
3. 验证：在执行系统调用之前，内核会验证调用的合法性，包括检查参数和调用的上下文，确保它们符合预期的使用方式。
4. 资源管理：系统调用帮助内核管理有限的资源，如CPU时间和内存，防止任何单一进程或用户占用过多资源，从而影响系统的稳定性。
5. 审计和监控：系统调用可以被监控和记录，这对于检测异常行为和安全入侵非常重要。
通过这些机制，系统调用成为了保护操作系统免受未授权访问和潜在攻击的第一道防线。现在，你能否想到系统调用可能存在的一些局限性或挑战？
~~~

Human：

~~~
只能实现预先封装好的功能
~~~

AI：

~~~markdown
确实，你指出了一个重要的点。系统调用通常只能提供一组有限的功能，这些功能是由操作系统预先定义和封装好的。这意味着：
1. 灵活性限制：程序员不能直接访问硬件或执行操作系统内核中未提供的任何操作，这限制了程序的灵活性。
2. 创新障碍：对于需要新颖或特定硬件操作的应用，系统调用可能不足以满足需求，这可能阻碍技术创新。
3. 依赖性：应用程序的功能在很大程度上依赖于操作系统提供的系统调用，这可能导致应用程序在不同操作系统间的移植性差。
由于这些局限性，开发者有时会寻找其他方法来实现他们的需求，比如使用驱动程序或特殊的库来访问特定的硬件功能。那么，你能想到为什么尽管有这些局限性，系统调用仍然是操作系统中不可或缺的一部分吗？
~~~

Human：

~~~
用户需要和操作系统交换来满足用户的需求
~~~

AI：

~~~markdown
正是如此，用户程序与操作系统之间的交互是不可避免的，因为用户需要操作系统提供的资源和服务来完成各种任务。系统调用提供了一种安全和有效的方式来实现这种交互。它们允许用户程序：
1. 请求服务：用户程序可以通过系统调用来请求操作系统提供的服务，如文件操作、网络通信、进程管理等。
2. 获取资源：操作系统控制着对硬件资源的访问，系统调用使得用户程序能够请求这些资源，如内存分配、I/O操作等。
3. 执行特权操作：某些操作需要特权级别才能执行，如直接访问硬件设备，系统调用允许用户程序在操作系统的监督下安全地执行这些操作。
4. 维护隔离：系统调用确保用户程序不能直接干预其他程序或操作系统的内核，这有助于保护系统的稳定性和安全性。
5. 实现抽象：操作系统通过系统调用为用户程序提供了一个抽象层，隐藏了硬件的复杂性，使得程序开发更加高效和可移植。
因此，尽管系统调用的功能有限，但它们是用户程序与操作系统交互的基础，是实现用户需求的关键桥梁。
~~~

### 学习实践过程遇到的问题与解决方式（AI 驱动，优先使用AI工具解决问题）

Q:系统调用与普通用户态函数比较，有何异同点

A:

系统调用（System Call）与普通用户态函数（User-Level Function）是操作系统中两个不同层面的概念，它们在目的、权限、执行环境等方面有着明显的异同点。以下是它们的一些主要区别和相似之处：

异同点：

1. **执行权限和环境：**
   - **系统调用：** 系统调用是在用户态程序需要操作系统提供的服务时，由用户态切换到内核态执行的一系列操作。它们通常需要较高的权限，因为它们可以访问和控制硬件资源、管理系统资源等。
   - **普通用户态函数：** 这些函数是在用户态执行的，权限较低，不能直接访问硬件资源或执行某些系统级别的操作。
2. **目的和功能：**
   - **系统调用：** 系统调用的主要目的是提供一个接口，让用户程序能够请求操作系统提供的服务，如文件操作、进程控制、网络通信等。
   - **普通用户态函数：** 这些函数通常是为了实现应用程序的特定功能，如数学计算、字符串处理等。
3. **错误处理：**
   - **系统调用：** 如果系统调用失败，通常会返回一个错误码，这是由操作系统定义的，用于指示错误类型。
   - **普通用户态函数：** 错误处理通常由函数的返回值或者异常机制来实现。
4. **性能开销：**
   - **系统调用：** 由于涉及到用户态到内核态的切换，系统调用通常有较高的性能开销。
   - **普通用户态函数：** 这些函数在用户态执行，没有状态切换的开销，因此通常执行速度更快。
5. **安全性：**
   - **系统调用：** 由于涉及到操作系统的核心功能，系统调用需要严格的安全检查，以防止恶意软件破坏系统或窃取数据。
   - **普通用户态函数：** 安全性通常由应用程序自己控制，操作系统不直接介入。
6. **可移植性：**
   - **系统调用：** 系统调用的接口和行为是由操作系统定义的，不同操作系统的系统调用可能不同，因此可移植性较差。
   - **普通用户态函数：** 这些函数通常与操作系统无关，更容易在不同的操作系统之间移植。

相似点：

1. **都是函数：** 无论是系统调用还是普通用户态函数，它们在编程语言中都表现为函数，可以被程序调用来执行特定的任务。
2. **都需要编程实现：** 无论是系统调用还是普通用户态函数，都需要程序员编写代码来实现其功能。
3. **都可以被优化：** 系统调用和普通用户态函数都可以通过优化来提高性能，比如减少系统调用的次数或者优化算法。

总的来说，系统调用是操作系统提供给用户程序的接口，用于执行需要操作系统权限的操作，而普通用户态函数则是应用程序内部的函数，用于实现应用程序的逻辑。两者在权限、性能和安全性等方面有着明显的区别。

### 作业提交要求

-  提交Markdown文件,文档命名“学号姓名《密码系统设计》.md” . 
- 提交Markdown文件转为 PDF,文档命名“学号姓名《密码系统设计》第 X 周.pdf” 
-  提交代码托管链接（可选）：学号姓名 gitee(github) 链接
- 内容质量高有加分

参考链接：

- AI工具

  - [ChatGPT](https://chatgpt.com/)
  - [Kimi.ai - 帮你看更大的世界 (moonshot.cn)](https://kimi.moonshot.cn/)
  - [Microsoft Copilot: 你的 AI 助手](https://copilot.microsoft.com/)
- 图书
  - 《Window C/C++加密解密实战》
