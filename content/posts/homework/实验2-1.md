---
title: 实验2-1
subtitle:
date: 2024-10-27T17:11:56+08:00
draft: false
author:
  name: 瞻鹤
  link:
  email: he-zhan@outlook.com
  avatar: /images/avatar.jpg
description:
keywords:
license:
comment: false
weight: 0
tags:
  - 
categories:
  - homework
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRss: false
hiddenFromRelated: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
password:
message:
repost:
  enable: true
  url:

# See details front matter: https://fixit.lruihao.cn/documentation/content-management/introduction/#front-matter
---

<!--more-->	

# 《密码系统设计》实验

## 实验项目
| 实验序号 | 实验名称     | 实验学时数 | 实验目的                          | 实验内容 | 实验类型 | 学生学习预期成果                                             |
| -------- | ------------ | ---------- | --------------------------------- | :------- | -------- | ------------------------------------------------------------ |
| 实验二   | 密码算法实现 | 6          | 基于国产化平台使⽤C语⾔编程实现SM2、SM3、SM4等算法； |          | 验证性   | 1.基于Arm等平台和国产化操作系统使⽤C语⾔编程实现SM2、SM3、SM4算法；2.对⽐分析算法实现的正确性和效率|

### 在 Ubuntu或openEuler中（推荐 openEuler）中调试运⾏商⽤密码检测中⼼https://www.scctc.org.cn/xzzx/sfydm/ydmxz/提供的源代码，⾄少运⾏SM2，SM3，SM4代码。使⽤GmSSL命令验证你代码的正确性。使⽤Markdown记录详细记录实践过程，每完成⼀项功能或者⼀个函数git commit ⼀次。（14分）

#### SM3

##### SM3.h

~~~ c
//
// Created by He-Zh on 2024/10/27.
//

#ifndef EXP2_SM3_H
#define EXP2_SM3_H
#include <string.h>
#define SM3_len 256
#define SM3_T1 0x79CC4519
#define SM3_T2 0x7A879D8A
#define SM3_IVA 0x7380166f
#define SM3_IVB 0x4914b2b9
#define SM3_IVC 0x172442d7
#define SM3_IVD 0xda8a0600
#define SM3_IVE 0xa96f30bc
#define SM3_IVF 0x163138aa
#define SM3_IVG 0xe38dee4d
#define SM3_IVH 0xb0fb0e4e
/* Various logical functions */
#define SM3_p1(x) (x^SM3_rotl32(x,15)^SM3_rotl32(x,23))
#define SM3_p0(x) (x^SM3_rotl32(x,9)^SM3_rotl32(x,17))
#define SM3_ff0(a,b,c) (a^b^c)
#define SM3_ff1(a,b,c) ((a&b)|(a&c)|(b&c))
#define SM3_gg0(e,f,g) (e^f^g)
#define SM3_gg1(e,f,g) ((e&f)|((~e)&g))
#define SM3_rotl32(x,n) ((((unsigned int) x) << n) | (((unsigned int) x) >> (32 - n)))
#define SM3_rotr32(x,n) ((((unsigned int) x) >> n) | (((unsigned int) x) << (32 - n)))
typedef struct {
    unsigned int state[8];
    unsigned int length;
    unsigned int curlen;
    unsigned char buf[64];
} SM3_STATE;
void BiToWj(unsigned int Bi[], unsigned int Wj[]);
void WjToWj1(unsigned int Wj[], unsigned int Wj1[]);
void CF(unsigned int Wj[], unsigned int Wj1[], unsigned int V[]);
void BigEndian(unsigned char src[], unsigned int bytelen, unsigned char des[]);
void SM3_init(SM3_STATE *md);
void SM3_compress(SM3_STATE * md);
void SM3_process(SM3_STATE * md, unsigned char buf[], int len);
void SM3_done(SM3_STATE *md, unsigned char *hash);
void SM3_256(unsigned char buf[], int len, unsigned char hash[]);
int SM3_SelfTest();
#endif //EXP2_SM3_H
~~~

##### SM3.c

~~~ c
//
// Created by He-Zh on 2024/10/27.
//

#include "sm3.h"
#include <stdio.h>
void BiToW(unsigned int Bi[], unsigned int W[])
{
    int i;
    unsigned int tmp;
    for(i=0;i<=15;i++)
    {
        W[i]=Bi[i];
    }
    for(i=16;i<=67;i++)
    {
        tmp=W[i-16]
            ^ W[i-9]
            ^ SM3_rotl32(W[i-3],15);
        W[i]=SM3_p1(tmp)
             ^ (SM3_rotl32(W[i-13],7))
             ^ W[i-6];
    }
}
void WToW1(unsigned int W[], unsigned int W1[])
{
    int i;
    for(i=0;i<=63;i++)
    {
        W1[i]=W[i]^W[i+4];
    }
}
void CF(unsigned int W[], unsigned int W1[], unsigned int V[])
{
    unsigned int SS1;
    unsigned int SS2;
    unsigned int TT1;
    unsigned int TT2;
    unsigned int A,B,C,D,E,F,G,H;
    unsigned int T=SM3_T1;
    unsigned int FF;
    unsigned int GG;
    int j;
//reg init,set ABCDEFGH=V0
    A=V[0];
    B=V[1];
    C=V[2];
    D=V[3];
    E=V[4];
    F=V[5];
    G=V[6];
    H=V[7];
    for(j=0;j<=63;j++)
    {
        //SS1
        if(j==0)
        {
            T=SM3_T1;
        }
        else if(j==16)
        {
            T=SM3_rotl32(SM3_T2,16);
        }
        else
        {
            T=SM3_rotl32(T,1);
        }
        SS1=SM3_rotl32((SM3_rotl32(A,12)+E+T),7);
        //SS2
        SS2=SS1^SM3_rotl32(A,12);
        //TT1
        if(j<=15)
        {
            FF=SM3_ff0(A,B,C);
        }
        else
        {
            FF=SM3_ff1(A,B,C);
        }
        TT1=FF+D+SS2+*W1;
        W1++;
        //TT2
        if(j<=15)
        {
            GG=SM3_gg0(E,F,G);
        }
        else
        {
            GG=SM3_gg1(E,F,G);
        }
        TT2=GG+H+SS1+*W;
        W++;
        //D
        D=C;
        //C
        C=SM3_rotl32(B,9);
        //B
        B=A;
        //A
        A=TT1;
        //H
        H=G;
        //G
        G=SM3_rotl32(F,19);
        //F
        F=E;
        //E
        E=SM3_p0(TT2);
    }
    //update V
    V[0]=A^V[0];
    V[1]=B^V[1];
    V[2]=C^V[2];
    V[3]=D^V[3];
    V[4]=E^V[4];
    V[5]=F^V[5];
    V[6]=G^V[6];
    V[7]=H^V[7];
}
void BigEndian(unsigned char src[], unsigned int bytelen, unsigned char des[])
{
    unsigned char tmp = 0;
    unsigned int i = 0;
    for(i=0; i<bytelen/4; i++)
    {
        tmp = des[4*i];
        des[4*i] = src[4*i+3];
        src[4*i+3] = tmp;
        tmp = des[4*i+1];
        des[4*i+1] = src[4*i+2];
        des[4*i+2] = tmp;
    }
}
void SM3_init(SM3_STATE *md)
{
    md->curlen = md->length = 0;
    md->state[0] = SM3_IVA;
    md->state[1] = SM3_IVB;
    md->state[2] = SM3_IVC;
    md->state[3] = SM3_IVD;
    md->state[4] = SM3_IVE;
    md->state[5] = SM3_IVF;
    md->state[6] = SM3_IVG;
    md->state[7] = SM3_IVH;
}
void SM3_compress(SM3_STATE * md)
{
    unsigned int W[68];
    unsigned int W1[64];
    //if CPU uses little-endian, BigEndian function is a necessary call
    BigEndian(md->buf, 64, md->buf);
    BiToW((unsigned int *)md->buf,W);
    WToW1(W,W1);
    CF(W, W1, md->state);
}
void SM3_process(SM3_STATE * md, unsigned char *buf, int len)
{
    while (len--)
    {
        /* copy byte */
        md->buf[md->curlen] = *buf++;
        md->curlen++;
        /* is 64 bytes full? */
        if (md->curlen == 64)
        {
            SM3_compress(md);
            md->length += 512;
            md->curlen = 0;
        }
    }
}
void SM3_done(SM3_STATE *md, unsigned char hash[])
{
    int i;
    unsigned char tmp = 0;
    /* increase the bit length of the message */
    md->length += md->curlen <<3;
    /* append the '1' bit */
    md->buf[md->curlen] = 0x80;
    md->curlen++;
    /* if the length is currently above 56 bytes, appends zeros till
    it reaches 64 bytes, compress the current block, creat a new
    block by appending zeros and length,and then compress it
    */
    if (md->curlen >56)
    {
        for (; md->curlen < 64;)
        {
            md->buf[md->curlen] = 0;
            md->curlen++;
        }
        SM3_compress(md);
        md->curlen = 0;
    }
    /* if the length is less than 56 bytes, pad upto 56 bytes of zeroes */
    for (; md->curlen < 56;)
    {
        md->buf[md->curlen] = 0;
        md->curlen++;
    }
    /* since all messages are under 2^32 bits we mark the top bits zero */
    for (i = 56; i < 60; i++)
    {
        md->buf[i] = 0;
    }
    /* append length */
    md->buf[63] = md->length & 0xff;
    md->buf[62] = (md->length >> 8) & 0xff;
    md->buf[61] = (md->length >> 16) & 0xff;
    md->buf[60] = (md->length >> 24) & 0xff;
    SM3_compress(md);
    /* copy output */
    memcpy(hash,md->state,SM3_len/8);
    BigEndian(hash,SM3_len/8,hash);//if CPU uses little-endian, BigEndian function is a necessary call
}
void SM3_256(unsigned char buf[], int len, unsigned char hash[])
{
    SM3_STATE md;
    SM3_init(&md);
    SM3_process(&md, buf, len);
    SM3_done(&md, hash);
}
int SM3_SelfTest()
{
    unsigned int i=0,a=1,b=1;
    unsigned char Msg1[3]={0x61,0x62,0x63};
    int MsgLen1=3;
    unsigned char MsgHash1[32]={0};
    unsigned char
            StdHash1[32]={0x66,0xC7,0xF0,0xF4,0x62,0xEE,0xED,0xD9,0xD1,0xF2,0xD4,0x6B,0xDC,0x10,0xE4,0xE2,
            0x41,0x67,0xC4,0x87,0x5C,0xF2,0xF7,0xA2,0x29,0x7D,0xA0,0x2B,0x8F,0x4B,0xA8,0xE0};
    unsigned char
            Msg2[64]={0x61,0x62,0x63,0x64,0x61,0x62,0x63,0x64,0x61,0x62,0x63,0x64,0x61,0x62,0x63,0x64,

                      0x61,0x62,0x63,0x64,0x61,0x62,0x63,0x64,0x61,0x62,0x63,0x64,0x61,0x62,0x63,0x64,

                      0x61,0x62,0x63,0x64,0x61,0x62,0x63,0x64,0x61,0x62,0x63,0x64,0x61,0x62,0x63,0x64,

                      0x61,0x62,0x63,0x64,0x61,0x62,0x63,0x64,0x61,0x62,0x63,0x64,0x61,0x62,0x63,0x64};
    int MsgLen2=64;
    unsigned char MsgHash2[32]={0};
    unsigned char
            StdHash2[32]={0xde,0xbe,0x9f,0xf9,0x22,0x75,0xb8,0xa1,0x38,0x60,0x48,0x89,0xc1,0x8e,0x5a,0x4d,
            0x6f,0xdb,0x70,0xe5,0x38,0x7e,0x57,0x65,0x29,0x3d,0xcb,0xa3,0x9c,0x0c,0x57,0x32};
    SM3_256(Msg1,MsgLen1,MsgHash1);
    SM3_256(Msg2,MsgLen2,MsgHash2);
    for(int i = 0; i < 32; i++){
        printf("%02x", MsgHash1[i]);
    }
    printf("\n");
    a=memcmp(MsgHash1,StdHash1,SM3_len/8);
    b=memcmp(MsgHash2,StdHash2,SM3_len/8);
    if ((a==0) && (b==0))
    {
        return 0;
    }
    else
    {
        return 1;
    }
}
int main(){
    printf("%d\n",SM3_SelfTest());
    return 0;
}
~~~

##### 运行结果

~~~ shell
$ ./sm3
66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0
0
$ echo -n "abc" | gmssl sm3
66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0
~~~

自测中生成了"abc"的哈希值，使用gmssl验证通过

#### SM4

##### SM4.h

~~~ c
xxxxxxxxxx157 1//2// Created by He-Zh on 2024/10/27.3//45#ifndef EXP2_SM4_H6#define EXP2_SM4_H7#define SM4_Rotl32(buf, n) (((buf)<<n)|((buf)>>(32-n)))8#include<stdio.h>9unsigned int SM4_CK[32] ={0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,10                          0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,11                          0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,12                          0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,13                          0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,14                          0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,15                          0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,16                          0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279};17unsigned char SM4_Sbox[256] =1819        {0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05,2021         0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99,2223         0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62,2425         0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6,2627         0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8,2829         0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35,3031         0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,3233         0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,3435         0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,3637         0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,3839         0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,4041         0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,4243         0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,4445         0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,4647         0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84,4849         0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48};50unsigned int SM4_FK[4] = {0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC};51void SM4_KeySchedule(unsigned char MK[], unsigned int rk[]);52void SM4_Encrypt(unsigned char MK[],unsigned char PlainText[],unsigned char CipherText[]);53void SM4_Decrypt(unsigned char MK[],unsigned char CipherText[], unsigned char PlainText[]);54int SM4_SelfCheck();5556#endif //EXP2_SM4_H57	
~~~

##### SM4.c

~~~ c
//
// Created by He-Zh on 2024/10/27.
//

#include "sm4.h"
void SM4_KeySchedule(unsigned char MK[],unsigned int rk[])
{
    unsigned int tmp,buf,K[36];
    int i;
    for(i=0;i<4;i++)
    {
        K[i]=SM4_FK[i]^( (MK[4*i]<<24) | (MK[4*i+1]<<16)
                         |(MK[4*i+2]<<8) | (MK[4*i+3]) );
    }
    for(i=0;i<32;i++)
    {
        tmp =K[i+1]^K[i+2]^K[i+3]^ SM4_CK[i];
        //nonlinear operation
        buf= (SM4_Sbox[(tmp >> 24) & 0xFF]) << 24
             |(SM4_Sbox[(tmp >> 16) & 0xFF]) << 16
             |(SM4_Sbox[(tmp >> 8) & 0xFF]) << 8
             |(SM4_Sbox[tmp & 0xFF]);
//linear operation
        K[i+4]=K[i]^((buf)^(SM4_Rotl32((buf),13))^(SM4_Rotl32((buf),23)));
        rk[i]=K[i+4];
    }
}
void SM4_Encrypt(unsigned char MK[],unsigned char PlainText[],unsigned char CipherText[])
{
    unsigned int rk[32],X[36],tmp,buf;
    int i,j;
    SM4_KeySchedule(MK,rk);
    for(j=0;j<4;j++)
    {
        X[j]=(PlainText[j*4]<<24) |(PlainText[j*4+1]<<16)
             |(PlainText[j*4+2]<<8)|(PlainText[j*4+3]);
    }
    for(i=0;i<32;i++)
    {
        tmp = X[i+1]^X[i+2]^X[i+3]^rk[i];
        //nonlinear operation
        buf= ( SM4_Sbox[(tmp >> 24) & 0xFF]) << 24
             |(SM4_Sbox[(tmp >> 16) & 0xFF]) << 16
             |(SM4_Sbox[(tmp >> 8) & 0xFF]) << 8
             |(SM4_Sbox[tmp & 0xFF]);
        //linear operation
        X[i+4]=X[i]^(buf^SM4_Rotl32((buf),2)^ SM4_Rotl32((buf),10)
                     ^ SM4_Rotl32((buf),18)^ SM4_Rotl32((buf),24));
    }
    for(j=0;j<4;j++)
    {
        CipherText[4*j]=(X[35-j]>> 24)& 0xFF;
        CipherText[4*j+1]=(X[35-j]>> 16)& 0xFF;
        CipherText[4*j+2]=(X[35-j]>> 8)& 0xFF;
        CipherText[4*j+3]=(X[35-j])& 0xFF;
    }
}
void SM4_Decrypt(unsigned char MK[],unsigned char CipherText[],unsigned char PlainText[])
{
    unsigned int rk[32],X[36],tmp,buf;
    int i,j;
    SM4_KeySchedule(MK,rk);
    for(j=0;j<4;j++)
    {
        X[j]=(CipherText[j*4]<<24) |(CipherText[j*4+1]<<16)|
             (CipherText[j*4+2]<<8)|(CipherText[j*4+3]);
    }
    for(i=0;i<32;i++)
    {
        tmp = X[i+1]^X[i+2]^X[i+3]^rk[31-i];
        //nonlinear operation
        buf= (SM4_Sbox[(tmp >> 24) & 0xFF]) << 24
             |(SM4_Sbox[(tmp >> 16) & 0xFF]) << 16
             |(SM4_Sbox[(tmp >> 8) & 0xFF]) << 8
             |(SM4_Sbox[tmp & 0xFF]);
        //linear operation
        X[i+4]=X[i]^(buf^SM4_Rotl32((buf),2)^ SM4_Rotl32((buf),10)
                     ^ SM4_Rotl32((buf),18)^ SM4_Rotl32((buf),24));
    }
    for(j=0;j<4;j++)
    {
        PlainText[4*j]=(X[35-j]>> 24)& 0xFF;
        PlainText[4*j+1]=(X[35-j]>>16)& 0xFF;
        PlainText[4*j+2]=(X[35-j]>> 8)& 0xFF;
        PlainText[4*j+3]=(X[35-j])& 0xFF;
    }
}
int SM4_SelfCheck()
{
    int i;
    //Standard data
    unsigned char key[16] =
            {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};
    unsigned char plain[16]=
            {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};
    unsigned char
            cipher[16]={0x68,0x1e,0xdf,0x34,0xd2,0x06,0x96,0x5e,0x86,0xb3,0xe9,0x4f,0x53,0x6e,0x42,0x46}
    ;
    unsigned char En_output[16];
    unsigned char De_output[16];
    SM4_Encrypt(key,plain,En_output);
    SM4_Decrypt(key,cipher,De_output);
    for(i=0;i<16;i++)
    {
        if ( (En_output[i]!=cipher[i]) | (De_output[i]!=plain[i]) )
        {
             printf("Self-check error");
            return 1;
        }
    }
    printf("Self-check success");
    return 0;
}
int main(){
    SM4_SelfCheck();
    return 0;
}
~~~

##### 运行结果

~~~ shell
$ echo -ne "\x01\x23\x45\x67\x89\xab\xcd\xef\xfe\xdc\xba\x98\x76\x54\x32\x10" > key.bin
$ echo -ne "\x01\x23\x45\x67\x89\xab\xcd\xef\xfe\xdc\xba\x98\x76\x54\x32\x10" > plain.txt 
$ gmssl sm4_ecb -encrypt -in plain.txt -key $(xxd -p -c 32 key.bin) -out enc.bin
$ od -tc -tx1 enc.bin 
0000000   h 036 337   4 322 006 226   ^ 206 263 351   O   S   n   B   F
         68  1e  df  34  d2  06  96  5e  86  b3  e9  4f  53  6e  42  46
0000020
zhanhe@zhanhe:~/roc-exp/exp2/sm4$ ./sm4
681edf34d206965e86b3e94f536e4246
Self-check success
~~~

加密结果与gmssl结果一致

#### SM2

一直自测不通过，同时几个同学也有同样的报错情况，在网上找了一个自带miracl库的仓库源代码测试，三个功能自测都通过，猜测是实验安装的miracl库存在问题。

代码文件见:下方参考链接

~~~ shell
$ tree
.
├── Makefile
├── libsm2alg.a
├── miracl
│   ├── Makefile
│   ├── miracl.h
│   ├── mirdef.h
│   ├── mraes.c
│   ├── mralloc.c
│   ├── mrarth0.c
│   ├── mrarth1.c
│   ├── mrarth2.c
│   ├── mrarth3.c
│   ├── mrbits.c
│   ├── mrbrick.c
│   ├── mrbuild.c
│   ├── mrcore.c
│   ├── mrcrt.c
│   ├── mrcurve.c
│   ├── mrdouble.c
│   ├── mrebrick.c
│   ├── mrec2m.c
│   ├── mrecn2.c
│   ├── mrfast.c
│   ├── mrflash.c
│   ├── mrflsh1.c
│   ├── mrflsh2.c
│   ├── mrflsh3.c
│   ├── mrflsh4.c
│   ├── mrfpe.c
│   ├── mrfrnd.c
│   ├── mrgcd.c
│   ├── mrgcm.c
│   ├── mrgf2m.c
│   ├── mrio1.c
│   ├── mrio2.c
│   ├── mrjack.c
│   ├── mrlucas.c
│   ├── mrmonty.c
│   ├── mrmuldv.c
│   ├── mrpi.c
│   ├── mrpower.c
│   ├── mrprime.c
│   ├── mrrand.c
│   ├── mrround.c
│   ├── mrscrt.c
│   ├── mrsha3.c
│   ├── mrshs.c
│   ├── mrshs256.c
│   ├── mrshs512.c
│   ├── mrsmall.c
│   ├── mrsroot.c
│   ├── mrstrong.c
│   ├── mrxgcd.c
│   ├── mrzzn2.c
│   ├── mrzzn2b.c
│   ├── mrzzn3.c
│   └── mrzzn4.c
├── sm2.c
├── sm2.h
├── sm2.o
├── sm2_test
├── sm2alg.c
├── sm2alg.h
├── sm2alg.o
├── sm3.c
├── sm3.h
├── sm3.o
├── sm_test.c
├── sm_test.o
├── sms4.c
├── sms4.h
└── sms4.o

1 directory, 71 files
~~~

##### 运行结果

~~~ shell
$ ./sm2_test 
SM2_enc_selftest pass
SM2_enc_selftest:0
SM2_sign_selftest:0
SM2_standard_keyex_selftest:0
~~~

### 在密标委⽹站http://www.gmbz.org.cn/main/bzlb.html查找SM2，SM3，SM4相关标准，分析代码实现与标准的对应关系。（6分）

- SM3：[SM3 密码杂凑算法](http://www.gmbz.org.cn/main/viewfile/20180108023812835219.html)
- SM4: [SM4分组密码算法](http://www.gmbz.org.cn/main/viewfile/20180108015408199368.html)
- SM2
    - [SM2 椭圆曲线公钥密码算法第1部分：总则](http://www.gmbz.org.cn/main/viewfile/20180108015515787986.html)
    - [SM2 椭圆曲线公钥密码算法第2部分：数字签名算法](http://www.gmbz.org.cn/main/viewfile/20180108023346264349.html)
    - [SM2 椭圆曲线公钥密码算法第3部分：密钥交换协议](http://www.gmbz.org.cn/main/viewfile/20180108023456003485.html)
    - [SM2 椭圆曲线公钥密码算法第4部分：公钥加密算法](http://www.gmbz.org.cn/main/viewfile/20180108023602687857.html)
    - [SM2 椭圆曲线公钥密码算法第5部分：参数定义](http://www.gmbz.org.cn/main/viewfile/2018010802371372251.html)
#### SM2加解密
| 标准             | 函数实现                                 | 备注                                                         |
| ---------------- | ---------------------------------------- | ------------------------------------------------------------ |
| 常数与符号       | 一一对应                                 |                                                              |
| 辅助函数         | KDF                                      |                                                              |
| 加密算法         | SM2_Encrypt 函数                         |                                                              |
| 解密算法         | SM2_Decrypt 函数                         |                                                              |
| 椭圆曲线系统参数 | SM2_Init 函数                            |                                                              |
| 用户密钥对       | Test_PubKey 函数，SM2_KeyGeneration 函数 | SM2_KeyGeneration 函数作用：该函数用于从给定的私钥生成相应的公钥。在椭圆曲线密码学中，公钥是通过对基点（G）进行私钥的标量乘法得到的。即公钥 pubKey = [priKey]G，其中 priKey 是私钥，G 是椭圆曲线上的基点，[priKey]G 表示将基点G进行私钥对应的标量乘法操作。输入：私钥 priKey，这是一个大整数，通常在 [1, n-2] 范围内，其中n是椭圆曲线的基点G的阶。输出：公钥 pubKey，这是一个椭圆曲线上的点，表示为 (x, y) 坐标。返回：函数返回0表示成功生成公钥，返回1表示生成公钥过程中出现错误，比如私钥不在有效范围内或者公钥点不在椭圆曲线上。Test_PubKey 函数作用：该函数用于验证给定的公钥是否有效。有效性检查包括：公钥点是否在无穷远点（点在椭圆曲线上的定义之外），公钥点的坐标是否在有限域内，以及公钥点是否在椭圆曲线上，最后还要检查公钥点的阶是否等于n。输入：公钥点 pubKey，这是一个椭圆曲线上的点。输出：无。返回：函数返回0表示公钥有效，返回1表示公钥点是无穷远点，返回2表示公钥点的X或Y坐标超出了有限域的范围，返回3表示公钥点不在椭圆曲线上，返回4表示公钥点的阶不等于n。 |
#### SM2密钥协商
| 标准         | 函数实现                                                     | 备注                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 常数与符号   | 一一对应                                                     |                                                              |
| 辅助函数     | KDF                                                          |                                                              |
| 用户密钥对   | SM2_KeyGeneration 函数                                       |                                                              |
| 密钥交换协议 | SM2_KeyEx_Init_I 函数，SM2_KeyEx_Re_I 函数，SM2_KeyEx_Init_II 函数，SM2_KeyEx_Re_II 函数 | SM2_KeyEx_Init_I 函数：作用：密钥交换的初始化步骤，由发起方（例如Alice）生成一个随机数rA并计算点RA，这是密钥交换的第一步。SM2_KeyEx_Re_I 函数：作用：密钥交换的响应步骤，由响应方（例如Bob）生成RB，并计算一个共享的秘密密钥。Bob将RB发送给Alice。SM2_KeyEx_Init_II 函数：作用：密钥交换的完成步骤，由发起方Alice计算共享的秘密密钥，并计算一个哈希值供响应方Bob验证。SM2_KeyEx_Re_II 函数： 作用：（可选）响应方Bob验证从发起方Alice接收到的哈希值，以确保密钥交换的完整性和安全性 |
#### SM2签名验签
| 标准             | 函数实现                                                     | 备注                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 常数与符号       | 一一对应                                                     |                                                              |
| 辅助函数         | KDF                                                          |                                                              |
| 用户密钥对       | SM2_KeyGeneration                                            |                                                              |
| 数字签名生成算法 | SM2_Sign                                                     |                                                              |
| 数字签名验证算法 | SM2_Verify                                                   |                                                              |
| 其他             | SM2_Init、Test_Point、Test_PubKey、Test_Zero、Test_n、Test_Range和SM3_256 | 持上述签名生成和验证过程中的辅助函数。它们用于初始化曲线参数、验证点是否在曲线上、验证公钥的有效性、检查大整数是否为零或等于n、以及计算哈希值 |
#### SM3
| 标准     | 函数实现                   | 详细解释                                                     |
| -------- | -------------------------- | ------------------------------------------------------------ |
| 常数     | 一一对应                   |                                                              |
| 消息扩展 | BiToW 函数，WToW1 函数     | BiToW 函数：这个函数将输入的512位消息块（分割成16个32位字）扩展到一个512位的W数组，分成68个32位字。这个过程涉及到位操作和与SM3算法的固定参数相结合。WToW1 函数：这个函数进一步扩展消息，通过将W数组的每个元素与其后第四个元素进行异或操作，生成新的W1数组。这个数组将用于后续的压缩函数。 |
| 压缩函数 | CF 函数，SM3_compress 函数 | CF 函数：这个函数执行SM3算法的核心压缩操作，它使用W和W1数组以及一系列非线性和线性变换来更新哈希值。这个过程涉及到多轮迭代，每轮使用不同的参数和操作。SM3_compress 函数：这个函数执行实际的压缩操作，它调用BigEndian函数进行字节序转换，然后调用BiToW和WToW1函数进行消息扩展，最后调用CF函数执行压缩操作。 |
| 迭代过程 | CF 函数，SM3_compress 函数 | 在CF函数中：这个函数通过64轮迭代，使用W和W1数组以及一系列非线性和线性变换来更新哈希值。每轮迭代都涉及到消息的加权、压缩和哈希状态的更新。在SM3_process函数中：这个函数处理输入的消息，将其分割成512位的块，并重复调用SM3_compress函数来压缩每个块，直到所有消息都被处理。 |

#### SM4
| 标准         | 函数实现             |
| ------------ | :------------------- |
| 轮函数F      | SM4_KeySchedule 函数 |
| 加密算法     | SM4_Encrypt 函数     |
| 解密算法     | SM4_Decrypt 函数     |
| 密钥扩展算法 | SM4_KeySchedule 函数 |

### 使⽤Rust完成SM2，SM3，SM4算法的实现（选做，10分）

#### SM4

~~~ rust
const SM4_CK: [u32; 32] = [
    0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,
    0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
    0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
    0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
    0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
    0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
    0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
    0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279,
];

const SM4_SBOX: [u8; 256] = [
    0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05,
    0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99,
    0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62,
    0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6,
    0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8,
    0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35,
    0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87,
    0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e,
    0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1,
    0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3,
    0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f,
    0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51,
    0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8,
    0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0,
    0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84,
    0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48,
];

const SM4_FK: [u32; 4] = [0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC];

fn sm4_rotl32(buf: u32, n: u32) -> u32 {
    (buf << n) | (buf >> (32 - n))
}

fn sm4_key_schedule(mk: &[u8], rk: &mut [u32; 32]) {
    let mut k = [0u32; 36];
    for i in 0..4 {
        k[i] = SM4_FK[i]
            ^ ((mk[4 * i] as u32) << 24
            | (mk[4 * i + 1] as u32) << 16
            | (mk[4 * i + 2] as u32) << 8
            | (mk[4 * i + 3] as u32));
    }

    for i in 0..32 {
        let tmp = k[i + 1] ^ k[i + 2] ^ k[i + 3] ^ SM4_CK[i];
        let buf = (SM4_SBOX[(tmp >> 24) as usize & 0xFF] as u32) << 24
            | (SM4_SBOX[(tmp >> 16) as usize & 0xFF] as u32) << 16
            | (SM4_SBOX[(tmp >> 8) as usize & 0xFF] as u32) << 8
            | SM4_SBOX[tmp as usize & 0xFF] as u32;
        k[i + 4] = k[i] ^ (buf ^ sm4_rotl32(buf, 13) ^ sm4_rotl32(buf, 23));
        rk[i] = k[i + 4];
    }
}
fn sm4_substitute(input: u32) -> u32 {
    // 使用S盒来替代输入字节
    let mut buf = 0u32;
    buf |= (SM4_SBOX[(input >> 24) as usize & 0xFF] as u32) << 24;
    buf |= (SM4_SBOX[(input >> 16) as usize & 0xFF] as u32) << 16;
    buf |= (SM4_SBOX[(input >> 8) as usize & 0xFF] as u32) << 8;
    buf |= SM4_SBOX[input as usize & 0xFF] as u32;
    buf
}

fn sm4_round_function(x0: u32, x1: u32, x2: u32, x3: u32, rk: u32) -> u32 {
    let tmp = x1 ^ x2 ^ x3 ^ rk;
    let buf = sm4_substitute(tmp);
    x0 ^ buf ^ sm4_rotl32(buf, 2) ^ sm4_rotl32(buf, 10) ^ sm4_rotl32(buf, 18) ^ sm4_rotl32(buf, 24)
}

fn sm4_encrypt(input: &[u8], output: &mut [u8], rk: &[u32; 32]) {
    let mut x = [0u32; 36];
    for i in 0..4 {
        x[i] = (input[4 * i] as u32) << 24
            | (input[4 * i + 1] as u32) << 16
            | (input[4 * i + 2] as u32) << 8
            | input[4 * i + 3] as u32;
    }

    for i in 0..32 {
        x[i + 4] = sm4_round_function(x[i], x[i + 1], x[i + 2], x[i + 3], rk[i]);
    }

    for i in 0..4 {
        output[4 * i] = (x[35 - i] >> 24) as u8;
        output[4 * i + 1] = (x[35 - i] >> 16) as u8;
        output[4 * i + 2] = (x[35 - i] >> 8) as u8;
        output[4 * i + 3] = x[35 - i] as u8;
    }
}

fn sm4_decrypt(input: &[u8], output: &mut [u8], rk: &[u32; 32]) {
    let mut x = [0u32; 36];
    for i in 0..4 {
        x[i] = (input[4 * i] as u32) << 24
            | (input[4 * i + 1] as u32) << 16
            | (input[4 * i + 2] as u32) << 8
            | input[4 * i + 3] as u32;
    }

    for i in 0..32 {
        x[i + 4] = sm4_round_function(x[i], x[i + 1], x[i + 2], x[i + 3], rk[31 - i]);
    }

    for i in 0..4 {
        output[4 * i] = (x[35 - i] >> 24) as u8;
        output[4 * i + 1] = (x[35 - i] >> 16) as u8;
        output[4 * i + 2] = (x[35 - i] >> 8) as u8;
        output[4 * i + 3] = x[35 - i] as u8;
    }
}
fn sm4_self_check() -> bool {
    // 标准测试数据
    let key: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    ];
    let plain: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    ];
    let expected_cipher: [u8; 16] = [
        0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
        0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46,
    ];

    // 结果缓冲区
    let mut rk = [0u32; 32];
    let mut cipher = [0u8; 16];
    let mut decrypted = [0u8; 16];

    // 生成轮密钥
    sm4_key_schedule(&key, &mut rk);

    // 加密
    sm4_encrypt(&plain, &mut cipher, &rk);
    // 检查加密结果是否与期望值相同
    if cipher != expected_cipher {
        println!("Self-check error: encryption failed.");
        return false;
    }

    // 解密
    sm4_decrypt(&cipher, &mut decrypted, &rk);
    // 检查解密结果是否恢复为原始明文
    if decrypted != plain {
        println!("Self-check error: decryption failed.");
        return false;
    }

    println!("Self-check success.");
    true
}

fn main() {
    if sm4_self_check() {
        println!("SM4 encryption and decryption passed the self-check.");
    } else {
        println!("SM4 encryption and decryption failed the self-check.");
    }
}
~~~

~~~ shell
Self-check success.
SM4 encryption and decryption passed the self-check.
~~~

#### SM3

~~~ rust
use std::mem::transmute;

const SM3_LEN: usize = 256;
const SM3_T1: u32 = 0x79CC4519;
const SM3_T2: u32 = 0x7A879D8A;
const SM3_IVA: u32 = 0x7380166f;
const SM3_IVB: u32 = 0x4914b2b9;
const SM3_IVC: u32 = 0x172442d7;
const SM3_IVD: u32 = 0xda8a0600;
const SM3_IVE: u32 = 0xa96f30bc;
const SM3_IVF: u32 = 0x163138aa;
const SM3_IVG: u32 = 0xe38dee4d;
const SM3_IVH: u32 = 0xb0fb0e4e;

#[derive(Clone)]
struct Sm3State {
    state: [u32; 8],
    length: u64,
    curlen: usize,
    buf: [u8; 64],
}

impl Sm3State {
    fn new() -> Self {
        Self {
            state: [SM3_IVA, SM3_IVB, SM3_IVC, SM3_IVD, SM3_IVE, SM3_IVF, SM3_IVG, SM3_IVH],
            length: 0,
            curlen: 0,
            buf: [0u8; 64],
        }
    }

    fn p1(x: u32) -> u32 {
        x ^ Sm3State::rotl(x, 15) ^ Sm3State::rotl(x, 23)
    }

    fn p0(x: u32) -> u32 {
        x ^ Sm3State::rotl(x, 9) ^ Sm3State::rotl(x, 17)
    }

    fn ff0(a: u32, b: u32, c: u32) -> u32 {
        a ^ b ^ c
    }

    fn ff1(a: u32, b: u32, c: u32) -> u32 {
        (a & b) | (a & c) | (b & c)
    }

    fn gg0(e: u32, f: u32, g: u32) -> u32 {
        e ^ f ^ g
    }

    fn gg1(e: u32, f: u32, g: u32) -> u32 {
        (e & f) | (!e & g)
    }

    fn rotl(x: u32, n: u32) -> u32 {
        (x << n) | (x >> (32 - n))
    }

    fn big_endian(src: &[u8], bytelen: usize, des: &mut [u8]) {
        for i in 0..(bytelen / 4) {
            des[4 * i] = src[4 * i + 3];
            des[4 * i + 1] = src[4 * i + 2];
            des[4 * i + 2] = src[4 * i + 1];
            des[4 * i + 3] = src[4 * i];
        }
    }

    fn bi_to_w(bi: &[u32; 16], w: &mut [u32; 68]) {
        w[0..16].copy_from_slice(bi);
        for i in 16..68 {
            let tmp = w[i - 16] ^ w[i - 9] ^ Sm3State::rotl(w[i - 3], 15);
            w[i] = Sm3State::p1(tmp) ^ Sm3State::rotl(w[i - 13], 7) ^ w[i - 6];
        }
    }

    fn w_to_w1(w: &[u32; 68], w1: &mut [u32; 64]) {
        for i in 0..64 {
            w1[i] = w[i] ^ w[i + 4];
        }
    }

    fn cf(w: &[u32; 68], w1: &[u32; 64], v: &mut [u32; 8]) {
        let mut a = v[0];
        let mut b = v[1];
        let mut c = v[2];
        let mut d = v[3];
        let mut e = v[4];
        let mut f = v[5];
        let mut g = v[6];
        let mut h = v[7];
        let mut t = SM3_T1;

        for j in 0..64 {
            if j == 16 {
                t = Sm3State::rotl(SM3_T2, 16);
            } else if j > 0 {
                t = Sm3State::rotl(t, 1);
            }
            let ss1 = Sm3State::rotl(Sm3State::rotl(a, 12).wrapping_add(e).wrapping_add(t), 7);
            let ss2 = ss1 ^ Sm3State::rotl(a, 12);
            let tt1 = if j <= 15 {
                Sm3State::ff0(a, b, c)
            } else {
                Sm3State::ff1(a, b, c)
            }
                .wrapping_add(d)
                .wrapping_add(ss2)
                .wrapping_add(w1[j]);
            let tt2 = if j <= 15 {
                Sm3State::gg0(e, f, g)
            } else {
                Sm3State::gg1(e, f, g)
            }
                .wrapping_add(h)
                .wrapping_add(ss1)
                .wrapping_add(w[j]);

            d = c;
            c = Sm3State::rotl(b, 9);
            b = a;
            a = tt1;
            h = g;
            g = Sm3State::rotl(f, 19);
            f = e;
            e = Sm3State::p0(tt2);
        }

        v[0] ^= a;
        v[1] ^= b;
        v[2] ^= c;
        v[3] ^= d;
        v[4] ^= e;
        v[5] ^= f;
        v[6] ^= g;
        v[7] ^= h;
    }

    fn compress(&mut self) {
        let mut w = [0u32; 68];
        let mut w1 = [0u32; 64];
        let mut buf = [0u32; 16];

        for i in 0..16 {
            buf[i] = u32::from_be_bytes([self.buf[4 * i], self.buf[4 * i + 1], self.buf[4 * i + 2], self.buf[4 * i + 3]]);
        }

        Sm3State::bi_to_w(&buf, &mut w);
        Sm3State::w_to_w1(&w, &mut w1);
        Sm3State::cf(&w, &w1, &mut self.state);
    }

    fn process(&mut self, buf: &[u8]) {
        for &b in buf {
            self.buf[self.curlen] = b;
            self.curlen += 1;

            if self.curlen == 64 {
                self.compress();
                self.length += 512;
                self.curlen = 0;
            }
        }
    }

    fn done(&mut self, hash: &mut [u8; 32]) {
        self.length += (self.curlen as u64) << 3;

        self.buf[self.curlen] = 0x80;
        self.curlen += 1;

        if self.curlen > 56 {
            self.buf[self.curlen..64].fill(0);
            self.compress();
            self.curlen = 0;
        }

        self.buf[self.curlen..56].fill(0);

        self.buf[56..64].copy_from_slice(&self.length.to_be_bytes());
        self.compress();

        for (i, &s) in self.state.iter().enumerate() {
            hash[i * 4..i * 4 + 4].copy_from_slice(&s.to_be_bytes());
        }
    }
}

fn sm3_256(buf: &[u8], hash: &mut [u8; 32]) {
    let mut state = Sm3State::new();
    state.process(buf);
    state.done(hash);
}

fn main() {
    let mut hash = [0u8; 32];
    sm3_256(b"abc", &mut hash);
    for byte in &hash {
        print!("{:02x}", byte);
    }
    println!();
}

~~~

~~~ shell
C:/Users/He-Zh/.cargo/bin/cargo.exe run --color=always --package sm3 --bin sm3
warning: unused import: `std::mem::transmute`
 --> src\main.rs:1:5
  |
1 | use std::mem::transmute;
  |     ^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: constant `SM3_LEN` is never used
 --> src\main.rs:3:7
  |
3 | const SM3_LEN: usize = 256;
  |       ^^^^^^^
  |
warning: associated function `big_endian` is never used
  --> src\main.rs:61:8
   |
23 | impl Sm3State {
   | ------------- associated function in this implementation
...
61 |     fn big_endian(src: &[u8], bytelen: usize, des: &mut [u8]) {
   |        ^^^^^^^^^^

warning: `sm3` (bin "sm3") generated 3 warnings (run `cargo fix --bin "sm3"` to apply 1 suggestion)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running `target\debug\sm3.exe`
66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0
~~~

结果一致

####  SM2

##### sm2.rs

~~~ RUST
use crate::sm3::{sm3_hash, sm3_hash_raw};
use std::vec;
use num_bigint::BigUint;
use num_traits::*;
use num_integer::*;
use rand::seq::SliceRandom;
use std::process::Command;
use std::path::Path;
use std::fs;
use std::borrow::Cow;

static PARA_LEN: usize = 64;
static ECC_N: &str = "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123";
static ECC_P: &str = "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF";
static ECC_G: &str = "32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0";
static ECC_A: &str = "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC";
static ECC_B: &str = "28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93";

macro_rules! format_hex {
    ($a: expr) => {
        format!("{:0width$x}", $a, width = PARA_LEN)
    };

    ($a: expr, $b: expr) => {
        format!("{:0width$x}{:0width$x}", $a, $b, width = PARA_LEN)
    };

    ($a: expr, $($b: tt)*) => {
        format!("{:0width$x}{}", $a, format_hex!($($b)*), width = PARA_LEN)
    }
}

fn submod(a: &BigUint, b: &BigUint, ecc_p: &BigUint) -> BigUint {
    if a >= b {
        (a - b) % ecc_p
    } else {
        let d = b - a;
        let e = d.div_ceil(ecc_p);
        e * ecc_p - d
    }
}

fn random_hex(x: usize) -> String {
    let c = vec!["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    let mut s: String = "".to_string();
    for _ in 0..x {
        s += *c.choose(&mut rand::thread_rng()).unwrap();
    }
    s
}

fn appendzero(data: &[u8], size: usize) -> Vec<u8> {
    let mut result = Vec::with_capacity(size);
    if data.len() < size {
        result.extend(std::iter::repeat(0).take(size - data.len()));
        result.extend_from_slice(data);
    } else {
        result.extend_from_slice(data);
    }
    result
}

fn concvec(vec1: &[u8], vec2: &[u8]) -> Vec<u8> {
    let mut vec1 = vec1.to_vec();
    vec1.extend(vec2);
    vec1
}

macro_rules! concvec {
    ($a: expr) => {
        $a.to_vec()
    };

    ($a: expr, $b: expr) => {
        concvec($a, $b)
    };

    ($a: expr, $($b: tt)*) => {
        concvec($a, &concvec!($($b)*))
    }
}

fn kdf(z: &[u8], klen: usize) -> Vec<u8> {
    let mut c: Vec<u8> = Vec::with_capacity(klen);
    let mut ct = 0x00000001u32;
    let j: usize = (klen + 31) / 32;
    let mut tmp: Vec<u8> = Vec::with_capacity(68);
    for i in 0..j {
        tmp.clear();
        tmp.extend_from_slice(z);
        tmp.extend_from_slice(&ct.to_be_bytes());
        let hash = sm3_hash_raw(&tmp);
        if i + 1 == j && klen % 32 != 0 {
            c.extend_from_slice(&hash[0..(klen % 32)])
        } else {
            c.extend_from_slice(&hash)
        }
        ct += 1;
    }
    c
}

fn pubkey2point(public_key: &str) -> Point {
    Point {
        x: BigUint::from_str_radix(&public_key[0..PARA_LEN], 16).unwrap(),
        y: BigUint::from_str_radix(&public_key[PARA_LEN..], 16).unwrap(),
        z: BigUint::one()
    }
}

#[derive(Debug, Clone, Eq, PartialEq)]
struct Point {
    x: BigUint,
    y: BigUint,
    z: BigUint
}

fn double_point(input: Point) -> Point {
    let (x1, y1, z1) = (input.x, input.y, input.z);
    let ecc_p = BigUint::from_str_radix(ECC_P, 16).unwrap();
    let t6 = (&z1 * &z1) % &ecc_p;
    let t2 = (&y1 * &y1) % &ecc_p;
    let t3 = (&x1 + &t6) % &ecc_p;
    let t4 = submod(&x1, &t6, &ecc_p);
    let t1 = (&t3 * &t4) % &ecc_p;
    let t3 = (&y1 * &z1) % &ecc_p;
    let mut t4 = (&t2 * BigUint::new(vec![8])) % &ecc_p;
    let t5 = (&x1 * &t4) % &ecc_p;
    let t1 = (&t1 * BigUint::new(vec![3])) % &ecc_p;
    let t6 = (&t6 * &t6) % &ecc_p;
    let ecc_a3 = BigUint::new(vec![0]);
    let t6 = (&ecc_a3 * &t6) % &ecc_p;
    let t1 = (&t1 + &t6) % &ecc_p;
    let z3 = (&t3 + &t3) % &ecc_p;
    let t3 = (&t1 * &t1) % &ecc_p;
    let t2 = (&t2 * &t4) % &ecc_p;
    let x3 = submod(&t3, &t5, &ecc_p);
    if &t5 % BigUint::new(vec![2]) == BigUint::one() {
        let tt = &t5 + ((&t5 + &ecc_p) >> 1);
        t4 = submod(&tt, &t3, &ecc_p);
    } else {
        let tt = &t5 + (&t5 >> 1);
        t4 = submod(&tt, &t3, &ecc_p);
    }
    let t1 = (&t1 * &t4) % &ecc_p;
    let y3 = submod(&t1, &t2, &ecc_p);
    Point {
        x: x3,
        y: y3,
        z: z3
    }
}

fn add_point(p1: Point, p2: Point) -> Point {
    let (x1, y1, z1) = (p1.x, p1.y, p1.z);
    let (x2, y2) = (p2.x, p2.y);
    let ecc_p: BigUint = BigUint::from_str_radix(ECC_P, 16).unwrap();
    let t1: BigUint = (&z1 * &z1) % &ecc_p;
    let t2: BigUint = (&y2 * &z1) % &ecc_p;
    let t3: BigUint = (&x2 * &t1) % &ecc_p;
    let t1: BigUint = (&t1 * &t2) % &ecc_p;
    let t2: BigUint = submod(&t3, &x1, &ecc_p);
    let t3: BigUint = (&t3 + &x1) % &ecc_p;
    let t4: BigUint = (&t2 * &t2) % &ecc_p;
    let t1 = submod(&t1, &y1, &ecc_p);
    let z3: BigUint = (&z1 * &t2) % &ecc_p;
    let t2: BigUint = (&t2 * &t4) % &ecc_p;
    let t3: BigUint = (&t3 * &t4) % &ecc_p;
    let t5: BigUint = (&t1 * &t1) % &ecc_p;
    let t4: BigUint = (&x1 * &t4) % &ecc_p;
    let x3: BigUint = submod(&t5, &t3, &ecc_p);
    let t2: BigUint = (&y1 * &t2) % &ecc_p;
    let t3: BigUint = submod(&t4, &x3, &ecc_p);
    let t1: BigUint = (&t1 * &t3) % &ecc_p;
    let y3: BigUint = submod(&t1, &t2, &ecc_p);
    Point {
        x: x3,
        y: y3,
        z: z3
    }
}

fn convert_jacb_to_nor(point: Point) -> Point {
    let ecc_p: BigUint = BigUint::from_str_radix(ECC_P, 16).unwrap();
    let (x, y, z) = (point.x, point.y, point.z);
    let z_inv: BigUint = z.modpow(&(&ecc_p - BigUint::new(vec![2])), &ecc_p);
    let z_invsquar: BigUint = (&z_inv * &z_inv) % &ecc_p;
    let z_invqube: BigUint = (&z_invsquar * &z_inv) % &ecc_p;
    let x_new: BigUint = (&x * &z_invsquar) % &ecc_p;
    let y_new: BigUint = (&y * &z_invqube) % &ecc_p;
    let z_new: BigUint = (&z * &z_inv) % &ecc_p;
    if z_new == BigUint::one() {
        Point {
            x: x_new,
            y: y_new,
            z: z_new
        }
    } else {
        Point {
            x: BigUint::zero(),
            y: BigUint::zero(),
            z: BigUint::zero()
        }
    }
}

fn kg(k: BigUint, point: &str) -> Point {
    let mut k = k;
    let point: String = point.to_string() + "1";
    let point = Point {
        x: BigUint::from_str_radix(&point[0..PARA_LEN], 16).unwrap(),
        y: BigUint::from_str_radix(&point[PARA_LEN..(PARA_LEN * 2)], 16).unwrap(),
        z: BigUint::from_str_radix(&point[(PARA_LEN * 2)..], 16).unwrap()
    };
    let mut mask_str = "8".to_string();
    for _ in 0..((PARA_LEN) - 1) {
        mask_str += "0";
    }
    let mask: BigUint = BigUint::from_str_radix(&mask_str, 16).unwrap();
    let mut temp = point.clone();
    let mut flag = false;
    for _ in 0..(PARA_LEN * 4) {
        if flag {
            temp = double_point(temp);
        }
        if &k & &mask != BigUint::zero() {
            if flag {
                temp = add_point(temp, point.clone());
            } else {
                flag = true;
                temp = point.clone();
            }
        }
        k = k << 1;
    }
    convert_jacb_to_nor(temp)
}

/// Check whether the private key is legal.
pub fn privkey_valid(private_key: &str) -> bool {
    hex_valid(private_key) && private_key.len() == 64
}

/// Check whether the public key is legal. The input public key may or may not contain the "04" prefix.

pub fn pubkey_valid(public_key: &str) -> bool {
    let public_key_len = public_key.len();
    if public_key_len != 128 && public_key_len != 130 {
        return false;
    }
    if public_key_len == 130 && &public_key[0..2] != "04" {
        return false;
    }
    let public_key = pubkey_trim(public_key);
    if !hex_valid(&public_key) {
        return false;
    }
    let x: &str = &public_key[0..64];
    let y: &str = &public_key[64..128];
    let x = BigUint::from_str_radix(x, 16).unwrap();
    let y = BigUint::from_str_radix(y, 16).unwrap();
    let a = BigUint::from_str_radix(ECC_A, 16).unwrap();
    let b = BigUint::from_str_radix(ECC_B, 16).unwrap();
    let p = BigUint::from_str_radix(ECC_P, 16).unwrap();
    let np0 = kg(BigUint::from_str_radix(ECC_N, 16).unwrap(), &public_key) == Point {x: BigUint::zero(), y: BigUint::zero(), z: BigUint::zero()};
    let on_curve = (&y * &y) % &p == (&x * &x * &x + &a * &x + &b) % &p;
    np0 && on_curve
}

/// Check whether a hex string is legal.
pub fn hex_valid(input: &str) -> bool {
    let hex_chars: Vec<char> = vec![
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'a', 'b', 'c', 'd', 'e', 'f',
        'A', 'B', 'C', 'D', 'E', 'F'
    ];
    let input_chars: Vec<char> = input.chars().collect();
    let is_even = input_chars.len() % 2 == 0;
    let all_in_hex = input_chars.iter().map(|x| hex_chars.contains(&x)).into_iter().all(|x| x);
    is_even && all_in_hex
}

/// Check whether a base64 string is legal.
pub fn base64_valid(input: &str) -> bool {
    match base64::decode(input) {
        Ok(_) => true,
        Err(_) => false,
    }
}

fn pubkey_trim<'a>(public_key: &'a str) -> Cow<'a, str> {
    if public_key.len() == 130 && &public_key[0..2] == "04" {
        Cow::Borrowed(&public_key[2..])
    } else {
        Cow::Borrowed(public_key)
    }
}

fn keypair_from_pem_bytes(pem_bytes: Vec<u8>) -> (String, String) {
    let pem_try = pem::parse(pem_bytes);
    let pem: pem::Pem;
    match pem_try {
        Ok(v) => {
            pem = v;
        }
        Err(_) => {
            return ("".to_string(), "".to_string());
        }
    }
    let keyfield = pem.contents;
    let priv_key = hex::encode(&keyfield[36..68]);
    let pub_key = hex::encode(&keyfield[74..138]);
    let pub_key = if !pubkey_valid(&pub_key) && &pub_key[0..2] == "04" {
        hex::encode(&keyfield[75..139])
    } else {
        pub_key
    };
    (priv_key, pub_key)
}

/// Export private/public key from pem file. The pem file should be in pkcs8 format and unencryped.

pub fn keypair_from_pem_file(pem_file: &str) -> (String, String) {
    let pem_file_path = Path::new(pem_file);
    let pem_bytes = fs::read(pem_file_path).unwrap();
    keypair_from_pem_bytes(pem_bytes)
}

fn pubkey_from_pem_bytes(pem_bytes: Vec<u8>) -> String {
    // let pem = pem::parse(pem_bytes).unwrap();
    let pem: pem::Pem;
    if let Ok(v) = pem::parse(pem_bytes) {
        pem = v;
    } else {
        return "".to_string();
    }
    let keyfield = pem.contents;
    let pub_key = hex::encode(&keyfield[27..91]);
    pub_key
}

/// Export public key from pem file. The pem file should be in pkcs8 format and unencrypted.

pub fn pubkey_from_pem_file(pem_file: &str) -> String {
    let pem_file_path = Path::new(pem_file);
    let pem_bytes = fs::read(pem_file_path).unwrap();
    pubkey_from_pem_bytes(pem_bytes)
}

fn keypair_to_pem_bytes(private_key: &str) -> Vec<u8> {
    let public_key = pk_from_sk(private_key);
    let pem = "308187020100301306072a8648ce3d020106082a811ccf5501822d046d306b0201010420".to_string() + private_key + "a14403420004" + &public_key;
    let pem = hex::decode(pem).unwrap();
    let pem = base64::encode(pem);
    let pem = "-----BEGIN PRIVATE KEY-----".to_string() + "\n" + &pem[0..64] + "\n" + &pem[64..128] + "\n" + &pem[128..] + "\n-----END PRIVATE KEY-----\n";
    pem.into_bytes()
}

/// Dump the keypair from a private key to a pem file in unencryped pkcs8 format.

pub fn keypair_to_pem_file(private_key: &str, pem_file: &str) {
    let output_file = Path::new(pem_file);
    let pem_bytes = keypair_to_pem_bytes(private_key);
    fs::write(output_file, &pem_bytes[..]).unwrap();
}

fn pubkey_to_pem_bytes(public_key: &str) -> Vec<u8> {
    let public_key = pubkey_trim(public_key);
    let pem = "3059301306072a8648ce3d020106082a811ccf5501822d03420004".to_string() + &public_key;
    let pem = hex::decode(pem).unwrap();
    let pem = base64::encode(pem);
    let pem = "-----BEGIN PUBLIC KEY-----".to_string() + "\n" + &pem[0..64] + "\n" + &pem[64..] + "\n-----END PUBLIC KEY-----\n";
    pem.into_bytes()
}

/// Dump the public key to a pem file in unencryped pkcs8 format.

pub fn pubkey_to_pem_file(public_key: &str, pem_file: &str) {
    let output_file = Path::new(pem_file);
    let pem_bytes = pubkey_to_pem_bytes(public_key);
    fs::write(output_file, &pem_bytes[..]).unwrap();
}

/// A keypair can be generated by openssl. The `openssl` executable file must be in system PATH. Currently openssl 1.1.1 is supported.

pub fn gen_keypair_openssl() -> (String, String) {
    let output = if cfg!(target_os = "windows") {
        Command::new("cmd").args(["/C", "openssl ecparam -genkey -name SM2 | openssl pkcs8 -topk8 -inform PEM -outform pem -nocrypt"]).output().expect("openssl generate faild.")
    } else {
        Command::new("sh").arg("-c").arg("openssl ecparam -genkey -name SM2 | openssl pkcs8 -topk8 -inform PEM -outform pem -nocrypt").output().expect("openssl generate faild.")
    };
    let output = output.stdout;
    keypair_from_pem_bytes(output)
}

pub fn gen_keypair() -> (String, String) {
    let d = random_hex(PARA_LEN);
    let pa = kg(BigUint::from_str_radix(&d, 16).unwrap(), ECC_G);
    let pa = format_hex!(pa.x, pa.y);
    (d, pa)
}

/// Calculate public key from a private key.

pub fn pk_from_sk(private_key: &str) -> String {
    let p = kg(BigUint::from_str_radix(private_key, 16).unwrap(), ECC_G);
    format_hex!(p.x, p.y)
}

fn sign_raw(data: &[u8], private_key: &str) -> Vec<u8> {
    let e = BigUint::from_bytes_be(data);
    let d = BigUint::from_str_radix(private_key, 16).unwrap();
    let k = random_hex(PARA_LEN);
    let k = BigUint::from_str_radix(&k, 16).unwrap();
    let k1 = k.clone();
    let p1 = kg(k, ECC_G);
    let r = (e + p1.x) % BigUint::from_str_radix(ECC_N, 16).unwrap();
    if r == BigUint::zero() || &r + &k1 == BigUint::from_str_radix(ECC_N, 16).unwrap() {
        vec![]
    } else {
        let d_1: BigUint = (&d + BigUint::one()).modpow(&(BigUint::from_str_radix(ECC_N, 16).unwrap() - BigUint::new(vec![2])), &BigUint::from_str_radix(ECC_N, 16).unwrap());
        let s: BigUint = (&d_1 * (&k1 + &r) - &r) % BigUint::from_str_radix(ECC_N, 16).unwrap();
        if s == BigUint::zero() {
            vec![]
        }   else {
            yasna::construct_der(|writer| {
                writer.write_sequence(|writer| {
                    writer.next().write_biguint(&r);
                    writer.next().write_biguint(&s);
                });
            })
        }
    }
}

fn verify_raw(data: &[u8], sign: &[u8], public_key: &str) -> bool {
    let rs = yasna::parse_der(sign, |reader| {
        reader.read_sequence(|reader| {
            let r = reader.next().read_biguint()?;
            let s = reader.next().read_biguint()?;
            return Ok((r, s));
        })
    });
    let r: BigUint;
    let s: BigUint;
    match rs {
        Ok(v) => {
            r = v.0;
            s = v.1;
        }
        Err(_) => {
            return false;
        }
    }
    let r1 = r.clone();
    let s1 = s.clone();
    let e = BigUint::from_bytes_be(data);
    let t = (r + s) % BigUint::from_str_radix(ECC_N, 16).unwrap();
    let t1 = t.clone();
    if t == BigUint::zero() {
        false
    } else {
        let mut p1 = kg(s1, ECC_G);
        let p2 = kg(t1, public_key);
        if p1 == p2 {
            p1 = double_point(p1);
        } else {
            p1 = add_point(p1, p2);
            p1 = convert_jacb_to_nor(p1);
        }
        let x = p1.x;
        r1 == (&e + &x) % BigUint::from_str_radix(ECC_N, 16).unwrap()
    }
}

fn sign(id: &[u8], data: &[u8], private_key: &str) -> Vec<u8> {
    let public_key = pk_from_sk(private_key);
    let m_bar = concvec(&hex::decode(zab(&public_key, id)).unwrap(), data);
    let e = hex::decode(sm3_hash(&m_bar)).unwrap();
    sign_raw(&e, private_key)
}

fn verify(id: &[u8], data: &[u8], sign: &[u8], public_key: &str) -> bool {
    let m_bar = concvec(&hex::decode(zab(&public_key, id)).unwrap(), data);
    let e = hex::decode(sm3_hash(&m_bar)).unwrap();
    verify_raw(&e, sign, public_key)
}

fn sign_to_file(id: &[u8], data: &[u8], sign_file: &str, private_key: &str) {
    let sign_file = Path::new(sign_file);
    let sign_data = sign(id, data, private_key);
    fs::write(sign_file, &sign_data[..]).unwrap();
}

fn verify_from_file(id: &[u8], data: &[u8], sign_file: &str, public_key: &str) -> bool {
    let sign_file = Path::new(sign_file);
    let sign_data = fs::read(sign_file).unwrap();
    verify(id, data, &sign_data, public_key)
}

fn encrypt(data: &[u8], public_key: &str) -> Vec<u8> {
    let k = random_hex(PARA_LEN);
    let c1xyz = kg(BigUint::from_str_radix(k.as_str(), 16).unwrap(), ECC_G);
    let c1x = appendzero(&BigUint::to_bytes_be(&c1xyz.x), PARA_LEN / 2);
    let c1y = appendzero(&BigUint::to_bytes_be(&c1xyz.y), PARA_LEN / 2);
    let c1 = concvec(&c1x, &c1y);
    let xy = kg(BigUint::from_str_radix(k.as_str(), 16).unwrap(), public_key);
    let x2 = BigUint::to_bytes_be(&xy.x);
    let y2 = BigUint::to_bytes_be(&xy.y);
    let x2 = appendzero(&x2, PARA_LEN / 2);
    let y2 = appendzero(&y2, PARA_LEN / 2);
    let xy = concvec(&x2, &y2);
    let t = kdf(&xy, data.len());
    let cipher = if BigUint::from_bytes_be(&t) == BigUint::zero() {
        b"".to_vec()
    } else {
        let c2 = BigUint::from_bytes_be(&data) ^ BigUint::from_bytes_be(&t);
        let c2 = BigUint::to_bytes_be(&c2);
        let c2 = appendzero(&c2, data.len());
        let h = concvec!(&x2, data, &y2);
        let c3 = sm3_hash(&h);
        let c3 = hex::decode(c3).unwrap();
        let cipher = concvec!(&c1, &c3, &c2);
        cipher
    };
    cipher
}

fn decrypt(data: &[u8], private_key: &str) -> Vec<u8> {
    let c1 = &data[0..64];
    let c2 = &data[96..];
    let xy = kg(BigUint::from_str_radix(private_key, 16).unwrap(), &hex::encode(c1));
    let x = appendzero(&BigUint::to_bytes_be(&xy.x), 32);
    let y = appendzero(&BigUint::to_bytes_be(&xy.y), 32);
    let xy = concvec(&x, &y);
    let t = kdf(&xy, c2.len());
    let result = if BigUint::from_bytes_be(&t) == BigUint::zero() {
        vec![]
    } else {
        BigUint::to_bytes_be(&(BigUint::from_bytes_be(&c2) ^ BigUint::from_bytes_be(&t)))
    };
    result
}

fn encrypt_c1c2c3(data: &[u8], public_key: &str) -> Vec<u8> {
    let cipher_c1c3c2 = encrypt(data, public_key);
    let c1 = &cipher_c1c3c2[0..64];
    let c3 = &cipher_c1c3c2[64..96];
    let c2 = &cipher_c1c3c2[96..];
    concvec!(c1, c2, c3)
}

fn decrypt_c1c2c3(data: &[u8], private_key: &str) -> Vec<u8> {
    let c1 = &data[0..64];
    let c2 = &data[64..(data.len() - 32)];
    let c3 = &data[(data.len() - 32)..];
    let cipher_c1c3c2 = concvec!(c1, c3, c2);
    decrypt(&cipher_c1c3c2, private_key)
}

fn encrypt_asna1(data: &[u8], public_key: &str) -> Vec<u8> {
    let cipher = encrypt(data, public_key);
    let x = BigUint::from_bytes_be(&cipher[0..32]);
    let y = BigUint::from_bytes_be(&cipher[32..64]);
    let sm3 = &cipher[64..96];
    let secret = &cipher[96..];
    yasna::construct_der(|writer| {
        writer.write_sequence(|writer| {
            writer.next().write_biguint(&x);
            writer.next().write_biguint(&y);
            writer.next().write_bytes(&sm3);
            writer.next().write_bytes(&secret);
        });
    })
}

fn decrypt_asna1(data: &[u8], private_key: &str) -> Vec<u8> {
    let (x, y, sm3, secret) = yasna::parse_der(data, |reader| {
        reader.read_sequence(|reader| {
            let x = reader.next().read_biguint()?;
            let y = reader.next().read_biguint()?;
            let sm3 = reader.next().read_bytes()?;
            let secret = reader.next().read_bytes()?;
            return Ok((x, y, sm3, secret));
        })
    }).unwrap();
    let x = BigUint::to_bytes_be(&x);
    let y = BigUint::to_bytes_be(&y);
    let x = appendzero(&x, 32);
    let y = appendzero(&y, 32);
    let cipher = concvec!(&x, &y, &sm3, &secret);
    decrypt(&cipher, private_key)
}

fn encrypt_hex(data: &[u8], public_key: &str) -> String {
    hex::encode(encrypt(data, public_key))
}

fn decrypt_hex(data: &str, private_key: &str) -> Vec<u8> {
    decrypt(&hex::decode(data).unwrap(), private_key)
}

fn encrypt_base64(data: &[u8], public_key: &str) -> String {
    base64::encode(encrypt(data, public_key))
}

fn decrypt_base64(data: &str, private_key: &str) -> Vec<u8> {
    // decrypt(&base64::decode(data).unwrap(), private_key)
    if let Ok(v) = base64::decode(data) {
        decrypt(&v, private_key)
    } else {
        vec![]
    }
}

fn encrypt_to_file(data: &[u8], enc_file: &str, public_key: &str) {
    let enc_file = Path::new(enc_file);
    let enc_data = encrypt_asna1(data, public_key);
    fs::write(enc_file, &enc_data[..]).unwrap();
}

fn decrypt_from_file(enc_file: &str, private_key: &str) -> Vec<u8> {
    let enc_file = Path::new(enc_file);
    let enc_data = fs::read(enc_file).unwrap();
    decrypt_asna1(&enc_data, private_key)
}

fn kexhat(x: BigUint) -> BigUint {
    let w_2: Vec<u8> = [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].to_vec();
    let w_2 = BigUint::from_bytes_be(&w_2);
    &w_2 + (&x & (&w_2 - BigUint::new(vec![1])))
}

fn zab(public_key: &str, uid: &[u8]) -> String {
    let entla: usize = 8 * uid.len();
    let za = concvec!(
        &vec![((entla >> 8) & 0xFF) as u8, (entla & 0xFF) as u8], 
        uid, 
        &hex::decode(ECC_A).unwrap(), 
        &hex::decode(ECC_B).unwrap(), 
        &hex::decode(ECC_G).unwrap(), 
        &hex::decode(public_key).unwrap()
    );
    sm3_hash(&za)
}

pub struct KeyExchangeResult {
    pub k: String,
    pub s12: Vec<u8>
}

fn keyexchange_raw(klen: usize, ida: &[u8], idb: &[u8], private_key: &str, public_key: &str, r_private_key: &str, r_public_key: &str, is_a: bool) -> KeyExchangeResult {
    let x2hat = kexhat(BigUint::from_str_radix(&pk_from_sk(r_private_key)[0..64], 16).unwrap());
    let x2rb = x2hat * BigUint::from_str_radix(r_private_key, 16).unwrap();
    let tbt = BigUint::from_str_radix(private_key, 16).unwrap() + x2rb;
    let tb = tbt % BigUint::from_str_radix(ECC_N, 16).unwrap();
    assert_eq!(pubkey_valid(r_public_key), true);
    let x1hat = kexhat(BigUint::from_str_radix(&r_public_key[0..64], 16).unwrap());
    let kx1y1 = kg(x1hat, &r_public_key);
    let vxyt = add_point(pubkey2point(public_key), kx1y1);
    let vxyt = convert_jacb_to_nor(vxyt);
    let vxyt = format_hex!(vxyt.x, vxyt.y);
    let vxy = kg(tb, &vxyt);
    let vx = vxy.x;
    let vy = vxy.y;
    let pza = if is_a {
        pk_from_sk(private_key)
    } else {
        public_key.to_string()
    };
    let za = zab(&pza, ida);
    assert_eq!(vx == BigUint::zero() || vy == BigUint::zero(), false);
    let pzb = if !is_a {
        pk_from_sk(private_key)
    } else {
        public_key.to_string()
    };
    let zb = zab(&pzb, idb);
    let z = concvec!(
        &vx.to_bytes_be(), 
        &vy.to_bytes_be(), 
        &hex::decode(&za).unwrap(), 
        &hex::decode(&zb).unwrap()
    );
    let z = hex::encode(&z).into_bytes();
    let h1 = if !is_a {
        concvec!(
            &BigUint::to_bytes_be(&vx), 
            &za.into_bytes(), 
            &zb.into_bytes(), 
            &BigUint::to_bytes_be(&BigUint::from_str_radix(&pk_from_sk(&r_private_key)[0..64], 16).unwrap()), 
            &BigUint::to_bytes_be(&BigUint::from_str_radix(&pk_from_sk(&r_private_key)[64..], 16).unwrap()), 
            &BigUint::to_bytes_be(&BigUint::from_str_radix(&r_public_key[0..64], 16).unwrap()), 
            &BigUint::to_bytes_be(&BigUint::from_str_radix(&r_public_key[64..], 16).unwrap())
        )
    } else {
        concvec!(
            &BigUint::to_bytes_be(&vx), 
            &za.into_bytes(), 
            &zb.into_bytes(), 
            &BigUint::to_bytes_be(&BigUint::from_str_radix(&r_public_key[0..64], 16).unwrap()), 
            &BigUint::to_bytes_be(&BigUint::from_str_radix(&r_public_key[64..], 16).unwrap()), 
            &BigUint::to_bytes_be(&BigUint::from_str_radix(&pk_from_sk(&r_private_key)[0..64], 16).unwrap()), 
            &BigUint::to_bytes_be(&BigUint::from_str_radix(&pk_from_sk(&r_private_key)[64..], 16).unwrap())
        )
    };
    let hash = sm3_hash(&h1);
    let h2 = concvec!(
        &hex::decode("02").unwrap(), 
        &BigUint::to_bytes_be(&vy), 
        &hex::decode(&hash).unwrap()
    );
    let s1 = sm3_hash(&h2);
    let h3 = concvec!(
        &hex::decode("03").unwrap(), 
        &BigUint::to_bytes_be(&vy), 
        &hex::decode(&hash).unwrap()
    );
    let s2 = sm3_hash(&h3);
    KeyExchangeResult {
        k: hex::encode(kdf(&z, klen)),
        s12: yasna::construct_der(|writer| {
            writer.write_sequence(|writer| {
                writer.next().write_bytes(&s1.into_bytes());
                writer.next().write_bytes(&s2.into_bytes());
            });
        })
    }
}

fn keyexchange_a(klen: usize, ida: &[u8], idb: &[u8], private_key_a: &str, public_key_b: &str, private_key_ar: &str, public_key_br: &str) -> KeyExchangeResult {
    keyexchange_raw(klen, ida, idb, private_key_a, public_key_b, private_key_ar, public_key_br, true)
}

fn keyexchange_b(klen: usize, idb: &[u8], ida: &[u8], private_key_b: &str, public_key_a: &str, private_key_br: &str, public_key_ar: &str) -> KeyExchangeResult {
    keyexchange_raw(klen, ida, idb, private_key_b, public_key_a, private_key_br, public_key_ar, false)
}

fn keyexchange_1ab(klen: usize, id: &[u8], private_key: &str) -> (Vec<u8>, String) {
    let public_key = pk_from_sk(private_key);
    let (private_key_r, public_key_r) = gen_keypair();
    (
        yasna::construct_der(|writer| {
            writer.write_sequence(|writer| {
                writer.next().write_u32(klen as u32);
                writer.next().write_bytes(id);
                writer.next().write_bytes(&public_key.into_bytes());
                writer.next().write_bytes(&public_key_r.into_bytes());
            });
        }),
        private_key_r
    )
}

fn keyexchange_2a(id: &[u8], private_key: &str, private_key_r: &str, recive_bytes: &[u8]) -> KeyExchangeResult {
    let klenidbpkpkr = yasna::parse_der(recive_bytes, |reader| {
        reader.read_sequence(|reader| {
            let klen = reader.next().read_u32()?;
            let idb = reader.next().read_bytes()?;
            let public_key = reader.next().read_bytes()?;
            let public_key_r = reader.next().read_bytes()?;
            return Ok((klen, idb, public_key, public_key_r));
        })
    });
    let klen: u32;
    let idb: Vec<u8>;
    let public_key: Vec<u8>;
    let public_key_r: Vec<u8>;
    match klenidbpkpkr {
        Ok(v) => {
            klen = v.0;
            idb = v.1;
            public_key = v.2;
            public_key_r = v.3;
        }
        Err(_) => {
            return KeyExchangeResult {
                k: "".to_string(),
                s12: vec![],
            };
        }
    }
    let klen = klen as usize;
    let public_key = std::str::from_utf8(&public_key).unwrap();
    let public_key_r = std::str::from_utf8(&public_key_r).unwrap();
    keyexchange_a(klen, id, &idb, private_key, public_key, private_key_r, public_key_r)
}

fn keyexchange_2b(id: &[u8], private_key: &str, private_key_r: &str, recive_bytes: &[u8]) -> KeyExchangeResult {
    let klenidapkpkr = yasna::parse_der(recive_bytes, |reader| {
        reader.read_sequence(|reader| {
            let klen = reader.next().read_u32()?;
            let idb = reader.next().read_bytes()?;
            let public_key = reader.next().read_bytes()?;
            let public_key_r = reader.next().read_bytes()?;
            return Ok((klen, idb, public_key, public_key_r));
        })
    });
    let klen: u32;
    let ida: Vec<u8>;
    let public_key: Vec<u8>;
    let public_key_r: Vec<u8>;
    match klenidapkpkr {
        Ok(v) => {
            klen = v.0;
            ida = v.1;
            public_key = v.2;
            public_key_r = v.3;
        }
        Err(_) => {
            return KeyExchangeResult {
                k: "".to_string(),
                s12: vec![],
            };
        }
    }
    let klen = klen as usize;
    let public_key = std::str::from_utf8(&public_key).unwrap();
    let public_key_r = std::str::from_utf8(&public_key_r).unwrap();
    keyexchange_b(klen, id, &ida, private_key, public_key, private_key_r, public_key_r)
}

pub struct Sign<'a> {
    pub id: &'a [u8],
    pub private_key: &'a str
}

impl<'a> Default for Sign<'a> {
    fn default() -> Self {
        Sign {id: b"1234567812345678", private_key: ""}
    }
}

impl<'a> Sign<'a> {
    /// Initialize a sm2 sign instance with default id b"1234567812345678".
    pub fn new(private_key: &'a str) -> Self {
        Sign {private_key: private_key, ..Sign::default()}
    }

    /// Initialize a sm2 sign instance with a custom id.
    pub fn new_with_id(id: &'a [u8], private_key: &'a str) -> Self {
        Sign {id: id, private_key: private_key}
    }

    /// Sign with sm3.
    pub fn sign(&self, data: &[u8]) -> Vec<u8> {
        sign(self.id, data, self.private_key)
    }

    /// Sign without sm3.
    pub fn sign_raw(&self, data: &[u8]) -> Vec<u8> {
        sign_raw(data, self.private_key)
    }

    pub fn sign_to_file(&self, data: &[u8], sign_file: &str) {
        sign_to_file(self.id, data, sign_file, self.private_key)
    }
}

pub struct Verify<'a> {
    pub id: &'a [u8],
    pub public_key: Cow<'a, str>
}

impl<'a> Default for Verify<'a> {
    fn default() -> Self {
        Verify {id: b"1234567812345678", public_key: Cow::Borrowed("")}
    }
}

impl<'a> Verify<'a> {
    /// Initialize a sm2 verify instance with default id b"1234567812345678".
    pub fn new(public_key: &'a str) -> Self {
        let public_key = pubkey_trim(public_key);
        Verify{public_key: public_key, ..Verify::default()}
    }

    /// Initialize a sm2 verify instance with a custom id.
    pub fn new_with_id(id: &'a [u8], public_key: &'a str) -> Self {
        Verify {id: id, public_key: Cow::Borrowed(public_key)}
    }

    /// Verify with sm3.
    pub fn verify(&self, data: &[u8], sign: &[u8]) -> bool {
        verify(self.id, data, sign, &self.public_key)
    }

    /// Verify without sm3.
    pub fn verify_raw(&self, data: &[u8], sign: &[u8]) -> bool {
        verify_raw(data, sign, &self.public_key)
    }

    pub fn verify_from_file(&self, data: &[u8], sign_file: &str) -> bool {
        verify_from_file(self.id, data, sign_file, &self.public_key)
    }
}

pub struct Encrypt<'a> {
    pub public_key: Cow<'a, str>
}

impl<'a> Encrypt<'a> {
    pub fn new(public_key: &'a str) -> Self {
        let public_key = pubkey_trim(public_key);
        Encrypt{public_key: public_key}
    }

    pub fn encrypt(&self, data: &[u8]) -> Vec<u8> {
        encrypt(data, &self.public_key)
    }

    pub fn encrypt_c1c2c3(&self, data: &[u8]) -> Vec<u8> {
        encrypt_c1c2c3(data, &self.public_key)
    }

    pub fn encrypt_asna1(&self, data: &[u8]) -> Vec<u8> {
        encrypt_asna1(data, &self.public_key)
    }

    pub fn encrypt_hex(&self, data: &[u8]) -> String {
        encrypt_hex(data, &self.public_key)
    }

    pub fn encrypt_base64(&self, data: &[u8]) -> String {
        encrypt_base64(data, &self.public_key)
    }

    pub fn encrypt_to_file(&self, data: &[u8], enc_file: &str) {
        encrypt_to_file(data, enc_file, &self.public_key)
    }
}

pub struct Decrypt<'a> {
    pub private_key: &'a str
}

impl<'a> Decrypt<'a> {
    pub fn new(private_key: &'a str) -> Self {
        Decrypt{private_key: private_key}
    }

    pub fn decrypt(&self, data: &[u8]) -> Vec<u8> {
        decrypt(data, self.private_key)
    }

    pub fn decrypt_c1c2c3(&self, data: &[u8]) -> Vec<u8> {
        decrypt_c1c2c3(data, self.private_key)
    }

    pub fn decrypt_asna1(&self, data: &[u8]) -> Vec<u8> {
        decrypt_asna1(data, self.private_key)
    }

    pub fn decrypt_hex(&self, data: &str) -> Vec<u8> {
        decrypt_hex(data, self.private_key)
    }

    pub fn decrypt_base64(&self, data: &str) -> Vec<u8> {
        decrypt_base64(data, self.private_key)
    }

    pub fn decrypt_from_file(&self, enc_file: &str) -> Vec<u8> {
        decrypt_from_file(enc_file, self.private_key)
    }
}

pub struct KeyExchange<'a> {
    pub id: &'a [u8],
    pub private_key: &'a str
}

impl<'a> KeyExchange<'a> {
    pub fn new(id: &'a [u8], private_key: &'a str) -> Self {
        KeyExchange{id: id, private_key: private_key}
    }

    /// klen is the length of key to generate.
    pub fn keyexchange_1ab(&self, klen: usize) -> (Vec<u8>, String) {
        keyexchange_1ab(klen, self.id, self.private_key)
    }

    pub fn keyexchange_2a(&self, private_key_r: &str, recive_bytes: &[u8]) -> KeyExchangeResult {
        keyexchange_2a(self.id, self.private_key, private_key_r, recive_bytes)
    }

    pub fn keyexchange_2b(&self, private_key_r: &str, recive_bytes: &[u8]) -> KeyExchangeResult {
        keyexchange_2b(self.id, self.private_key, private_key_r, recive_bytes)
    }
}
~~~

##### sm3.rs

~~~  rust
use std::vec;

fn sm3_ff_j(x: u32, y: u32, z: u32, j: u32) -> u32 {
    let mut ret = 0;
    if j < 16 {
        ret = x ^ y ^ z;
    } else if 16 <= j && j < 64 {
        ret = (x & y) | (x & z) | (y & z);
    }
    ret
}

fn sm3_gg_j(x: u32, y: u32, z: u32, j: u32) -> u32 {
    let mut ret = 0;
    if j < 16 {
        ret = x ^ y ^ z;
    } else if 16 <= j && j < 64 {
        ret = (x & y) | (!x & z)
    }
    ret
}

fn sm3_p_0(x: u32) -> u32 {
    x ^ x.rotate_left(9) ^ x.rotate_left(17)
}

fn sm3_p_1(x: u32) -> u32 {
    x ^ x.rotate_left(15) ^ x.rotate_left(23)
}

fn sm3_cf(v_i: &Vec<u32>, b_i: &Vec<u32>) -> Vec<u32> {
    let t_j: Vec<u32> = vec![
        2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169,
        2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169,
        2043430169, 2043430169, 2043430169, 2043430169, 2055708042, 2055708042,
        2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042,
        2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042,
        2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042,
        2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042,
        2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042,
        2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042,
        2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042,
        2055708042, 2055708042, 2055708042, 2055708042
    ];
    let mut w: Vec<u32> = Vec::with_capacity(68);
    for i in 0..16 {
        let mut weight = 0x1000000;
        let mut data: u32 = 0;
        for k in (i * 4)..((i + 1) * 4) {
            data = data.wrapping_add(b_i[k] * weight);
            weight /= 0x100;
        }
        w.push(data);
    }
    for j in 16..68 {
        w.push(sm3_p_1(w[j - 16] ^ w[j - 9] ^ w[j - 3].rotate_left(15)) ^ w[j - 13].rotate_left(7) ^ w[j - 6]);
    }
    let mut w_1: Vec<u32> = Vec::with_capacity(64);
    for j in 0..64 {
        w_1.push( w[j] ^ w[j + 4]);
    }
    let mut a = v_i[0];
    let mut b = v_i[1];
    let mut c = v_i[2];
    let mut d = v_i[3];
    let mut e = v_i[4];
    let mut f = v_i[5];
    let mut g = v_i[6];
    let mut h = v_i[7];
    for j in 0..64 {
        let ss_1 = ((a.rotate_left(12).wrapping_add(e).wrapping_add(t_j[j].rotate_left(j as u32))) & 0xffffffff).rotate_left(7);
        let ss_2 = ss_1 ^ a.rotate_left(12);
        let tt_1 = (sm3_ff_j(a, b, c, j as u32).wrapping_add(d).wrapping_add(ss_2).wrapping_add(w_1[j])) & 0xffffffff;
        let tt_2 = (sm3_gg_j(e, f, g, j as u32).wrapping_add(h).wrapping_add(ss_1).wrapping_add(w[j])) & 0xffffffff;
        d = c;
        c = b.rotate_left(9);
        b = a;
        a = tt_1;
        h = g;
        g = f.rotate_left(19);
        f = e;
        e = sm3_p_0(tt_2);
        a = a & 0xFFFFFFFF;
        b = b & 0xFFFFFFFF;
        c = c & 0xFFFFFFFF;
        d = d & 0xFFFFFFFF;
        e = e & 0xFFFFFFFF;
        f = f & 0xFFFFFFFF;
        g = g & 0xFFFFFFFF;
        h = h & 0xFFFFFFFF;
    }
    let mut cf: Vec<u32> = Vec::with_capacity(8);
    let v_j: Vec<u32> = vec![a, b, c, d, e, f, g, h];
    for i in 0..8 {
        cf.push(v_j[i] ^ v_i[i]);
    }
    cf
}

pub fn sm3_hash_raw(msg: &[u8]) -> Vec<u8> {
    let iv: Vec<u32> = vec![
        1937774191, 1226093241, 388252375, 3666478592,
        2842636476, 372324522, 3817729613, 2969243214,
    ];
    let len = msg.len();
    let reserve = len % 64 + 1;
    let len_pad = match reserve > 56 {
        true => len + 130 - reserve,
        false => len + 66 - reserve
    };
    let range_end = match reserve > 56 {
        true => 120,
        false => 56
    };
    let mut msg_pad: Vec<u8> = Vec::with_capacity(len_pad);
    msg_pad.extend_from_slice(msg);
    msg_pad.push(0x80);
    for _ in reserve..range_end {
        msg_pad.push(0x00);
    }
    let mut bit_length: usize = len * 8;
    let mut bit_length_str: Vec<usize> = Vec::with_capacity(8);
    bit_length_str.push(bit_length % 0x100);
    for _ in 0..7 {
        bit_length /= 0x100;
        bit_length_str.push(bit_length % 0x100);
    }
    for i in 0..8 {
        msg_pad.push(bit_length_str[7 - i] as u8);
    }
    let group_count: usize = len_pad / 64;
    let mut b: Vec<Vec<u32>> = Vec::with_capacity(group_count);
    for _ in 0..group_count {
        b.push(Vec::with_capacity(64));
    }
    for i in 0..group_count {
        b[i] = msg_pad[(i * 64)..((i + 1) * 64)].iter().map(|x| x.to_be() as u32).collect();
    }
    let mut v: Vec<Vec<u32>> = Vec::with_capacity(group_count + 1);
    for _ in 0..(group_count + 1) {
        v.push(Vec::with_capacity(8));
    }
    v[0] = iv;
    for i in 0..group_count {
        v[i + 1] = sm3_cf(&v[i], &b[i]);
    }
    let y = &v[group_count];
    y.into_iter().flat_map(|x| x.to_be_bytes()).collect()
}

pub fn sm3_hash(msg: &[u8]) -> String {
    let hash = sm3_hash_raw(msg);
    hash.iter().map(|x| format!("{:02x}", x)).collect()
}

pub fn sm3_hash_file(input_file: &str) -> String {
    let input_file = std::path::Path::new(input_file);
    let input_data = std::fs::read(input_file).unwrap();
    sm3_hash(&input_data)
}

pub fn sm3_hash_string(msg_str: &str) -> String {
    let msg = msg_str.as_bytes();
    sm3_hash(msg)
}
~~~

##### lib.rs

~~~ rust
pub mod sm3;
pub mod sm2;
~~~

##### main.rs

~~~ rust
mod sm3;
mod sm2;

fn main() {
    let (sk, pk) = sm2::gen_keypair(); // 生成密钥对
    let enc_ctx = sm2::Encrypt::new(&pk); // 使用公钥创建加密上下文
    let enc = enc_ctx.encrypt(b"abc"); // 加密数据
    let dec_ctx = sm2::Decrypt::new(&sk); // 使用私钥创建解密上下文
    let dec = dec_ctx.decrypt(&enc); // 解密数据
    assert_eq!(String::from_utf8(dec).unwrap(), "abc"); // 断言解密后的数据与原文
    let (sk, pk) = sm2::gen_keypair(); // 生成密钥对
    let sign_ctx = sm2::Sign::new(&sk); // 使用私钥创建签名上下文
    let sign = sign_ctx.sign(b"abc"); // 签名数据
    let verify_ctx = sm2::Verify::new(&pk); // 使用公钥创建验证上下文
    let verify = verify_ctx.verify(b"abc", &sign); // 验证签名
    assert_eq!(verify, true); // 断言签名验证成功
    // 第一步：双方生成密钥对和临时密钥对
    let ida = b"id_a@company.com";
    let (ska, _) = sm2::gen_keypair();
    let keyexchange_a = sm2::KeyExchange::new(ida, &ska);
    let (a2b, rska) = keyexchange_a.keyexchange_1ab(16);

    let idb = b"id_b@company.com";
    let (skb, _) = sm2::gen_keypair();
    let keyexchange_b = sm2::KeyExchange::new(idb, &skb);
    let (b2a, rskb) = keyexchange_b.keyexchange_1ab(16);

// 第二步：双方使用对方的临时公钥和自己的临时私钥计算共享密钥
    let ka = keyexchange_a.keyexchange_2a(&rska, &b2a);
    let kb = keyexchange_b.keyexchange_2b(&rskb, &a2b);

// 第三步：验证共享密钥是否一致
    assert_eq!(ka.k, kb.k); // 断言共享密钥相同
    assert_eq!(ka.s12, kb.s12); // 断言其他交换信息一致
    println!("ALL IS OK!!!");
}
~~~

#### 运行结果

~~~ shell
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.03s
     Running `target\debug\sm2.exe`
ALL IS OK!!!
~~~

### 实验记录中提交 gitee 课程项目链接，提交本次实验相关 git log运行结果

~~~ shell
commit e63f37e23ae01e1c97f36072ccb73ed9e5e3dc36 (HEAD -> master)
Author: zhanhe <he-zhan@outlook.com>
Date:   Sun Oct 27 17:41:31 2024 +0800

    sm2

commit b8e310bdbcff84527f0a0b760859d27a73844a22
Author: zhanhe <he-zhan@outlook.com>
Date:   Sun Oct 27 10:34:29 2024 +0800

    sm4

commit 5d4b1c5aeb213512cec8c7f3673d41ccd0cc3af4
Author: zhanhe <he-zhan@outlook.com>
Date:   Sun Oct 27 10:24:15 2024 +0800

    sm3

commit 7d4842f01cf857ee68282430cc95ed16afd9d49c
Author: zhanhe <he-zhan@outlook.com>
Date:   Sun Oct 27 10:22:12 2024 +0800

    sm3
~~~

### 提交要求：

- 提交实践过程Markdown和转化的PDF文件
- 代码，文档托管到gitee或github等，推荐 gitclone 
- 记录实验过程中遇到的问题，解决过程，反思等内容，完成实验报告相关内容

### 参考链接

[个人仓库]([1006487432.github.io/content/src at master · 1006487432/1006487432.github.io](https://github.com/1006487432/1006487432.github.io/tree/master/content/src));

[lookingforfyf/SMX_Test: 基于MIRACL（C语言密码库）的国密SM2签名验签以及加解密、SM3的加解密、SM4的加解密算法](https://github.com/lookingforfyf/SMX_Test/tree/master)
