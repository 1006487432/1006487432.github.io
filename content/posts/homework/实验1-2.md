---
title: 实验1-2
subtitle:
date: 2024-10-20T10:11:56+08:00
draft: false
author:
  name: 瞻鹤
  link:
  email: he-zhan@outlook.com
  avatar: /images/avatar.jpg
description:
keywords:
license:
comment: false
weight: 0
tags:
  - 
categories:
  - homework
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRss: false
hiddenFromRelated: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
password:
message:
repost:
  enable: true
  url:

# See details front matter: https://fixit.lruihao.cn/documentation/content-management/introduction/#front-matter
---

<!--more-->	

# 《密码系统设计》实验

## 实验项目
| 实验序号 | 实验名称       | 实验学时数 | 实验目的                    | 实验内容                              | 实验类型 | 学生学习预期成果                                             |
| -------- | -------------- | ---------- | --------------------------- | :------------------------------------ | -------- | ------------------------------------------------------------ |
| 实验一   | 嵌入式开发基础 | 6          | 掌握Linux系统使用与开发方法 | Linux命令，OpenSSL（GmSSL）命令与开发 | 验证性   | 1.掌握常见的Linux命令与C语言开发方法；<br>2.掌握OpenSSL（GmSSL）的基本用法与开发；<br>3.掌握常见商用密码算法的使用 |

### 参考相关内容，在 Ubuntu或openEuler中（推荐 openEuler）中使⽤OpenSSL库编程实现调⽤SM2（加密解密，签名验签），SM3（摘要计算，HMAC 计算），SM4（加密解密）算法，使⽤Markdown记录详细记录实践过程，每完成⼀项git commit ⼀次。（5'）

#### SM2

##### 代码

~~~ c
#include <openssl/ec.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
// 从PEM文件中读取私钥
EVP_PKEY *load_private_key(const char *filename) {
    FILE *fp = fopen(filename, "r");
    if (!fp) {
        perror("Unable to open file");
        return NULL;
    }
    EVP_PKEY *private_key = PEM_read_PrivateKey(fp, NULL, NULL, NULL);
    if (!private_key) {
        ERR_print_errors_fp(stderr);
    }
    fclose(fp);
    return private_key;
}

EVP_PKEY* load_public_key(const char* filename) {
    EVP_PKEY *key = NULL;
    BIO *bio = BIO_new(BIO_s_file());
    if (!bio) {
        fprintf(stderr, "Unable to create file BIO\n");
        return NULL;
    }

    BIO_read_filename(bio, filename);
    key = PEM_read_bio_PUBKEY(bio, NULL, 0, NULL);
    BIO_free(bio);

    if (!key) {
        fprintf(stderr, "Unable to load public key\n");
    }
    return key;
}
int read_file(const unsigned char *input_file, unsigned char ** text, size_t* len){
    FILE* fp_in = fopen(input_file, "rb");
    if (!fp_in) {
        perror("Error opening input file");
        return 1;
    }
    // 获取文件大小并分配内存
    fseek(fp_in, 0, SEEK_END);
    *len = ftell(fp_in);
    fseek(fp_in, 0, SEEK_SET);
    *text = malloc(*len);
    if (!*text) {
        perror("Memory allocation failed");
        return 0;
    }
    fread(*text, 1, *len, fp_in);
    fclose(fp_in);
    return 0;
}
int sm2_encrypt(const unsigned char *input_file,EVP_PKEY *pub_key,unsigned char **ciphertext, size_t *ciphertext_len) {
    EVP_PKEY_CTX *pctx = NULL;
    int ret = 0;
    // Check for a valid public key
    if (!pub_key) {
        fprintf(stderr, "Invalid public key.\n");
        return 0;
    }
    // Create a public key context
    pctx = EVP_PKEY_CTX_new(pub_key, NULL);
    if (!pctx) {
        fprintf(stderr, "Unable to create EVP_PKEY_CTX.\n");
        ERR_print_errors_fp(stderr);
        return 0;
    }
    unsigned char* buf = NULL;
    size_t buf_len = 0;
    if(read_file(input_file, &buf, &buf_len)){
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    }
    // Initialize the encryption operation
    if (EVP_PKEY_encrypt_init(pctx) <= 0) {
        fprintf(stderr, "Encryption initialization failed.\n");
        ERR_print_errors_fp(stderr);
        goto cleanup;
    }
    // Determine the length of the ciphertext
    if (EVP_PKEY_encrypt(pctx, NULL, ciphertext_len, buf, buf_len) <= 0) {
        fprintf(stderr, "Failed to determine ciphertext length.\n");
        ERR_print_errors_fp(stderr);
        goto cleanup;
    }
    // Allocate memory for the ciphertext
    *ciphertext = OPENSSL_malloc(*ciphertext_len);
    if (!*ciphertext) {
        fprintf(stderr, "Unable to allocate memory for ciphertext.\n");
        goto cleanup;
    }
    // Perform the encryption
    if (EVP_PKEY_encrypt(pctx, *ciphertext, ciphertext_len, buf, buf_len) <= 0) {
        fprintf(stderr, "Encryption failed.\n");
        ERR_print_errors_fp(stderr);
        goto cleanup;
    }
    ret = 1; // Success
    free(buf);
    buf = NULL;
cleanup:
    if (!ret && *ciphertext) {
        OPENSSL_free(*ciphertext);
        *ciphertext = NULL;
        *ciphertext_len = 0;
    }
    if (pctx) {
        EVP_PKEY_CTX_free(pctx);
    }
    return ret;
}
int sm2_decrypt(const unsigned char *input_file,EVP_PKEY *priv_pkey,unsigned char **plaintext, size_t *plaintext_len) {
    EVP_PKEY_CTX *pctx = NULL;
    int ret = 0;

    if (!priv_pkey) {
        fprintf(stderr, "Invalid pri key. \n");
        return 0;
    }
    unsigned char* buf = NULL;
    size_t buf_len = 0;
    if(read_file(input_file, &buf, &buf_len)){
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    }
    // Create a private key context
    pctx = EVP_PKEY_CTX_new(priv_pkey, NULL);
    if (!pctx) {
        fprintf(stderr, "Unable to create EVP_PKEY_CTX.\n");
        ERR_print_errors_fp(stderr);
        goto cleanup;
    }

    // Initialize the decryption operation
    if (EVP_PKEY_decrypt_init(pctx) <= 0) {
        fprintf(stderr, "Decryption initialization failed.\n");
        ERR_print_errors_fp(stderr);
        goto cleanup;
    }

    // Determine the length of the plaintext
    if (EVP_PKEY_decrypt(pctx, NULL, plaintext_len, buf, buf_len) <= 0) {
        fprintf(stderr, "Failed to determine plaintext length.\n");
        ERR_print_errors_fp(stderr);
        goto cleanup;
    }

    // Allocate memory for the plaintext
    *plaintext = OPENSSL_malloc(*plaintext_len);
    if (!*plaintext) {
        fprintf(stderr, "Unable to allocate memory for plaintext.\n");
        goto cleanup;
    }

    // Perform the decryption
    if (EVP_PKEY_decrypt(pctx, *plaintext, plaintext_len, buf, buf_len) <= 0) {
        fprintf(stderr, "Decryption failed.\n");
        ERR_print_errors_fp(stderr);
        goto cleanup;
    }
    printf("plaintext:%s", *plaintext);
    ret = 1; // Success
cleanup:
    if (!ret && *plaintext) {
        OPENSSL_free(*plaintext);
        *plaintext = NULL;
        *plaintext_len = 0;
    }
    if (pctx) {
        EVP_PKEY_CTX_free(pctx);
    }
    return ret;
}
int generate_sm2_key(const char *priv_key_file, const char *pub_key_file) {
    EC_KEY *ec_key = NULL;
    EVP_PKEY *pkey = NULL;
    FILE *priv_fp = NULL;
    FILE *pub_fp = NULL;
    int ret = 1; // 1表示失败

    // 创建基于SM2的椭圆曲线密钥
    ec_key = EC_KEY_new_by_curve_name(NID_sm2);
    if (!ec_key) {
        ERR_print_errors_fp(stderr);
        return ret;
    }

    // 生成SM2密钥对
    if (!EC_KEY_generate_key(ec_key)) {
        fprintf(stderr, "Failed to generate SM2 key\n");
        ERR_print_errors_fp(stderr);
        goto cleanup;
    }

    // 将EC_KEY转换为EVP_PKEY
    pkey = EVP_PKEY_new();
    if (!pkey || !EVP_PKEY_assign_EC_KEY(pkey, ec_key)) {
        fprintf(stderr, "Failed to assign EC_KEY to EVP_PKEY\n");
        ERR_print_errors_fp(stderr);
        goto cleanup;
    }
    ec_key = NULL; // EVP_PKEY 已经接管了ec_key的内存管理

    // 保存私钥到文件
    priv_fp = fopen(priv_key_file, "wb");
    if (!priv_fp || !PEM_write_PrivateKey(priv_fp, pkey, NULL, NULL, 0, NULL, NULL)) {
        fprintf(stderr, "Failed to write private key\n");
        ERR_print_errors_fp(stderr);
        goto cleanup;
    }

    // 保存公钥到文件
    pub_fp = fopen(pub_key_file, "wb");
    if (!pub_fp || !PEM_write_PUBKEY(pub_fp, pkey)) {
        fprintf(stderr, "Failed to write public key\n");
        ERR_print_errors_fp(stderr);
        goto cleanup;
    }

    printf("SM2 key pair generated and saved successfully.\n");
    ret = 0; // 成功

cleanup:
    if (pkey) EVP_PKEY_free(pkey);
    if (ec_key) EC_KEY_free(ec_key);
    if (priv_fp) fclose(priv_fp);
    if (pub_fp) fclose(pub_fp);
    return ret;
}
int sm2_sign(const unsigned char *input_file, EVP_PKEY *priv_key, unsigned char **signature, size_t *sig_len) {
    unsigned char *sig = NULL;
    unsigned char *message = NULL;
    size_t len = 0;
    if(read_file(input_file,&message, &len)){
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    }
    int ret = 0;
    // Create a signing context
    EVP_MD_CTX *ctx = EVP_MD_CTX_new();
    if (!ctx) {
        fprintf(stderr, "Failed to create signing context\n");
        goto end;
    }
    // Initialize the signing operation
    if (EVP_DigestSignInit(ctx, NULL, EVP_sm3(), NULL, priv_key) <= 0) {
        fprintf(stderr, "Failed to init signing\n");
        goto end;
    }

    // Update the signing operation with the message
    if (EVP_DigestSignUpdate(ctx, message, len) <= 0) {
        fprintf(stderr, "Failed to update signing\n");
        goto end;
    }
    // Finalize the signing operation
    size_t tmp_sig_len = 0;
    if (EVP_DigestSignFinal(ctx, NULL, &tmp_sig_len) <= 0) {
        fprintf(stderr, "Failed to get signature length\n");
        goto end;
    }
    sig = OPENSSL_malloc(tmp_sig_len);
    if (EVP_DigestSignFinal(ctx, sig, &tmp_sig_len) <= 0) {
        fprintf(stderr, "Failed to sign\n");
        goto end;
    }
    // Assign the signature and length
    *signature = (char *)sig;
    *sig_len = tmp_sig_len;
    ret = 1;
    end:
    if (!ret) {
        ERR_print_errors_fp(stderr);
        OPENSSL_free(sig);
    }
    EVP_MD_CTX_free(ctx);
    return ret;
}
int sm2_verify(const unsigned char *input_file, EVP_PKEY *pub_key, const unsigned char *signature) {
    int ret = 0;
    // Load public key
    unsigned char *message = NULL, *sign = NULL;
    size_t len = 0, sig_len = 0;
    if(read_file(input_file,&message, &len) || read_file(signature, &sign, &sig_len)){
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    }

    // Create a verification context
    EVP_MD_CTX *ctx = EVP_MD_CTX_new();
    if (!ctx) {
        fprintf(stderr, "Failed to create verification context\n");
        goto end;
    }

    // Initialize the verification operation
    if (EVP_DigestVerifyInit(ctx, NULL, EVP_sm3(), NULL, pub_key) <= 0) {
        fprintf(stderr, "Failed to init verification\n");
        goto end;
    }

    // Update the verification operation with the message
    if (EVP_DigestVerifyUpdate(ctx, message, len) <= 0) {
        fprintf(stderr, "Failed to update verification\n");
        goto end;
    }

    // Finalize the verification operation
    if (EVP_DigestVerifyFinal(ctx, (const unsigned char *)sign, sig_len) <= 0) {
        fprintf(stderr, "Failed to verify\n");
        goto end;
    }

    ret = 1;

    end:
    if (!ret) {
        ERR_print_errors_fp(stderr);
    }
    EVP_MD_CTX_free(ctx);
    return ret;
}
void usage(){
    printf("usage: -key\n");
    printf("       -e -kfile -file\n");
    printf("       -d -kfile -file\n");
    printf("       -s -kfile -file\n");
    printf("       -v -kfile -file -sig\n");
}
int check(char * argv[]){
    if(strcmp(argv[4], "-file") != 0){
        usage();
        return 1;
    }
    if (argv[5] == NULL || argv[5][0] == '\0') {
        fprintf(stderr, "No file provided\n");
        return 1;
    }
    return 0;
}
int main(int argc, char * argv[]){
    if(argc == 1){
        usage();
        return 0;
    }
    if(strcmp(argv[1], "-key") == 0){
        const char *priv_key_file = "sm2_private.pem";
        const char *pub_key_file = "sm2_public.pem";
        generate_sm2_key(priv_key_file,pub_key_file);
    }else if(argc <= 5){
        usage();
    }else if(strcmp(argv[1], "-e") == 0 && strcmp(argv[2], "-kfile") == 0){
        EVP_PKEY *pub_key = load_public_key(argv[3]);
        unsigned char * ciphertext = NULL;
        size_t ciphertextlen = 0;
        if(!pub_key){
            fprintf(stderr, "Failed to load keys\n");
            return 1;
        }
        if(check(argv)){
            EVP_PKEY_free(pub_key);
            return 1;
        }
        if (sm2_encrypt((const unsigned char *)argv[5], pub_key, &ciphertext, &ciphertextlen) == 1) {
            // Print the ciphertext
            printf("SM2 Encryption OK\n");
            const char *output_file = "encrypt.txt";
            FILE* fp_out = fopen(output_file, "wb");
            if (!fp_out) {
                printf("SM2 Save Error\n");
                perror("Error opening output file\n");
                fclose(fp_out);
                return 1;
            }
            fwrite(ciphertext, 1, ciphertextlen, fp_out);
            printf("SM2 Save ok\n");
            fclose(fp_out);
        } else {
            fprintf(stderr, "Encryption failed\n");
             if (ciphertext) {
                OPENSSL_free(ciphertext); // 确保在失败时释放内存
            }
        }
    }else if(strcmp(argv[1], "-d") == 0 && strcmp(argv[2], "-kfile") == 0){
        EVP_PKEY *priv_key = load_private_key(argv[3]);
        unsigned char * plaintext = NULL;
        size_t plaintextlen = 0;
        if(!priv_key){
            fprintf(stderr, "Failed to load keys\n");
            return 1;
        }
        if(check(argv)){
            EVP_PKEY_free(priv_key);
            return 1;
        }
        if (sm2_decrypt((const unsigned char *)argv[5], priv_key, &plaintext, &plaintextlen) == 1) {
            // Print the ciphertext
            printf("SM2 Decryption OK\n");
            const char *output_file = "decrypt.txt";
            FILE* fp_out = fopen(output_file, "wb");
            if (!fp_out) {
                printf("SM2 Save Error\n");
                perror("Error opening output file\n");
                fclose(fp_out);
                return 1;
            }
            fwrite(plaintext, 1, plaintextlen, fp_out);
            printf("SM2 Save ok\n");
            fclose(fp_out);
        } else {
            fprintf(stderr, "Decryption failed\n");
            if (plaintext) {
                OPENSSL_free(plaintext); // 确保在失败时释放内存
            }
        }
    }else if(strcmp(argv[1], "-s") == 0 && strcmp(argv[2], "-kfile") == 0){
        EVP_PKEY *priv_key = load_private_key(argv[3]);
        unsigned char * signtext = NULL;
        size_t signlen = 0;
        if(!priv_key){
            fprintf(stderr, "Failed to load keys\n");
            return 1;
        }
        if(check(argv)){
            EVP_PKEY_free(priv_key);
            return 1;
        }
        if(sm2_sign((const unsigned char *)argv[5], priv_key, &signtext, &signlen) == 1){
            // Print the ciphertext
            printf("SM2 signature OK\n");
            const char *output_file = "signature.sig";
            FILE* fp_out = fopen(output_file, "wb");
            if (!fp_out) {
                printf("SM2 Save Error\n");
                perror("Error opening output file\n");
                fclose(fp_out);
                return 1;
            }
            fwrite(signtext, 1, signlen, fp_out);
            printf("SM2 Save ok\n");
            fclose(fp_out);
        }else{
            fprintf(stderr, "Signature failed\n");
            if (signtext) {
                OPENSSL_free(signtext); // 确保在失败时释放内存
            }
        }
    }
    else if(strcmp(argv[1], "-v") == 0 && strcmp(argv[2], "-kfile") == 0){
        EVP_PKEY *pub_key = load_public_key(argv[3]);
        if(!pub_key){
            fprintf(stderr, "Failed to load keys\n");
            return 1;
        }
        if(check(argv)){
            EVP_PKEY_free(pub_key);
            return 1;
        }
        if(argc <= 6 || strcmp(argv[6], "-sig") != 0){
            usage();
            return 0;
        }
        if (argv[7] == NULL || argv[7][0] == '\0') {
            fprintf(stderr, "No signature provided\n");
            return 1;
        }
        if(sm2_verify((const unsigned char *)argv[5], pub_key, (const unsigned char *)argv[7])){
            printf("Signature verified successfully.\n");
        }else{
            printf("Signature verification failed.\n");
        }
        EVP_PKEY_free(pub_key);
    }else{
        usage();
    }
    return 0;
}

~~~
##### 运行结果

~~~ shell
$ ./sm2-1 -key
SM2 key pair generated and saved successfully.
$ ./sm2-1 -e -kfile sm2_public.pem -file plain.txt 
SM2 Encryption OK
SM2 Save ok
$ ./sm2-1 -d -kfile sm2_private.pem -file encrypt.txt 
plaintext:20221415
SM2 Decryption OK
SM2 Save ok
$ ./sm2-1 -s -kfile sm2_private.pem -file plain.txt
SM2 signature OK
SM2 Save ok
$ ./sm2-1 -v -kfile sm2_public.pem -file plain.txt -sig signature.sig
Signature verified successfully.
~~~

#### SM3
##### Hash代码
~~~ c
#include <openssl/evp.h>
#include <string.h>
void dumpbuf(const unsigned char *buf, int len) {
    for (int i = 0; i < len; i++) {
        printf("%02x", buf[i]);
    }
    printf("\n");
}
int read_file(const unsigned char *input_file, unsigned char ** text, size_t* len){
    FILE* fp_in = fopen(input_file, "rb");
    if (!fp_in) {
        perror("Error opening input file");
        return 1;
    }
    // 获取文件大小并分配内存
    fseek(fp_in, 0, SEEK_END);
    *len = ftell(fp_in);
    fseek(fp_in, 0, SEEK_SET);
    *text = malloc(*len);
    if (!*text) {
        perror("Memory allocation failed");
        return 0;
    }
    fread(*text, 1, *len, fp_in);
    fclose(fp_in);
    return 0;
}
int sm3_hash(const unsigned char *input_file, unsigned char *hash, unsigned int *hash_len)
{
    unsigned char *message = NULL;
    size_t len = 0;
    if(read_file(input_file,&message, &len)){
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    }
    EVP_MD_CTX *md_ctx = NULL;
    const EVP_MD *md = NULL;
    int ret = -1; // 默认返回值为失败
    md_ctx = EVP_MD_CTX_new();
    if (md_ctx == NULL) {
        return ret;
    }
    md = EVP_sm3();
    if (md == NULL) {
        EVP_MD_CTX_free(md_ctx);
        return ret;
    }
    if (EVP_DigestInit_ex(md_ctx, md, NULL) != 1) {
        goto cleanup;
    }
    if (EVP_DigestUpdate(md_ctx, message, len) != 1) {
        goto cleanup;
    }
    if (EVP_DigestFinal_ex(md_ctx, hash, hash_len) != 1) {
        goto cleanup;
    }
    ret = 0; // 成功
    cleanup:
    EVP_MD_CTX_free(md_ctx);
    return ret;
}
int main(int argc, char * argv[]){
    unsigned char hash_value[32]; // SM3 输出 32 字节
    unsigned int hash_len;
    if(argc < 3){
        printf("usage: -in filename\n");
        return 0;
    }
    if(strcmp(argv[1], "-in") != 0){
        printf("usage: -in filename\n");
        return 0;
    }
    int ret = sm3_hash((const unsigned char *)argv[2], hash_value, &hash_len);
    if (ret != 0) {
        fprintf(stderr, "SM3 Hash failed\n");
        return 1;
    }
    printf("SM3 Hash OK\n");
    const char *output_file = "hash.bin";
    FILE* fp_out = fopen(output_file, "wb");
    if (!fp_out) {
        printf("SM3 Save Error\n");
        perror("Error opening output file\n");
        fclose(fp_out);
        return 1;
    }
    dumpbuf(hash_value, hash_len);
    fwrite(hash_value, 1, hash_len, fp_out);
    printf("SM3 Save ok\n");
    fclose(fp_out);
    return 0;
}
~~~
##### 运行结果

~~~ shell
$ ./sm3 -in plain.txt 
SM3 Hash OK
b5c106be3093da5cf09d06c457507f4c2e4487629f36a78295826c9e192571af
SM3 Save ok
~~~

##### SM3-HMAC代码
~~~ c
#include <stdio.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/err.h>
#include <string.h>
#define BLOCK_LENGTH 64
#define L 32 // SM3的输出长度为256位（32字节）
int read_file(const unsigned char *input_file, unsigned char ** text, size_t* len){
    FILE* fp_in = fopen(input_file, "rb");
    if (!fp_in) {
        perror("Error opening input file");
        return 1;
    }
    // 获取文件大小并分配内存
    fseek(fp_in, 0, SEEK_END);
    *len = ftell(fp_in);
    fseek(fp_in, 0, SEEK_SET);
    *text = malloc(*len);
    if (!*text) {
        perror("Memory allocation failed");
        return 0;
    }
    fread(*text, 1, *len, fp_in);
    fclose(fp_in);
    return 0;
}
// 异或操作
void XOR(unsigned char *out, const unsigned char *in1, const unsigned char *in2, size_t len) {
    for (size_t i = 0; i < len; i++) {
        out[i] = in1[i] ^ in2[i];
    }
}

// SM3 HMAC 实现
unsigned char* SM3_HMAC(const unsigned char *key, size_t key_len, const unsigned char *data, size_t data_len, unsigned char *mac, size_t *mac_len) {
    unsigned char key_pad[BLOCK_LENGTH] = {0};
    unsigned char o_key_pad[BLOCK_LENGTH];
    unsigned char inner_hash[L];
    unsigned char final_hash[L];

    // 检查密钥长度并进行处理
    if (key_len > BLOCK_LENGTH) {
        // 如果密钥太长，则对其进行SM3哈希
        EVP_MD_CTX *ctx = EVP_MD_CTX_new();
        if (!ctx) {
            fprintf(stderr, "Unable to create MD context\n");
            return NULL;
        }
        EVP_DigestInit_ex(ctx, EVP_sm3(), NULL);
        EVP_DigestUpdate(ctx, key, key_len);
        unsigned char hashed_key[L];
        EVP_DigestFinal_ex(ctx, hashed_key, NULL);
        memcpy(key_pad, hashed_key, L);
        EVP_MD_CTX_free(ctx);
    } else {
        memcpy(key_pad, key, key_len);
    }

    // 初始化内层和外层哈希的密钥
    memset(o_key_pad, 0x5c, BLOCK_LENGTH);
    memset(key_pad, 0x36, BLOCK_LENGTH);
    XOR(o_key_pad, o_key_pad, key_pad, BLOCK_LENGTH);

    // 计算内层哈希
    EVP_MD_CTX *inner_ctx = EVP_MD_CTX_new();
    if (!inner_ctx) {
        fprintf(stderr, "Unable to create MD context\n");
        return NULL;
    }
    EVP_DigestInit_ex(inner_ctx, EVP_sm3(), NULL);
    EVP_DigestUpdate(inner_ctx, key_pad, BLOCK_LENGTH);
    EVP_DigestUpdate(inner_ctx, data, data_len);
    EVP_DigestFinal_ex(inner_ctx, inner_hash, NULL);
    EVP_MD_CTX_free(inner_ctx);

    // 计算外层哈希
    EVP_MD_CTX *outer_ctx = EVP_MD_CTX_new();
    if (!outer_ctx) {
        fprintf(stderr, "Unable to create MD context\n");
        return NULL;
    }
    EVP_DigestInit_ex(outer_ctx, EVP_sm3(), NULL);
    EVP_DigestUpdate(outer_ctx, o_key_pad, BLOCK_LENGTH);
    EVP_DigestUpdate(outer_ctx, inner_hash, L);
    EVP_DigestFinal_ex(outer_ctx, final_hash, NULL);
    EVP_MD_CTX_free(outer_ctx);
    // 设置最终的MAC值
    memcpy(mac, final_hash, L);
    *mac_len = L;
    return mac;
}

int main(int argc, char * argv[]) {
    if(argc < 5){
        printf("usage: -kfile -file");
        return 0;
    }
    if(strcmp(argv[1], "-kfile") == 0 && strcmp(argv[3], "-file") == 0){
        unsigned char *key, *data;
        unsigned char mac[L];
        size_t mac_len, key_len, data_len;
        if(read_file((const unsigned char*)argv[2], &key, &key_len) || read_file((const unsigned char *)argv[4], &data, &data_len)){
            fprintf(stderr, "Unable to read file.\n");
            return 0;
        }
        SM3_HMAC(key, key_len, data, data_len, mac, &mac_len);
        printf("HMAC-SM3: ");
        for (size_t i = 0; i < mac_len; i++) {
            printf("%02x", mac[i]);
        }
        printf("\n");

        const char *output_file = "SM3-HMAC.bin";
        FILE* fp_out = fopen(output_file, "wb");
        if (!fp_out) {
            printf("SM3 Save Error\n");
            perror("Error opening output file\n");
            fclose(fp_out);
            return 1;
        }
        fwrite(mac, 1, L, fp_out);
        printf("SM3-HMAC Save ok\n");
        fclose(fp_out);
    }
    return 0;
}
~~~
##### 运行结果

~~~ shell
$ ./sm3-hmac -kfile sm2public_key.pem -file plain.txt 
HMAC-SM3: edb7460ebac2fb855ef31e111502696d9477a427855e258e3e5c0af5500938d1
SM3-HMAC Save ok
~~~

#### SM4
##### 代码
~~~ c
#define _CRT_SECURE_NO_WARNINGS

#include "openssl/evp.h"
#include <string.h>
#include <stdio.h>

#define FAILURE -1
#define SUCCESS 0
int read_file(const unsigned char *input_file, unsigned char ** text, size_t* len){
    FILE* fp_in = fopen(input_file, "rb");
    if (!fp_in) {
        perror("Error opening input file");
        return 1;
    }
    // 获取文件大小并分配内存
    fseek(fp_in, 0, SEEK_END);
    *len = ftell(fp_in);
    fseek(fp_in, 0, SEEK_SET);
    *text = malloc(*len);
    if (!*text) {
        perror("Memory allocation failed");
        return 0;
    }
    fread(*text, 1, *len, fp_in);
    fclose(fp_in);
    return 0;
}
// Function to print hexadecimal data  
void print_hex(const char *title, const unsigned char *data, int len) {
    printf("%s:", title);
    for (int i = 0; i < len; i++) {
        if (i % 16 == 0)
            printf("\n%04X: ", i);
        printf("%02X ", data[i]);
    }
    printf("\n");
}
int do_encrypt(const unsigned char * input_key, const unsigned char * input_iv, const unsigned char * input_message,const EVP_CIPHER *type, const char *ctype)
{
    unsigned char outbuf[1024];
    int outlen, tmplen;
    // SM4 uses a 16-byte (128-bit) key  
    unsigned char *key, *iv, *message;
    size_t key_len, iv_len, message_len;
    if(read_file(input_key, &key, &key_len) || read_file(input_iv, &iv, &iv_len)) {
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    }
    if(key_len != 16 || iv_len != 16) {
        fprintf(stderr, "Error Key or Iv.\n");
        return 0;
    }
    if(read_file(input_message, &message, &message_len)) {
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    }
    // SM4 block size is 16 bytes, so IV should also be 16 bytes
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        printf("Failed to create EVP_CIPHER_CTX\n");
        return FAILURE;
    }

    // Initialize encryption operation  
    if (EVP_EncryptInit_ex(ctx, type, NULL, key, iv) != 1) {
        printf("EVP_EncryptInit_ex failed for %s\n", ctype);
        EVP_CIPHER_CTX_free(ctx);
        return FAILURE;
    }

    // Provide plaintext and get ciphertext  
    if (EVP_EncryptUpdate(ctx, outbuf, &outlen, (unsigned char*)message, message_len) != 1) {
        printf("EVP_EncryptUpdate failed for %s\n", ctype);
        EVP_CIPHER_CTX_free(ctx);
        return FAILURE;
    }

    // Finalize encryption  
    if (EVP_EncryptFinal_ex(ctx, outbuf + outlen, &tmplen) != 1) {
        printf("EVP_EncryptFinal_ex failed for %s\n", ctype);
        EVP_CIPHER_CTX_free(ctx);
        return FAILURE;
    }
    outlen += tmplen;
    // Clean up context  
    EVP_CIPHER_CTX_free(ctx);

    // Write ciphertext to file  
    char filename[64];
    sprintf(filename, "./cipher_%s.dat", ctype);
    FILE *out = fopen(filename, "wb+");
    if (!out) {
        printf("Cannot open file: %s\n", filename);
        return FAILURE;
    }
    fwrite(outbuf, 1, outlen, out);
    fflush(out);
    fclose(out);
    printf("%s encryption successful. Ciphertext length: %d bytes\n", ctype, outlen);
    print_hex("Ciphertext", outbuf, outlen);
    return SUCCESS;
}
int do_decrypt(const unsigned char * input_key, const unsigned char * input_iv, const unsigned char * input_message,const EVP_CIPHER *type, const char *ctype)
{
    unsigned char inbuf[1024] = { 0 };
    unsigned char outbuf[1024] = { 0 };
    int outlen, inlen, tmplen;
    // SM4 uses a 16-byte (128-bit) key  
    unsigned char *key, *iv, *message;
    size_t key_len, iv_len, message_len;
    if(read_file(input_key, &key, &key_len) || read_file(input_iv, &iv, &iv_len)) {
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    }
    if(key_len != 16 || iv_len != 16) {
        fprintf(stderr, "Error Key or Iv.\n");
        return 0;
    }
    if(read_file(input_message, &message, &message_len)) {
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    }
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        printf("Failed to create EVP_CIPHER_CTX\n");
        return FAILURE;
    }

    // Initialize decryption operation  
    if (EVP_DecryptInit_ex(ctx, type, NULL, key, iv) != 1) {
        printf("EVP_DecryptInit_ex failed for %s\n", ctype);
        EVP_CIPHER_CTX_free(ctx);
        return FAILURE;
    }

    // Provide ciphertext and get plaintext  
    if (EVP_DecryptUpdate(ctx, outbuf, &outlen, message, message_len) != 1) {
        printf("EVP_DecryptUpdate failed for %s\n", ctype);
        EVP_CIPHER_CTX_free(ctx);
        return FAILURE;
    }
    // Finalize decryption  
    if (EVP_DecryptFinal_ex(ctx, outbuf + outlen, &tmplen) != 1) {
        printf("EVP_DecryptFinal_ex failed for %s\n", ctype);
        EVP_CIPHER_CTX_free(ctx);
        return FAILURE;
    }
    outlen += tmplen;
    // Clean up context  
    EVP_CIPHER_CTX_free(ctx);
    printf("%s decryption result: \n%.*s\n", ctype, outlen, outbuf);
    print_hex("Decrypted plaintext (hex)", outbuf, outlen);
    return SUCCESS;
}

int main(int argc, char *argv[])
{
    // Initialize OpenSSL algorithms
    OpenSSL_add_all_algorithms();
    // Use SM4-CBC for encryption and decryption
    const EVP_CIPHER *sm4_cbc = EVP_sm4_cbc();
    if (!sm4_cbc) {
        printf("Cannot get SM4-CBC cipher\n");
        return FAILURE;
    }

    if(argc < 8){
        printf("usage: -e/-d -kfile -iv -file");
        return 0;
    }
    if(strcmp(argv[1], "-e") == 0){
        if(strcmp(argv[2], "-kfile") == 0 && strcmp(argv[4], "-iv") == 0 && strcmp(argv[6], "-file") == 0)
            if (do_encrypt((unsigned char*)argv[3], (unsigned char*)argv[5],(unsigned char*)argv[7],sm4_cbc, "sm4-cbc") != SUCCESS) {
                printf("SM4-CBC encryption failed\n");
                EVP_cleanup();
                return FAILURE;
            }
    }else if(strcmp(argv[1], "-d") == 0){
        if(strcmp(argv[2], "-kfile") == 0 && strcmp(argv[4], "-iv") == 0 && strcmp(argv[6], "-file") == 0){
            if (do_decrypt((unsigned char*)argv[3], (unsigned char*)argv[5],(unsigned char*)argv[7],sm4_cbc, "sm4-cbc") != SUCCESS) {
                printf("SM4-CBC decryption failed\n");
                EVP_cleanup();
                return FAILURE;
            }
        }
    }else{
        printf("usage: -e/-d -kfile -iv -file");
        return 0;
    }
    // Clean up OpenSSL algorithms  
    EVP_cleanup();

    return 0;
}
~~~
##### 运行结果

~~~ shell
$ ./sm4 -e -kfile key.bin -iv iv.bin -file plain.txt 
sm4-cbc encryption successful. Ciphertext length: 16 bytes
Ciphertext:
0000: F7 9A 8F C5 65 49 CE 3D 2D 63 63 C4 CC BE C5 A5
$ ./sm4 -d -kfile key.bin -iv iv.bin -file cipher_sm4-cbc.dat 
sm4-cbc decryption result:
20221415
Decrypted plaintext (hex):
0000: 32 30 32 32 31 34 31 35 0A
~~~


### 参考相关内容，在 Ubuntu或openEuler中（推荐 openEuler）中使⽤GmSSL库编程实现调⽤SM2（加密解密，签名验签），SM3（摘要计算，HMAC 计算），SM4（加密解密）算法，使⽤Markdown记录详细记录实践过程，每完成⼀项git commit ⼀次。（5'）
#### SM2
##### 代码
~~~ c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <gmssl/sm2.h>
#include <gmssl/sm3.h>
#include <gmssl/error.h>
int read_file(const unsigned char *input_file, unsigned char ** text, size_t* len){
    FILE* fp_in = fopen(input_file, "rb");
    if (!fp_in) {
        perror("Error opening input file");
        return 1;
    }
    // 获取文件大小并分配内存
    fseek(fp_in, 0, SEEK_END);
    *len = ftell(fp_in);
    fseek(fp_in, 0, SEEK_SET);
    *text = malloc(*len);
    if (!*text) {
        perror("Memory allocation failed");
        return 0;
    }
    fread(*text, 1, *len, fp_in);
    fclose(fp_in);
    return 0;
}
// 辅助函数：以十六进制格式打印字节数组
void print_hex(const char *label, const uint8_t *data, size_t len) {
    printf("%s: ", label);
    for(size_t i = 0; i < len; i++) {
        printf("%02X", data[i]);
    }
    printf("\n");
}

int gmssl_sm2_encrypt(const unsigned char * input_file, SM2_KEY* key){
    unsigned char *plaintext = NULL;
    size_t plaintext_len = 0;
    if(read_file(input_file,&plaintext, &plaintext_len)){
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    };
    uint8_t ciphertext[SM2_MAX_CIPHERTEXT_SIZE];
    size_t ciphertext_len = sizeof(ciphertext);
    int ret = sm2_encrypt(key, (const uint8_t *)plaintext, plaintext_len, ciphertext, &ciphertext_len);
    if (ret != 1) {
        fprintf(stderr, "SM2 加密失败\n");
        return EXIT_FAILURE;
    }
    printf("加密成功。\n");
    // 打印密文
    print_hex("密文", ciphertext, ciphertext_len);
    const char *output_file = "encrypt.txt";
    FILE* fp_out = fopen(output_file, "wb");
    if (!fp_out) {
        perror("Error opening output file\n");
        fclose(fp_out);
        return 1;
    }
    fwrite(ciphertext, 1, ciphertext_len, fp_out);
    printf("Save ok\n");
    fclose(fp_out);
}
int gmssl_sm2_decrypt(const unsigned char * input_file, SM2_KEY* key){
    unsigned char *ciphertext = NULL;
    size_t ciphertext_len = 0;
    if(read_file(input_file,&ciphertext, &ciphertext_len)){
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    };
    uint8_t decrypted[SM2_MAX_PLAINTEXT_SIZE];
    size_t decrypted_len = sizeof(decrypted);
    printf("解密密文...\n");
    int ret = sm2_decrypt(key, (const uint8_t *)ciphertext, ciphertext_len, decrypted, &decrypted_len);
    if (ret != 1) {
        fprintf(stderr, "SM2 解密失败\n");
        return EXIT_FAILURE;
    }
    printf("解密成功。\n");
    // 确认解密后的明文与原始明文一致
    decrypted[decrypted_len] = '\0'; // 添加字符串终止符
    printf("解密后的明文: %s\n", decrypted);
    const char *output_file = "decrypt.txt";
    FILE* fp_out = fopen(output_file, "wb");
    if (!fp_out) {
        perror("Error opening output file\n");
        fclose(fp_out);
        return 1;
    }
    fwrite(decrypted, 1, decrypted_len, fp_out);
    printf("Save ok\n");
    fclose(fp_out);
}
int gmssl_sm2_sign(const unsigned char * input_file, SM2_KEY* key){
    char *message = NULL;
    size_t message_len = 0;
    if(read_file(input_file,&message, &message_len)){
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    };
    SM2_SIGN_CTX sign_ctx;
    sm2_sign_init(&sign_ctx, key, SM2_DEFAULT_ID, SM2_DEFAULT_ID_LENGTH);
    // 更新签名上下文
    int ret = sm2_sign_update(&sign_ctx, (const uint8_t *)message, message_len);
    if (ret != 1) {
        fprintf(stderr, "SM2 签名更新失败\n");
        return EXIT_FAILURE;
    }
    // 完成签名
    uint8_t signature[SM2_MAX_SIGNATURE_SIZE];
    size_t signature_len = sizeof(signature);
    ret = sm2_sign_finish(&sign_ctx, signature, &signature_len);
    if (ret != 1) {
        fprintf(stderr, "SM2 签名失败\n");
        return EXIT_FAILURE;
    }
    printf("签名成功。\n");
    print_hex("签名", signature, signature_len);
    const char *output_file = "signature.sig";
    FILE* fp_out = fopen(output_file, "wb");
    if (!fp_out) {
        perror("Error opening output file\n");
        fclose(fp_out);
        return 1;
    }
    fwrite(signature, 1, signature_len, fp_out);
    printf("Save ok\n");
    fclose(fp_out);
}
int gmssl_sm2_verify(const unsigned char * input_file, const unsigned char * input_sign, SM2_KEY* key){
    unsigned char *message = NULL;
    size_t message_len = 0;
    if(read_file(input_file,&message, &message_len)){
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    }
    uint8_t *signature = NULL;
    size_t signature_len = 0;
    if(read_file(input_sign,&signature, &signature_len)){
        fprintf(stderr, "Unable to read file.\n");
        return 0;
    }
    printf("%s\n", message);
    print_hex("签名",signature,signature_len);
    SM2_SIGN_CTX verify_ctx;
    sm2_verify_init(&verify_ctx, key, SM2_DEFAULT_ID, SM2_DEFAULT_ID_LENGTH);
    int ret = sm2_verify_update(&verify_ctx, (const uint8_t *)message, message_len);
    if (ret != 1) {
        fprintf(stderr, "SM2 签名验证更新失败\n");
        return EXIT_FAILURE;
    }

    ret = sm2_verify_finish(&verify_ctx, signature, signature_len);
    if (ret == 1) {
        printf("签名验证成功。\n");
    } else {
        printf("签名验证失败。\n");
        return EXIT_FAILURE;
    }
}
int generate_sm2_key(){
    int ret;
    SM2_KEY key;
    // 生成 SM2 密钥对
    printf("生成 SM2 密钥对...\n");
    ret = sm2_key_generate(&key);
    if (ret != 1) {
        fprintf(stderr, "SM2 密钥生成失败\n");
        return 1;
    }
    printf("SM2 密钥生成成功。\n");
    FILE *priv_fp = fopen("private_key.bin", "wb");
    if (priv_fp == NULL) {
        fprintf(stderr, "打开私钥文件失败\n");
        return EXIT_FAILURE;
    }
    FILE *pub_fp = fopen("public_key.bin", "wb");
    if (pub_fp == NULL) {
        fprintf(stderr, "打开公钥文件失败\n");
        return EXIT_FAILURE;
    }
    uint8_t prikey[32];
    sm2_z256_to_bytes(key.private_key, prikey);
    uint8_t octets[65];
    octets[0] = SM2_point_uncompressed;
    (void)sm2_z256_point_to_bytes(&key.public_key, octets + 1);
    fwrite(prikey, 1, sizeof(prikey), priv_fp);
    fclose(priv_fp); // 关闭私钥文件
    // 写入公钥
    fwrite(octets, 1, sizeof(octets), pub_fp);
    fclose(pub_fp); // 关闭公钥文件
    sm2_key_print(stdout, 0, 4, "SM2", &key);
    return 0;
}
int load_pri_key(const unsigned char* pri, SM2_KEY* mykey){
    if (mykey == NULL) {
        fprintf(stderr, "提供的SM2_KEY结构指针无效\n");
        return 1;
    }
    FILE *priv_fp = fopen(pri, "rb");
    if (priv_fp == NULL) {
        fprintf(stderr, "打开私钥文件失败\n");
        return 1;
    }
    uint8_t prikey[32];
    size_t len;
    len = fread(prikey, 1, sizeof(prikey), priv_fp);
    if (len != sizeof(prikey)) {
        fprintf(stderr, "读取私钥数据失败\n");
        fclose(priv_fp);
        return 1;
    }
    fclose(priv_fp);
    sm2_z256_from_bytes(mykey->private_key, prikey);
    return 0;
}
int load_pub_key(const unsigned char* pub, SM2_KEY* mykey){
    if (mykey == NULL) {
        fprintf(stderr, "提供的SM2_KEY结构指针无效\n");
        return 1;
    }
    FILE *pub_fp = fopen(pub, "rb");
    if (pub_fp == NULL) {
        fprintf(stderr, "打开公钥文件失败\n");
        return 1;
    }
    uint8_t octets[65];
    size_t len;
    len = fread(octets, 1, sizeof(octets), pub_fp);
    if (len != sizeof(octets)) {
        fprintf(stderr, "读取公钥数据失败\n");
        fclose(pub_fp);
        return 1;
    }
    fclose(pub_fp);
    if (sm2_z256_point_from_bytes(&mykey->public_key, octets + 1) != 1) {
        fprintf(stderr, "密钥数据加载失败\n");
        return 1;
    }
    return 0;
}
int load_key(const char* pri_file, const char* pub_file, SM2_KEY* mykey) {
    load_pub_key(pub_file, mykey);
    load_pri_key(pri_file, mykey);
    return 0;
}

void usage(){
    printf("usage: -key\n");
    printf("       -e -kfile -file\n");
    printf("       -d -kfile -file\n");
    printf("       -s -pri -pub -file\n");
    printf("       -v -kfile -file -signature\n");
}
int check(char * argv[]){
    if(strcmp(argv[4], "-file") != 0){
        usage();
        return 1;
    }
    if (argv[5] == NULL || argv[5][0] == '\0') {
        fprintf(stderr, "No file provided\n");
        return 1;
    }
    return 0;
}
int main(int argc, char* argv[]) {
    SM2_KEY mykey;
    if(argc == 1){
        usage();
        return 0;
    }
    if(strcmp(argv[1], "-key") == 0){
        generate_sm2_key();
    }else if(argc <= 5){
        usage();
    }else if(strcmp(argv[1], "-e") == 0 && strcmp(argv[2], "-kfile") == 0){
        if(load_pub_key((const unsigned char*)argv[3], &mykey)){
            fprintf(stderr, "密钥数据加载失败\n");
            return 1;
        }
        if(check(argv)){
            usage();
            return 1;
        }
        gmssl_sm2_encrypt((const unsigned char*)argv[5], &mykey);
    }else if(strcmp(argv[1], "-d") == 0 && strcmp(argv[2], "-kfile") == 0){
        if(load_pri_key((const unsigned char*)argv[3], &mykey)){
            fprintf(stderr, "密钥数据加载失败\n");
            return 1;
        }
        if(check(argv)){
            usage();
            return 1;
        }
        gmssl_sm2_decrypt((const unsigned char*)argv[5], &mykey);
    }else if(strcmp(argv[1], "-s") == 0 && strcmp(argv[2], "-pri") == 0 && strcmp(argv[4], "-pub") == 0){
        if(load_pri_key((const unsigned char*)argv[3], &mykey) || load_pub_key((const unsigned char*)argv[5], &mykey)){
            fprintf(stderr, "密钥数据加载失败\n");
            return 1;
        }
        if(strcmp(argv[6], "-file") != 0 || argv[7] == NULL){
            usage();
            return 1;
        }
        gmssl_sm2_sign((const unsigned char*)argv[7], &mykey);
    }
    else if(strcmp(argv[1], "-v") == 0 && strcmp(argv[2], "-kfile") == 0){
        //load_pri_key("private_key.bin", &mykey);
        if(load_pub_key((const unsigned char*)argv[3], &mykey)){
            fprintf(stderr, "密钥数据加载失败\n");
            return 1;
        }
        if(check(argv) || strcmp(argv[6], "-signature") != 0 || argv[7] == NULL){
            usage();
            return 1;
        }
        gmssl_sm2_verify((const unsigned char*)argv[5], (const unsigned char*) argv[7],&mykey);
    }else {
        usage();
    }
}
~~~
##### 运行结果

~~~ shell
$ ./sm2gmssl -key
生成 SM2 密钥对...
SM2 密钥生成成功。
    SM2
        publicKey: 595672DA35F9C0D5D2738904169B869C1AB115D09F8C832ED16AFBB0FAEA817EE171667A67350E97E4705211DDE9D3224D27D6139617B6D189565938FA4020B4
        privateKey: 2128d7c5698353e59c48c2570ba94406fbd65a1eeb1088c9b1f92e00318f9006
$ ./sm2gmssl -e -kfile public_key.bin -file plain.txt 
加密成功。
密文: 30818A02204E6AB7157D38C1630E8E15453096788E64B8C53ED9CA7C9CAA4206B88F12E74302207D443255F6F5378A996821EBAEB97455B594C8F8FA49C579EC63447565592EC404209CB40C41C080965A7D6332569078C3EB7BBAFB12C7EDE5E33BE11DC0223B2BC4042249947147D7F6F26A5729459AE73E1B062D5FF058B900CEBE2CB1A9F42DED800BDE1F
Save ok
$ ./sm2gmssl -d -kfile private_key.bin -file encrypt.txt
解密密文...
解密成功。
解密后的明文: 20221415cjs20221415cjs20221415cjs

Save ok
$ ./sm2gmssl -s -pri private_key.bin -pub public_key.bin -file plain.txt
签名成功。
签名: 3044022063544FB1E6272C1ADD74F5136819DC363FCC9BE9472571A7ABDAB18D31E5CF1702205D3DDFE8232E75A6C0E7C5EEF670D6164D61AFE026CC0A4DE3FC8429AF44B8F4
Save ok
$ ./sm2gmssl -v -kfile public_key.bin -file plain.txt  -signature signature.sig
20221415cjs20221415cjs20221415cjs

签名: 3044022063544FB1E6272C1ADD74F5136819DC363FCC9BE9472571A7ABDAB18D31E5CF1702205D3DDFE8232E75A6C0E7C5EEF670D6164D61AFE026CC0A4DE3FC8429AF44B8F4
签名验证成功。
~~~

#### SM3
##### SM3-HASH
~~~ c
#include <stdio.h>
#include <string.h>
#include <gmssl/sm3.h>
int read_file(const unsigned char *input_file, unsigned char ** text, size_t* len){
    FILE* fp_in = fopen(input_file, "rb");
    if (!fp_in) {
        perror("Error opening input file");
        return 1;
    }
    // 获取文件大小并分配内存
    fseek(fp_in, 0, SEEK_END);
    *len = ftell(fp_in);
    fseek(fp_in, 0, SEEK_SET);
    *text = malloc(*len);
    if (!*text) {
        perror("Memory allocation failed");
        return 0;
    }
    fread(*text, 1, *len, fp_in);
    fclose(fp_in);
    return 0;
}
int main(int argc, char* argv[]) {
    if(argc < 3){
        printf("usage: -in filename\n");
        return 0;
    }
    if(strcmp(argv[1], "-in") != 0){
        printf("usage: -in filename\n");
        return 0;
    }
    unsigned char hash[SM3_DIGEST_SIZE];  // SM3_DIGEST_SIZE is the length of the hash
    SM3_CTX ctx;
    sm3_init(&ctx);  // Initialize the hash context
    sm3_update(&ctx, (const unsigned char*)argv[2], strlen(argv[2]));  // Hash the data
    sm3_finish(&ctx, hash);  // Finalize the hash
    printf("SM3 hash: ");
    for (int i = 0; i < SM3_DIGEST_SIZE; i++) {
        printf("%02x", hash[i]);
    }
    printf("\n");
    const char *output_file = "hash.bin";
    FILE* fp_out = fopen(output_file, "wb");
    if (!fp_out) {
        printf("SM3 Save Error\n");
        perror("Error opening output file\n");
        fclose(fp_out);
        return 1;
    }
    fwrite(hash, 1, SM3_DIGEST_SIZE, fp_out);
    printf("SM3 Save ok\n");
    fclose(fp_out);
    return 0;
}
~~~
##### 运行结果

~~~ shell
$ ./sm3gmssl -in plain.txt 
SM3 hash: e8b7cdd914485231d54d60fa13d27f0243b336c78d173324c8ef7d3176ea9d23
SM3 Save ok
~~~

##### SM3-HMAC
~~~ c
// sm3.c
#include <string.h>
#include <stdint.h>
#include <stdio.h>
typedef struct {
    uint32_t total[2];     // 消息总长度（以位为单位）
    uint32_t state[8];     // 哈希状态
    unsigned char buffer[64]; // 数据缓冲区

    // 用于 HMAC
    unsigned char ipad[64];
    unsigned char opad[64];
} sm3_context;

/*
 * 32-bit integer manipulation macros (big endian)
 */
#ifndef GET_UINT32_BE
#define GET_UINT32_BE(n,b,i)                             \
    {                                                       \
        (n) = ((uint32_t)(b)[(i)    ] << 24)             \
            | ((uint32_t)(b)[(i) + 1] << 16)             \
            | ((uint32_t)(b)[(i) + 2] <<  8)             \
            | ((uint32_t)(b)[(i) + 3]       );            \
    }
#endif

#ifndef PUT_UINT32_BE
#define PUT_UINT32_BE(n,b,i)                             \
    {                                                       \
        (b)[(i)    ] = (unsigned char) ( (n) >> 24 );     \
        (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );     \
        (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );     \
        (b)[(i) + 3] = (unsigned char) ( (n)       );     \
    }
#endif

/*
 * SM3 context setup
 */
void sm3_starts(sm3_context *ctx)
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x7380166F;
    ctx->state[1] = 0x4914B2B9;
    ctx->state[2] = 0x172442D7;
    ctx->state[3] = 0xDA8A0600;
    ctx->state[4] = 0xA96F30BC;
    ctx->state[5] = 0x163138AA;
    ctx->state[6] = 0xE38DEE4D;
    ctx->state[7] = 0xB0FB0E4E;
}

static void sm3_process(sm3_context *ctx, const unsigned char data[64])
{
    uint32_t SS1, SS2, TT1, TT2, W[68], W1[64];
    uint32_t A, B, C, D, E, F, G, H;
    uint32_t T[64];
    uint32_t Temp1, Temp2, Temp3, Temp4, Temp5;
    int j;
#ifdef _DEBUG
    int i;
#endif

    for (j = 0; j < 16; j++)
        T[j] = 0x79CC4519;
    for (j = 16; j < 64; j++)
        T[j] = 0x7A879D8A;

    for (j = 0; j < 16; j++)
    GET_UINT32_BE(W[j], data, j * 4);

#ifdef _DEBUG
    printf("Message with padding:\n");
    for (i = 0; i < 8; i++)
        printf("%08x ", W[i]);
    printf("\n");
    for (i = 8; i < 16; i++)
        printf("%08x ", W[i]);
    printf("\n");
#endif

#define FF0(x,y,z) ( (x) ^ (y) ^ (z))
#define FF1(x,y,z) (((x) & (y)) | ( (x) & (z)) | ( (y) & (z)))

#define GG0(x,y,z) ( (x) ^ (y) ^ (z))
#define GG1(x,y,z) (((x) & (y)) | ( (~(x)) & (z)) )

#define  SHL(x,n) (((x) & 0xFFFFFFFF) << (n))
#define ROTL(x,n) (SHL((x),n) | ((x) >> (32 - (n))))

#define P0(x) ((x) ^  ROTL((x),9) ^ ROTL((x),17))
#define P1(x) ((x) ^  ROTL((x),15) ^ ROTL((x),23))

    for (j = 16; j < 68; j++)
    {
        Temp1 = W[j - 16] ^ W[j - 9];
        Temp2 = ROTL(W[j - 3], 15);
        Temp3 = Temp1 ^ Temp2;
        Temp4 = P1(Temp3);
        Temp5 = ROTL(W[j - 13], 7) ^ W[j - 6];
        W[j] = Temp4 ^ Temp5;
    }

#ifdef _DEBUG
    printf("Expanding message W0-67:\n");
    for (i = 0; i < 68; i++)
    {
        printf("%08x ", W[i]);
        if (((i + 1) % 8) == 0) printf("\n");
    }
    printf("\n");
#endif

    for (j = 0; j < 64; j++)
    {
        W1[j] = W[j] ^ W[j + 4];
    }

#ifdef _DEBUG
    printf("Expanding message W'0-63:\n");
    for (i = 0; i < 64; i++)
    {
        printf("%08x ", W1[i]);
        if (((i + 1) % 8) == 0) printf("\n");
    }
    printf("\n");
#endif

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];
#ifdef _DEBUG
    printf("j     A       B        C         D         E        F        G       H\n");
    printf("   %08x %08x %08x %08x %08x %08x %08x %08x\n", A, B, C, D, E, F, G, H);
#endif

    for (j = 0; j < 16; j++)
    {
        SS1 = ROTL((ROTL(A, 12) + E + ROTL(T[j], j)), 7);
        SS2 = SS1 ^ ROTL(A, 12);
        TT1 = FF0(A, B, C) + D + SS2 + W1[j];
        TT2 = GG0(E, F, G) + H + SS1 + W[j];
        D = C;
        C = ROTL(B, 9);
        B = A;
        A = TT1;
        H = G;
        G = ROTL(F, 19);
        F = E;
        E = P0(TT2);
#ifdef _DEBUG
        printf("%02d %08x %08x %08x %08x %08x %08x %08x %08x\n", j, A, B, C, D, E, F, G, H);
#endif
    }

    for (j = 16; j < 64; j++)
    {
        SS1 = ROTL((ROTL(A, 12) + E + ROTL(T[j], j)), 7);
        SS2 = SS1 ^ ROTL(A, 12);
        TT1 = FF1(A, B, C) + D + SS2 + W1[j];
        TT2 = GG1(E, F, G) + H + SS1 + W[j];
        D = C;
        C = ROTL(B, 9);
        B = A;
        A = TT1;
        H = G;
        G = ROTL(F, 19);
        F = E;
        E = P0(TT2);
#ifdef _DEBUG
        printf("%02d %08x %08x %08x %08x %08x %08x %08x %08x\n", j, A, B, C, D, E, F, G, H);
#endif
    }

    ctx->state[0] ^= A;
    ctx->state[1] ^= B;
    ctx->state[2] ^= C;
    ctx->state[3] ^= D;
    ctx->state[4] ^= E;
    ctx->state[5] ^= F;
    ctx->state[6] ^= G;
    ctx->state[7] ^= H;
#ifdef _DEBUG
    printf("   %08x %08x %08x %08x %08x %08x %08x %08x\n", ctx->state[0], ctx->state[1], ctx->state[2],
        ctx->state[3], ctx->state[4], ctx->state[5], ctx->state[6], ctx->state[7]);
#endif
}

/*
 * SM3 process buffer
 */
void sm3_update(sm3_context *ctx, const unsigned char *input, int ilen)
{
    int fill;
    uint32_t left;

    if (ilen <= 0)
        return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += ilen;
    ctx->total[0] &= 0xFFFFFFFF;

    if (ctx->total[0] < (uint32_t)ilen)
        ctx->total[1]++;

    if (left && ilen >= fill)
    {
        memcpy(ctx->buffer + left, input, fill);
        sm3_process(ctx, ctx->buffer);
        input += fill;
        ilen -= fill;
        left = 0;
    }

    while (ilen >= 64)
    {
        sm3_process(ctx, input);
        input += 64;
        ilen -= 64;
    }

    if (ilen > 0)
    {
        memcpy(ctx->buffer + left, input, ilen);
    }
}

static const unsigned char sm3_padding[64] =
        {
                0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        };

/*
 * SM3 final digest
 */
void sm3_finish(sm3_context *ctx, unsigned char output[32])
{
    uint32_t last, padn;
    uint32_t high, low;
    unsigned char msglen[8];

    high = (ctx->total[0] >> 29) | (ctx->total[1] << 3);
    low = (ctx->total[0] << 3);

    PUT_UINT32_BE(high, msglen, 0);
    PUT_UINT32_BE(low, msglen, 4);

    last = ctx->total[0] & 0x3F;
    padn = (last < 56) ? (56 - last) : (120 - last);

    sm3_update(ctx, sm3_padding, padn);
    sm3_update(ctx, msglen, 8);

    PUT_UINT32_BE(ctx->state[0], output, 0);
    PUT_UINT32_BE(ctx->state[1], output, 4);
    PUT_UINT32_BE(ctx->state[2], output, 8);
    PUT_UINT32_BE(ctx->state[3], output, 12);
    PUT_UINT32_BE(ctx->state[4], output, 16);
    PUT_UINT32_BE(ctx->state[5], output, 20);
    PUT_UINT32_BE(ctx->state[6], output, 24);
    PUT_UINT32_BE(ctx->state[7], output, 28);
}

/*
 * output = SM3( input buffer )
 */
void sm3(const unsigned char *input, int ilen, unsigned char output[32])
{
    sm3_context ctx;

    sm3_starts(&ctx);
    sm3_update(&ctx, input, ilen);
    sm3_finish(&ctx, output);

    memset(&ctx, 0, sizeof(sm3_context));
}

/*
 * output = SM3( file contents )
 */
int sm3_file(const char *path, unsigned char output[32])
{
    FILE *f;
    size_t n;
    sm3_context ctx;
    unsigned char buf[1024];

    if ((f = fopen(path, "rb")) == NULL)
        return 1;

    sm3_starts(&ctx);

    while ((n = fread(buf, 1, sizeof(buf), f)) > 0)
        sm3_update(&ctx, buf, n);

    sm3_finish(&ctx, output);

    memset(&ctx, 0, sizeof(sm3_context));

    if (ferror(f) != 0)
    {
        fclose(f);
        return 2;
    }

    fclose(f);
    return 0;
}

/*
 * SM3 HMAC context setup
 */
void sm3_hmac_starts(sm3_context *ctx, const unsigned char *key, int keylen)
{
    int i;
    unsigned char sum[32];

    if (keylen > 64)
    {
        sm3(key, keylen, sum);
        keylen = 32;
        //key = sum;
        key = (const unsigned char*)sum;
    }

    memset(ctx->ipad, 0x36, 64);
    memset(ctx->opad, 0x5C, 64);

    for (i = 0; i < keylen; i++)
    {
        ctx->ipad[i] ^= key[i];
        ctx->opad[i] ^= key[i];
    }

    sm3_starts(ctx);
    sm3_update(ctx, ctx->ipad, 64);

    memset(sum, 0, sizeof(sum));
}

/*
 * SM3 HMAC process buffer
 */
void sm3_hmac_update(sm3_context *ctx, const unsigned char *input, int ilen)
{
    sm3_update(ctx, input, ilen);
}

/*
 * SM3 HMAC final digest
 */
void sm3_hmac_finish(sm3_context *ctx, unsigned char output[32])
{
    int hlen = 32;
    unsigned char tmpbuf[32];

    sm3_finish(ctx, tmpbuf);
    sm3_starts(ctx);
    sm3_update(ctx, ctx->opad, 64);
    sm3_update(ctx, tmpbuf, hlen);
    sm3_finish(ctx, output);

    memset(tmpbuf, 0, sizeof(tmpbuf));
}

/*
 * output = HMAC-SM3( hmac key, input buffer )
 */
void sm3_hmac(const unsigned char *key, int keylen,
              const unsigned char *input, int ilen,
              unsigned char output[32])
{
    sm3_context ctx;

    sm3_hmac_starts(&ctx, key, keylen);
    sm3_hmac_update(&ctx, input, ilen);
    sm3_hmac_finish(&ctx, output);

    memset(&ctx, 0, sizeof(sm3_context));
}
// 打印缓冲区为十六进制格式
void dumpbuf(const unsigned char *buf, int len) {
    for (int i = 0; i < len; i++) {
        printf("%02x", buf[i]);
        if (((i + 1) % 4) == 0) printf(" ");
    }
    printf("\n");
}
int read_file(const unsigned char *input_file, unsigned char ** text, size_t* len){
    FILE* fp_in = fopen(input_file, "rb");
    if (!fp_in) {
        perror("Error opening input file");
        return 1;
    }
    // 获取文件大小并分配内存
    fseek(fp_in, 0, SEEK_END);
    *len = ftell(fp_in);
    fseek(fp_in, 0, SEEK_SET);
    *text = malloc(*len);
    if (!*text) {
        perror("Memory allocation failed");
        return 0;
    }
    fread(*text, 1, *len, fp_in);
    fclose(fp_in);
    return 0;
}
int main(int argc, char *argv[])
{
    if(argc < 5){
        printf("usage: -kfile -file\n");
        return 0;
    }
    if(strcmp(argv[1], "-kfile") == 0 && strcmp(argv[3], "-file") == 0){
        const unsigned char *input = NULL;
        const unsigned char *key = NULL;
        size_t  keylen = 0, ilen = 0;
        if(read_file((const unsigned char*)argv[2], &key, &keylen) || read_file((const unsigned char *)argv[4], &input, &ilen)){
            fprintf(stderr, "Unable to read file.\n");
            return 0;
        }
        unsigned char output[32];
        printf("Message: %s\n", input);
        sm3_hmac(key, keylen, input, ilen, output);
        printf("HMAC:   ");
        dumpbuf(output, 32);

        const char *output_file = "SM3-HMAC.bin";
        FILE* fp_out = fopen(output_file, "wb");
        if (!fp_out) {
            printf("SM3 Save Error\n");
            perror("Error opening output file\n");
            fclose(fp_out);
            return 1;
        }
        fwrite(output, 1, 32, fp_out);
        printf("SM3-HMAC Save ok\n");
        fclose(fp_out);
    }
    return 0;
}

~~~
##### 运行结果

~~~ shell
$ ./sm3-hmac -kfile public_key.bin -file plain.txt 
Message: 20221415cjs20221415cjs20221415cjs
HMAC:   aa2de707 ba2e71cc 7beba05a 8ce539ee 06ddc735 157ce788 1e9fdd44 6be04037
SM3-HMAC Save ok
~~~

#### SM4
##### 代码
~~~ c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include "gmssl/sm4.h"
#include "gmssl/rand.h"

void usage() {
    printf("usage:    -key\n");
    printf("          -iv\n");
    printf("          -e/-d -key -iv -file\n");
    return;
}

int read_file(const unsigned char *input_file, unsigned char **text, size_t *len) {
    FILE *fp_in = fopen(input_file, "rb");
    if (!fp_in) {
        perror("Error opening input file");
        return 1;
    }
    // 获取文件大小并分配内存
    fseek(fp_in, 0, SEEK_END);
    *len = ftell(fp_in);
    fseek(fp_in, 0, SEEK_SET);
    *text = malloc(*len);
    if (!*text) {
        perror("Memory allocation failed");
        return 0;
    }
    fread(*text, 1, *len, fp_in);
    fclose(fp_in);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc == 1) {
        usage();
        return;
    }
    if (strcmp(argv[1], "-key") == 0) {
        uint8_t key[SM4_KEY_SIZE];
        if (rand_bytes(key, SM4_KEY_SIZE) != 1) {
            fprintf(stderr, "随机密钥生成失败。\n");
            return EXIT_FAILURE;
        }
        printf("随机生成的密钥: ");
        for (size_t i = 0; i < SM4_KEY_SIZE; i++) {
            printf("%02X ", key[i]);
        }
        printf("\n");
        const char *output_file = "key.bin";
        FILE *fp_out = fopen(output_file, "wb");
        if (!fp_out) {
            printf("Save Error\n");
            perror("Error opening output file\n");
            fclose(fp_out);
            return 1;
        }
        fwrite(key, 1, SM4_KEY_SIZE, fp_out);
        printf("key Save ok\n");
        fclose(fp_out);
    } else if (strcmp(argv[1], "-iv") == 0) {
        uint8_t iv[SM4_BLOCK_SIZE];
        if (rand_bytes(iv, SM4_BLOCK_SIZE) != 1) {
            fprintf(stderr, "随机IV生成失败。\n");
            return EXIT_FAILURE;
        }
        // 打印生成的IV
        printf("随机生成的IV: ");
        for (size_t i = 0; i < SM4_BLOCK_SIZE; i++) {
            printf("%02X ", iv[i]);
        }
        printf("\n");
        const char *output_file = "iv.bin";
        FILE *fp_out = fopen(output_file, "wb");
        if (!fp_out) {
            printf("Save Error\n");
            perror("Error opening output file\n");
            fclose(fp_out);
            return 1;
        }
        fwrite(iv, 1, SM4_KEY_SIZE, fp_out);
        printf("iv Save ok\n");
        fclose(fp_out);
    } else if (strcmp(argv[1], "-e") == 0) {
        if (argc < 8) {
            usage();
            return 0;
        }
        if (strcmp(argv[2], "-key") != 0 || strcmp(argv[4], "-iv") != 0 || strcmp(argv[6], "-file") != 0) {
            usage();
            return 0;
        }
        unsigned char *plaintext = NULL, *key = NULL, *iv = NULL;
        size_t plaintext_len = 0, key_len = 0, iv_len = 0;
        if (read_file((const unsigned char *) argv[3], &key, &key_len) ||
            read_file((const unsigned char *) argv[5], &iv, &iv_len) ||
            read_file((const unsigned char *) argv[7], &plaintext, &plaintext_len)) {
            fprintf(stderr, "Unable to read file.\n");
            return 0;
        }
        if(key_len != SM4_KEY_SIZE || iv_len != SM4_BLOCK_SIZE){
            printf("key or iv error\n");
            return 0;
        }
        SM4_KEY enc_key;
        sm4_set_encrypt_key(&enc_key, key);
        size_t max_ciphertext_len = plaintext_len + SM4_BLOCK_SIZE;
        uint8_t *ciphertext = malloc(max_ciphertext_len);
        if (ciphertext == NULL) {
            fprintf(stderr, "内存分配失败。\n");
            return EXIT_FAILURE;
        }
        size_t outlen;
        int ret;
        // 加密带填充的明文
        ret = sm4_cbc_padding_encrypt(&enc_key, (uint8_t *) iv, plaintext, plaintext_len, ciphertext, &outlen);
        if (ret != 1) {
            fprintf(stderr, "加密失败。\n");
            free(ciphertext);
            return EXIT_FAILURE;
        }
        // 输出密文（十六进制格式）
        printf("密文 (%zu 字节): ", outlen);
        for (size_t i = 0; i < outlen; i++) {
            printf("%02X ", ciphertext[i]);
        }
        printf("\n");
        free(ciphertext);
        const char *output_file = "ciphertext.txt";
        FILE *fp_out = fopen(output_file, "wb");
        if (!fp_out) {
            printf("Save Error\n");
            perror("Error opening output file\n");
            fclose(fp_out);
            return 1;
        }
        fwrite(ciphertext, 1, outlen, fp_out);
        printf("Save ok\n");
        fclose(fp_out);
    } else if (strcmp(argv[1], "-d") == 0) {
        unsigned char *ciphertext = NULL, *key = NULL, *iv = NULL;
        size_t ciphertext_len = 0, key_len = 0, iv_len = 0;
        if (argc < 8) {
            usage();
            return 0;
        }
        if (strcmp(argv[2], "-key") != 0 || strcmp(argv[4], "-iv") != 0 || strcmp(argv[6], "-file") != 0) {
            usage();
            return 0;
        }
        if (read_file((const unsigned char *) argv[3], &key, &key_len) ||
            read_file((const unsigned char *) argv[5], &iv, &iv_len) ||
            read_file((const unsigned char *) argv[7], &ciphertext, &ciphertext_len)) {
            fprintf(stderr, "Unable to read file.\n");
            return 0;
        }
        if(key_len != SM4_KEY_SIZE || iv_len != SM4_BLOCK_SIZE){
            printf("key or iv error\n");
            return 0;
        }
        SM4_KEY dec_key;
        sm4_set_decrypt_key(&dec_key, key);
        size_t max_ciphertext_len = ciphertext_len;
        uint8_t *decryptedtext = malloc(max_ciphertext_len + 1); // +1用于终止符
        if (decryptedtext == NULL) {
            fprintf(stderr, "内存分配失败。\n");
            free(ciphertext);
            free(key);
            free(iv);
            return EXIT_FAILURE;
        }
        size_t outlen;
        // 解密带填充的密文
        int ret = sm4_cbc_padding_decrypt(&dec_key, (uint8_t *) iv, (uint8_t *) ciphertext, max_ciphertext_len,
                                          decryptedtext, &outlen);
        if (ret != 1) {
            fprintf(stderr, "解密失败。\n");
            free(ciphertext);
            free(decryptedtext);
            return EXIT_FAILURE;
        }
        // 确保解密后的文本是以空字符结尾的字符串
        decryptedtext[outlen] = '\0';
        // 打印解密后的明文（以十六进制格式）
        printf("解密后的明文 (%zu 字节): ", outlen);
        for (size_t i = 0; i < outlen; i++) {
            printf("%02X ", decryptedtext[i]);
        }
        printf("\n");
        const char *output_file = "decryptedtext.txt";
        FILE *fp_out = fopen(output_file, "wb");
        if (!fp_out) {
            printf("Save Error\n");
            perror("Error opening output file\n");
            fclose(fp_out);
            return 1;
        }
        fwrite(decryptedtext, 1, outlen, fp_out);
        printf("Save ok\n");
        fclose(fp_out);
        free(decryptedtext);
    } else {
        usage();
        return EXIT_SUCCESS;
    }
}
~~~
##### 运行结果

~~~ shell
$ ./sm4 -key
随机生成的密钥: 96 30 EE 6A 83 47 65 91 5C 1F 83 C0 16 D4 70 B5
key Save ok
$ ./sm4 -iv
随机生成的IV: 01 CB 38 3C 11 48 B2 87 15 3B 46 65 9E 7C 77 24
iv Save ok
$ ./sm4 -e -key key.bin -iv iv.bin -file plain.txt
密文 (240 字节): 2B EF 79 AD 2D A9 F3 6E 46 06 9F 84 84 3F A2 0B D4 E3 AF 3D EF C4 C0 C3 08 13 A5 40 3A 7B FC E9 4D B0 2F 4F 67 0A 2B 7A 8B 71 D6 EA 55 05 41 FC 4C 50 77 2F 96 6D 9A E7 F8 A2 27 39 D6 1
B 5C 64 0D 9F 4B 74 83 A9 75 D2 F6 60 D5 EE ED 15 CF 6A 67 75 E9 08 E1 D8 0B E5 2C C1 0B 45 53 F0 8D 1C 46 2C 51 5B 92 C9 24 EF DE F8 D8 61 41 24 BB 92 49 66 46 96 84 8E 7D F0 F1 8C 58 13 D6 FE D0 C8 D
5 39 15 E2 57 F1 CB 16 56 D7 F5 36 94 8B 6A EF D4 26 7A A9 4B EF 84 BD 8F 67 A4 F7 B3 65 2F B0 45 49 DD 0B C4 51 82 A4 13 43 1C 5D A1 4B 3A FE 8B DF 4E EE 29 CD 39 17 C1 70 A0 39 10 C8 93 0B 63 D6 88 29 FE A9 5B BC 1E 41 22 7F 7A 78 16 9C 0F AF 81 81 3F 8C 6A DF F7 7E CB 32 74 A5 F7 50 08 84 CC 1E CF 2F 17 76 7C 61 FF E5 CD DB 2B 1C
Save ok
$ ./sm4 -d -key key.bin -iv iv.bin -file ciphertext.txt
解密后的明文 (224 字节): 35 92 1A 63 E7 3D F9 87 C4 B3 8E F4 31 B4 B3 F3 0C E5 DE C2 19 9D C2 5B A0 C0 96 FF 03 5C CB 38 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73
 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33
 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35
Save ok
$ cat decryptedtext.txt 
5�⸮c�=��ĳ��1���
               �����[����\�820221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs12345
               
解密密文前面有一段是错误的，原因未知
$ gmssl sm4_cbc -decrypt -key $(xxd -p -c 32 key.bin) -iv $(xxd -p -c 32 iv.bin) -in ciphertext.txt 
5�⸮c�=��ĳ��1���
               �����[����\�820221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs12345
使用命令行解密仍然存在，猜测是加密代码出错
$ gmssl sm4_cbc -encrypt -key $(xxd -p -c 32 key.bin) -iv $(xxd -p -c 32 iv.bin) -out cjssm4.cbc -in plain.txt 
$ ./sm4 -d -key key.bin -iv iv.bin -file cjssm4.cbc 
解密后的明文 (224 字节): 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73
 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33
 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35
Save ok
$ cat decryptedtext.txt 
20221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs12345
使用命令行加密再用代码解密发现没问题，代码问题出在加密部分
~~~

##### 更改后的代码

~~~ c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include "gmssl/sm4.h"
#include "gmssl/rand.h"

void usage() {
    printf("usage:    -key\n");
    printf("          -iv\n");
    printf("          -e/-d -key -iv -file\n");
    return;
}

int read_file(const unsigned char *input_file, unsigned char **text, size_t *len) {
    FILE *fp_in = fopen(input_file, "rb");
    if (!fp_in) {
        perror("Error opening input file");
        return 1;
    }
    // 获取文件大小并分配内存
    fseek(fp_in, 0, SEEK_END);
    *len = ftell(fp_in);
    fseek(fp_in, 0, SEEK_SET);
    *text = malloc(*len);
    if (!*text) {
        perror("Memory allocation failed");
        return 0;
    }
    fread(*text, 1, *len, fp_in);
    fclose(fp_in);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc == 1) {
        usage();
        return;
    }
    if (strcmp(argv[1], "-key") == 0) {
        uint8_t key[SM4_KEY_SIZE];
        if (rand_bytes(key, SM4_KEY_SIZE) != 1) {
            fprintf(stderr, "随机密钥生成失败。\n");
            return EXIT_FAILURE;
        }
        printf("随机生成的密钥: ");
        for (size_t i = 0; i < SM4_KEY_SIZE; i++) {
            printf("%02X ", key[i]);
        }
        printf("\n");
        const char *output_file = "key.bin";
        FILE *fp_out = fopen(output_file, "wb");
        if (!fp_out) {
            printf("Save Error\n");
            perror("Error opening output file\n");
            fclose(fp_out);
            return 1;
        }
        fwrite(key, 1, SM4_KEY_SIZE, fp_out);
        printf("key Save ok\n");
        fclose(fp_out);
    } else if (strcmp(argv[1], "-iv") == 0) {
        uint8_t iv[SM4_BLOCK_SIZE];
        if (rand_bytes(iv, SM4_BLOCK_SIZE) != 1) {
            fprintf(stderr, "随机IV生成失败。\n");
            return EXIT_FAILURE;
        }
        // 打印生成的IV
        printf("随机生成的IV: ");
        for (size_t i = 0; i < SM4_BLOCK_SIZE; i++) {
            printf("%02X ", iv[i]);
        }
        printf("\n");
        const char *output_file = "iv.bin";
        FILE *fp_out = fopen(output_file, "wb");
        if (!fp_out) {
            printf("Save Error\n");
            perror("Error opening output file\n");
            fclose(fp_out);
            return 1;
        }
        fwrite(iv, 1, SM4_BLOCK_SIZE, fp_out);
        printf("iv Save ok\n");
        fclose(fp_out);
    } else if (strcmp(argv[1], "-e") == 0) {
        if (argc < 8) {
            usage();
            return 0;
        }
        if (strcmp(argv[2], "-key") != 0 || strcmp(argv[4], "-iv") != 0 || strcmp(argv[6], "-file") != 0) {
            usage();
            return 0;
        }
        unsigned char *plaintext = NULL, *key = NULL, *iv = NULL;
        size_t plaintext_len = 0, key_len = 0, iv_len = 0;
        if (read_file((const unsigned char *) argv[3], &key, &key_len) ||
            read_file((const unsigned char *) argv[5], &iv, &iv_len) ||
            read_file((const unsigned char *) argv[7], &plaintext, &plaintext_len)) {
            fprintf(stderr, "Unable to read file.\n");
            return 0;
        }
        if(key_len != SM4_KEY_SIZE || iv_len != SM4_BLOCK_SIZE){
            printf("key or iv error\n");
            return 0;
        }
        SM4_KEY enc_key;
        sm4_set_encrypt_key(&enc_key, key);
        size_t max_ciphertext_len = plaintext_len + SM4_BLOCK_SIZE;
        uint8_t *ciphertext = malloc(max_ciphertext_len);
        if (ciphertext == NULL) {
            fprintf(stderr, "内存分配失败。\n");
            return EXIT_FAILURE;
        }
        size_t outlen;
        int ret;
        // 加密带填充的明文
        ret = sm4_cbc_padding_encrypt(&enc_key, (uint8_t *) iv, (uint8_t *)plaintext, plaintext_len, ciphertext, &outlen);
        if (ret != 1) {
            fprintf(stderr, "加密失败。\n");
            free(ciphertext);
            return EXIT_FAILURE;
        }
        // 输出密文（十六进制格式）
        printf("密文 (%zu 字节): ", outlen);
        for (size_t i = 0; i < outlen; i++) {
            printf("%02X ", ciphertext[i]);
        }
        printf("\n");
        const char *output_file = "ciphertext.txt";
        FILE *fp_out = fopen(output_file, "wb");
        if (!fp_out) {
            printf("Save Error\n");
            perror("Error opening output file\n");
            fclose(fp_out);
            return 1;
        }
        fwrite(ciphertext, 1, outlen, fp_out);
        printf("Save ok\n");
        fclose(fp_out);
        free(ciphertext);
    } else if (strcmp(argv[1], "-d") == 0) {
        unsigned char *ciphertext = NULL, *key = NULL, *iv = NULL;
        size_t ciphertext_len = 0, key_len = 0, iv_len = 0;
        if (argc < 8) {
            usage();
            return 0;
        }
        if (strcmp(argv[2], "-key") != 0 || strcmp(argv[4], "-iv") != 0 || strcmp(argv[6], "-file") != 0) {
            usage();
            return 0;
        }
        if (read_file((const unsigned char *) argv[3], &key, &key_len) ||
            read_file((const unsigned char *) argv[5], &iv, &iv_len) ||
            read_file((const unsigned char *) argv[7], &ciphertext, &ciphertext_len)) {
            fprintf(stderr, "Unable to read file.\n");
            return 0;
        }
        if(key_len != SM4_KEY_SIZE || iv_len != SM4_BLOCK_SIZE){
            printf("key or iv error\n");
            return 0;
        }
        SM4_KEY dec_key;
        sm4_set_decrypt_key(&dec_key, key);
        size_t max_ciphertext_len = ciphertext_len;
        uint8_t *decryptedtext = malloc(max_ciphertext_len + 1); // +1用于终止符
        if (decryptedtext == NULL) {
            fprintf(stderr, "内存分配失败。\n");
            free(ciphertext);
            free(key);
            free(iv);
            return EXIT_FAILURE;
        }
        size_t outlen;
        // 解密带填充的密文
        int ret = sm4_cbc_padding_decrypt(&dec_key, (uint8_t *) iv, (uint8_t *) ciphertext, max_ciphertext_len,
                                          decryptedtext, &outlen);
        if (ret != 1) {
            fprintf(stderr, "解密失败。\n");
            free(ciphertext);
            free(decryptedtext);
            return EXIT_FAILURE;
        }
        // 确保解密后的文本是以空字符结尾的字符串
        decryptedtext[outlen] = '\0';
        // 打印解密后的明文（以十六进制格式）
        printf("解密后的明文 (%zu 字节): ", outlen);
        for (size_t i = 0; i < outlen; i++) {
            printf("%02X ", decryptedtext[i]);
        }
        printf("\n");
        const char *output_file = "decryptedtext.txt";
        FILE *fp_out = fopen(output_file, "wb");
        if (!fp_out) {
            printf("Save Error\n");
            perror("Error opening output file\n");
            fclose(fp_out);
            return 1;
        }
        fwrite(decryptedtext, 1, outlen, fp_out);
        printf("Save ok\n");
        fclose(fp_out);
        free(decryptedtext);
    } else {
        usage();
        return EXIT_SUCCESS;
    }
}
~~~

发现free放在了保存文件之前，导致实际保存的加密错误，更改后正常解密。

~~~ shell
$ ./sm4 -e -key key.bin -iv iv.bin -file plain.txt 
密文 (240 字节): 2B EF 79 AD 2D A9 F3 6E 46 06 9F 84 84 3F A2 0B D4 E3 AF 3D EF C4 C0 C3 08 13 A5 40 3A 7B FC E9 4D B0 2F 4F 67 0A 2B 7A 8B 71 D6 EA 55 05 41 FC 4C 50 77 2F 96 6D 9A E7 F8 A2 27 39 D6 1
B 5C 64 0D 9F 4B 74 83 A9 75 D2 F6 60 D5 EE ED 15 CF 6A 67 75 E9 08 E1 D8 0B E5 2C C1 0B 45 53 F0 8D 1C 46 2C 51 5B 92 C9 24 EF DE F8 D8 61 41 24 BB 92 49 66 46 96 84 8E 7D F0 F1 8C 58 13 D6 FE D0 C8 D
5 39 15 E2 57 F1 CB 16 56 D7 F5 36 94 8B 6A EF D4 26 7A A9 4B EF 84 BD 8F 67 A4 F7 B3 65 2F B0 45 49 DD 0B C4 51 82 A4 13 43 1C 5D A1 4B 3A FE 8B DF 4E EE 29 CD 39 17 C1 70 A0 39 10 C8 93 0B 63 D6 88 29 FE A9 5B BC 1E 41 22 7F 7A 78 16 9C 0F AF 81 81 3F 8C 6A DF F7 7E CB 32 74 A5 F7 50 08 84 CC 1E CF 2F 17 76 7C 61 FF E5 CD DB 2B 1C
Save ok
$ ./sm4 -d -key key.bin -iv iv.bin -file ciphertext.txt 
解密后的明文 (224 字节): 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73
 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33
 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35
Save ok
$ cat decryptedtext.txt 
20221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs12345
~~~



### 两⼈⼀组，在 Ubuntu或openEuler中（推荐 openEuler）中使⽤OpenSSL编程实现带签名的数字信封协议。使⽤OpenSSL库时，Alice发送，Bob接收。Ailice，Bob在实验中要替换为⾃⼰的8位学号+姓名。 使⽤Markdown记录详细记录实践过程，每完成⼀项git commit ⼀次。（5分）

##### Alice

~~~ shell
$ ./sm2-1 -key
SM2 key pair generated and saved successfully.
$ gmssl rand -outlen 16 -out key.bin
$ gmssl rand -outlen 16 -out iv.bin
$ ./sm4 -e -kfile key.bin -iv iv.bin -file plain.txt
sm4-cbc encryption successful. Ciphertext length: 16 bytes
Ciphertext:
0000: 1F A9 F1 96 1D 9A AA 72 80 93 04 FE 46 E2 E8 D1
$ ./sm2-1 -e -kfile public.pem -file key.bin
SM2 Encryption OK
SM2 Save ok
$ ./sm2-1 -s -kfile sm2_private.pem -file cipher_sm4-cbc.dat
SM2 signature OK
SM2 Save ok
~~~

##### Bob

~~~ shell
$ ./sm2 -v -kfile sm2_public.pem -file cipher_sm4-cbc.dat -sig signature.sig 
Signature verified successfully.
$ ./sm2 -d -kfile private.pem -file keyc.bin
�q5l��mSM2 Decryption OK
SM2 Save ok
$ ./sm4 -d -kfile decrypt.txt -iv iv.bin -file cipher_sm4-cbc.dat 
sm4-cbc decryption result:
20221415cjs

Decrypted plaintext (hex):
0000: 32 30 32 32 31 34 31 35 63 6A 73 0A
~~~

### 两⼈⼀组，在 Ubuntu或openEuler中（推荐 openEuler）中使⽤GmSSL编程实现带签名的数字信封协议。使⽤GmSSL库时，Bob发送，Alice接收。Ailice，Bob在实验中要替换为⾃⼰的8位学号+姓名。 使⽤Markdown记录详细记录实践过程，每完成⼀项git commit ⼀次。（5分）

##### Alice

~~~ shell
$ ./sm2gmssl -key
生成 SM2 密钥对...
SM2 密钥生成成功。
    SM2
        publicKey: E986F5093AC8CADB100B2A2A8B92C6DD9C7AC07A800F54E4D8575A1CBCCCA55EAC59C92F28DF3DA6EA599B8A27EFBD1D91C9F3A18721EB31CDAA04316C6AED04
        privateKey: 216567971c3c2b118a4f28b6114cecf5a2219eb84b82cb7a06a290621690bea2
$ ./sm4 -key
随机生成的密钥: 01 EC B5 6D 52 43 DB 81 E5 B5 E6 BE 9B 93 B1 F7
key Save ok
$ ./sm4 -iv
随机生成的IV: 25 19 98 8C 8E F4 23 44 F3 8C 5E CE B9 61 9A 14
iv Save ok
$ ./sm4 -e -key key.bin -iv iv.bin -file plain.txt
密文 (240 字节): 54 FE 1C 70 36 3D AE 68 3D A3 A2 35 AD AD D7 D1 C9 29 B0 39 1E 8A 8E 75 A7 90 52 66 C7 D4 3A 53 DA 3E 0D BA EA B6 05 5A C1 3A A9 AF 66 E4 A8 18 09 5E 5E 46 95 F9 05 B9 4B 3B EC 4D 26 E
7 5B 8B AA 47 76 50 67 11 08 CF 56 9C AF F0 06 22 99 37 9E 53 50 CC CA 3C 93 E2 1D CC 75 64 64 C0 DB B6 BC 9F DC 8E 7A 6F 1D 47 17 DC E4 48 8A 5E 7C FD 7A 34 E2 F6 42 92 79 9B 62 B0 CE 7C ED 78 6B D9 7
A 87 03 29 DB E6 2E 00 21 97 C8 8A 5D 89 3F EB 88 33 34 14 17 E8 8C 4F 1F 87 3D 05 EE 94 31 12 C1 CF 3E 4B B9 0F C6 24 0B 56 52 4C 98 BB 09 EB FF 3F 3F A4 64 6A 4A 3E B9 38 ED 8D C1 33 5B 0A C1 9E 61 D2 03 8B 46 9C 1C 65 ED F7 13 26 CB B3 33 B0 24 0B 0A 66 51 C3 E4 89 4E 39 95 FE 57 F8 7A 15 4B 7F 65 69 22 C6 48 D7 15 CD 6A 45 54 8F
Save ok
$ ./sm2gmssl -e -kfile public_key.bin -file key.bin 
加密成功。
密文: 30790220504834525F9552F043732F408FA2A1E426D2669F6B6AF6E58D2549B24A4B63DC022100E20BD809E497E3A940098687B9C1ABAD7C387AF41B804B3D60A2281075C79D300420623878EE1DE175B29EAA4370B6449B6F93E0BFC17E46CC2DA7245FF8C4B3DC1D04101466D03D58214EDCF08341A1CFF7F781
Save ok
$ ./sm2gmssl -s -pri private_key.bin -pub public_key.bin -file ciphertext.txt 
签名成功。
签名: 30460221009D8116FE786595B27F29D42F38DC57366A8C9F1005175DEFFF4A19F7D07E734D022100CFA35F37852870D2490A0E7E2D7867631C78DECB9E76FAD847D47B5ACF99E011
Save ok
~~~

##### Bob

~~~ shell
$ ./sm2gmssl -v -kfile public_key.bin -file ciphertext.txt -signature signature.sig 
��Z�:��f��5�����^^F���K;�M&�[��GvP�V���"�7�SP��<���udd�۶��܎zoG��H�^|�z4��B�y�b��|�xk�z�)��.
签名: 30460221009D8116FE786595B27F29D42F38DC57366A8C9F1005175DEFFF4A19F7D07E734D022100CFA35F37852870D2490A0E7E2D7867631C78DECB9E76FAD847D47B5ACF99E011
签名验证成功。
$ ./sm2gmssl -d -kfile private_key.bin -file encrypt.txt 
解密密文...
解密成功。
解密后的明文: �mRCہ�澛���
Save ok

$ ./sm4 -d -key decrypt.txt -iv iv.bin -file ciphertext.txt 
解密后的明文 (224 字节): 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73
 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33
 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35 32 30 32 32 31 34 31 35 63 6A 73 31 32 33 34 35
Save ok
$ cat decryptedtext.txt 
20221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs1234520221415cjs12345
~~~

### 实验记录中提交 gitee 课程项目链接，提交本次实验相关 git log运行结果

### 提交要求：

- 提交实践过程Markdown和转化的PDF文件
- 代码，文档托管到gitee或github等，推荐 gitclone 
- 记录实验过程中遇到的问题，解决过程，反思等内容，完成实验报告相关内容

